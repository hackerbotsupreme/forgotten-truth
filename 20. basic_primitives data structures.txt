
// JavaScript data types and data structures

// Dynamic and weak typing
// JavaScript is a dynamic language with dynamic types.
//Variables in JavaScript are not directly associated 
//with any particular value type, and any variable 
//can be assigned(and re - assigned) values of any types:

// JS
// Copy to Clipboard
let foo = 42; // foo is now a number
foo = "bar"; // foo is now a string
foo = true; // foo is now a boolean
// JavaScript is also a weakly typed language, 
//which means it allows implicit type conversion 
//when an operation involves mismatched types, 
//instead of throwing type errors.

//     JS
// Copy to Clipboard
const foo = 42; // foo is a number
const result = foo + "1"; // JavaScript coerces foo to a string, so it can be concatenated with the other operand
console.log(result); // 421
// Implicit coercions are very convenient, 
//but can create subtle bugs when conversions 
//happen where they are not expected, 
//or where they are expected to happen 
//in the other direction(for example, 
//string to number instead of number to string). 
//For symbols and BigInts, JavaScript has 
//intentionally disallowed certain implicit 
///type conversions.

// Primitive values
// All types except Object define immutable 
//values represented directly at the lowest 
//level of the language.We refer to values 
//of these types as primitive values.

// All primitive types, except null, can be 
//tested by the typeof operator.typeof null 
//returns "object", so one has to use === null to 
//test for null.

// All primitive types, except null 
// and undefined, have their corresponding 
// object wrapper types, which provide 
// useful methods for working with the 
// primitive values.For example,
// the Number object provides methods like 
// toExponential().When a property is accessed 
// on a primitive value, JavaScript automatically 
// wraps the value into the corresponding 
// wrapper object and accesses the property 
// on the object instead.However, accessing 
// a property on null or undefined throws 
// a TypeError exception, which necessitates 
// the introduction of the optional chaining operator.

// Type	        typeof return value	        Object wrapper
// Null	           "object"	                        N / A
// Undefined	   "undefined"	                    N / A
// Boolean	        "boolean"	                    Boolean
// Number	        "number"	                    Number
// BigInt	        "bigint"	                    BigInt
// String	        "string"	                    String
// Symbol	        "symbol"	                    Symbol

// The object wrapper classes' reference pages contain 
//more information about the methods and properties 
//available for each type, as well as detailed descriptions 
//for the semantics of the primitive types themselves.

// Null type
// The Null type is inhabited by exactly one value: null.

// Undefined type
// The Undefined type is inhabited by exactly one 
//value: undefined.

//Conceptually, undefined indicates the absence 
//of a value, while null indicates the absence of 
//an object(which could also make up an excuse for 
//typeof null === "object").The language usually 
//defaults to undefined when something is devoid of a value:

// A return statement with no value(return;) 
//implicitly returns undefined.
// Accessing a nonexistent object property(obj.iDontExist) 
//returns undefined.
// A variable declaration without initialization(let x;) 
//implicitly initializes the variable to undefined.
// Many methods, such as Array.prototype.find() 
//and Map.prototype.get(), return undefined when 
//no element is found.
// null is used much less often in the core language.
//The most important place is the end of the prototype chain 
//— subsequently, methods that interact with prototypes, 
//such as Object.getPrototypeOf(), Object.create(), etc., 
//accept or return null instead of undefined.

// null is a keyword, but undefined is a normal 
//identifier that happens to be a global property.
//In practice, the difference is minor, since 
//undefined should not be redefined or shadowed.

// Boolean type
// The Boolean type represents a logical entity 
//and is inhabited by two values: true and false.

// Boolean values are usually used for conditional 
//operations, including ternary operators, if...else, 
//while, etc.

// Number type
// The Number type is a double - precision 64 - bit binary 
//format IEEE 754 value.It is capable of storing positive 
//floating - point numbers between 2 - 1074(Number.MIN_VALUE) 
//and 21024(Number.MAX_VALUE) as well as negative floating 
//- point numbers between - 2 - 1074 and - 21024, but 
//it can only safely store integers in the range - (253 − 1) 
//(Number.MIN_SAFE_INTEGER) to 253 − 1(Number.MAX_SAFE_INTEGER).Outside this range, JavaScript can no longer safely represent integers; they will instead be represented by a double - precision floating point approximation.You can check if a number is within the range of safe integers using Number.isSafeInteger().

// Values outside the range ±(2 - 1074 to 21024) are automatically converted:

// Positive values greater than Number.MAX_VALUE are converted to + Infinity.
// Positive values smaller than Number.MIN_VALUE are converted to + 0.
// Negative values smaller than - Number.MAX_VALUE are converted to - Infinity.
// Negative values greater than - Number.MIN_VALUE are converted to - 0.
//     + Infinity and - Infinity behave similarly to mathematical infinity, but with some slight differences; see Number.POSITIVE_INFINITY and Number.NEGATIVE_INFINITY for details.

// The Number type has only one value with multiple representations: 0 is represented as both - 0 and + 0(where 0 is an alias for +0).In practice, there is almost no difference between the different representations; for example, +0 === -0 is true.However, you are able to notice this when you divide by zero:

// JS
// Copy to Clipboard
console.log(42 / +0); // Infinity
console.log(42 / -0); // -Infinity
// NaN("Not a Number") is a special kind of 
// number value that's typically encountered 
// when the result of an arithmetic operation 
// cannot be expressed as a number. It is also 
// the only value in JavaScript that is not 
// equal to itself.

// Although a number is conceptually 
//a "mathematical value" and is always implicitly 
//floating - point - encoded, JavaScript provides 
//bitwise operators.When applying bitwise operators, 
//the number is first converted to a 32 - bit integer.

//Note: Although bitwise operators can be used to 
//represent several Boolean values within 
//a single number using bit masking, this is 
//usually considered a bad practice.JavaScript 
//offers other means to represent a set of 
//Booleans(like an array of Booleans, or an 
//object with Boolean values assigned to 
//named properties). Bit masking also tends 
//to make the code more difficult to read, 
//understand, and maintain.

// It may be necessary to use such 
//techniques in very constrained environments, 
//like when trying to cope with the limitations 
//of local storage, or in extreme cases(such 
//as when each bit over the network counts).This 
//technique should only be considered when 
//it is the last measure that can be taken 
//to optimize size.

// BigInt type
// The BigInt type is a numeric primitive 
//in JavaScript that can represent integers 
//with arbitrary magnitude.With BigInts, you 
//can safely store and operate on large 
//integers even beyond the safe integer 
// limit(Number.MAX_SAFE_INTEGER // 9007199254740991) 
// for Numbers.

// A BigInt is created by appending 
// n to the end of an integer or by calling 
// the BigInt() function.

// This example demonstrates where 
// incrementing the Number.MAX_SAFE_INTEGER 
// returns the expected result:

// JS
// Copy to Clipboard
// // BigInt
const x = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n
x + 1n === x + 2n; // false because 9007199254740992n and 9007199254740993n are unequal

// Number
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true because both are 9007199254740992
// You can use most operators to work with BigInts, 
// including +, *, -, **, and % — the only forbidden 
// one is >>>.A BigInt is not strictly equal to a 
// Number with the same mathematical value, but it 
// is loosely so.

// BigInt values are neither always more precise 
// nor always less precise than numbers, 
// since BigInts cannot represent fractional 
// numbers, but can represent big integers 
// more accurately.Neither type entails the 
// other, and they are not mutually 
// substitutable.A TypeError is thrown if 
// BigInt values are mixed with regular 
// numbers in arithmetic expressions, or 
// if they are implicitly converted to each other.

// String type
// The String type represents textual data 
// and is encoded as a sequence of 16 - bit 
// unsigned integer values representing 
// UTF - 16 code units.Each element in the 
// string occupies a position in the string.The 
// first element is at index 0, the next at index 1, 
// and so on.The length of a string is the 
// number of UTF - 16 code units in it, 
// which may not correspond to the actual 
// number of Unicode characters; see the 
// String reference page for more details.

// JavaScript strings are immutable.
// This means that once a string is created, 
// it is not possible to modify it.String methods 
// create new strings based on the content of the 
// current string — for example:

// A substring of the original using substring().
// A concatenation of two strings using the 
// concatenation operator (+) or concat().
// Beware of "stringly-typing" your code!
// It can be tempting to use strings to 
// represent complex data.Doing this comes 
// with short - term benefits:

// It is easy to build complex strings 
// with concatenation.
// Strings are easy to debug(what you see printed 
// is always what is in the string).
// Strings are the common denominator of 
// a lot of APIs(input fields, local storage values, 
// fetch() responses when using Response.text(), etc.) 
// and it can be tempting to only work with strings.
// With conventions, it is possible to represent 
// any data structure in a string.This does not 
// make it a good idea.For instance, with a 
// separator, one could emulate a list(while 
// a JavaScript array would be more suitable).
// Unfortunately, when the separator is used 
// in one of the "list" elements, then, 
// the list is broken.An escape character 
// can be chosen, etc.All of this requires 
// conventions and creates an unnecessary 
// maintenance burden.

// Use strings for textual data.When 
// representing complex data, parse strings,
//  and use the appropriate abstraction.

// Symbol type
// A Symbol is a unique and immutable 
// primitive value and may be used as the 
// key of an Object property(see below).In 
// some programming languages, Symbols are 
// called "atoms".The purpose of symbols 
// is to create unique property keys that 
// are guaranteed not to clash with keys 
// from other code.

//     Objects
// In computer science, an object is 
//a value in memory which is possibly 
//referenced by an identifier.In JavaScript, 
//objects are the only mutable 
//values.Functions are, in fact, also 
//objects with the additional capability 
//of being callable.

//     Properties
// In JavaScript, objects can be seen 
//as a collection of properties.With 
// the object literal syntax, 
//a limited set of properties are 
//initialized; then properties can be 
//added and removed.Object properties 
//are equivalent to key - value pairs.
//Property keys are either strings 
//or symbols.Property values can be 
//values of any type, including other 
//objects, which enables building 
//complex data structures.

// There are two types of 
//object properties: The data property 
//and the accessor property.Each property 
//has corresponding attributes.Each attribute 
//is accessed internally by the JavaScript 
//engine, but you can set them through 
//Object.defineProperty(), or read them 
//through Object.getOwnPropertyDescriptor().
//You can read more about the various nuances 
//on the Object.defineProperty() page.

// Data property
// Data properties associate a key with 
//a value.It can be described by the 
//following attributes:

// value
// The value retrieved by a get access 
//of the property.Can be any JavaScript value.

//     writable
// A boolean value indicating if the 
//property can be changed with an assignment.

//     enumerable
// A boolean value indicating if the 
//property can be enumerated by a for...in 
//loop.See also Enumerability and 
//ownership of properties for how 
//enumerability interacts with 
//other functions and syntaxes.

//     configurable
// A boolean value indicating if the 
//property can be deleted, can be changed 
//to an accessor property, and can have 
//its attributes changed.

// Accessor property
// Associates a key with one of two 
//accessor functions(get and set) to 
//retrieve or store a value.

//Note: It's important to recognize 
//it's accessor property — not accessor 
//method.We can give a JavaScript object 
//class-like accessors by using a function 
//as a value — but that doesn't make 
//the object a class.

// An accessor property has the following attributes:

// get
// A function called with an empty 
//argument list to retrieve the property 
//value whenever a get access to the value 
// is performed.See also getters.May be undefined.

//     set
// A function called with an argument 
// that contains the assigned value.Executed 
// whenever a specified property is attempted 
// to be changed.See also setters.May be undefined.

//     enumerable
// A boolean value indicating if the property 
// can be enumerated by a for...in loop.See 
// also Enumerability and ownership of 
// properties for how enumerability interacts 
// with other functions and syntaxes.

//     configurable
// A boolean value indicating if the property 
// can be deleted, can be changed to a data 
// property, and can have its attributes changed.

// The prototype of an object points to another 
// object or to null — it's conceptually 
// a hidden property of the object, 
// commonly represented as [[Prototype]]. 
//Properties of the object's[[Prototype]] 
//can also be accessed on the object itself.

// Objects are ad - hoc key - value pairs, 
//so they are often used as maps.However, 
//there can be ergonomics, security, and 
//performance issues.Use a Map for 
//storing arbitrary data instead.The 
//Map reference contains a more detailed 
//discussion of the pros & cons between 
//plain objects and maps for storing 
//key - value associations.

//     Dates
// When representing dates, the best 
//choice is to use the built -in Date 
//utility in JavaScript.

// Indexed collections: Arrays and typed Arrays
// Arrays are regular objects for which 
//there is a particular relationship between 
//integer - keyed properties and the length property.

//Additionally, arrays inherit from Array.prototype, 
//which provides a handful of convenient methods 
//to manipulate arrays.For example, indexOf() 
//searches a value in the array and push() 
//appends an element to the array.This makes 
//Arrays a perfect candidate to represent ordered lists.

// Typed Arrays present an array - like view
// of an underlying binary data buffer, and 
//offer many methods that have similar 
//semantics to the array counterparts. 
//"Typed array" is an umbrella term for 
//a range of data structures, including 
//Int8Array, Float32Array, etc.Check 
//the typed array page for more information.
//Typed arrays are often used in conjunction 
//with ArrayBuffer and DataView.

// Keyed collections: Maps, Sets, WeakMaps, WeakSets
// These data structures take object 
// references as keys.Set and WeakSet 
// represent a collection of unique 
// values, while Map and WeakMap represent 
// a collection of key - value associations.

// You could implement Maps and Sets 
// yourself.However, since objects cannot
//  be compared(in the sense of < "less than", 
// for instance), neither does the engine 
// expose its hash function for objects, 
// look - up performance would necessarily 
// be linear.Native implementations of 
// them(including WeakMaps) can have look - 
// up performance that is approximately 
// logarithmic to constant time.

//     Usually, to bind data to a DOM node, 
// one could set properties directly on the 
// object, or use data -* attributes.This has 
// the downside that the data is available to 
// any script running in the same context.Maps 
// and WeakMaps make it easy to privately bind 
// data to an object.

// WeakMap and WeakSet only allow garbage - 
// collectable values as keys, which are either 
// objects or non - registered symbols, and the 
// keys may be collected even when they remain in 
// the collection.They are specifically used for 
// memory usage optimization.

// Structured data: JSON
// JSON(JavaScript Object Notation) is a 
// lightweight data - interchange format, 
// derived from JavaScript, but used by many 
// programming languages.JSON builds universal 
// data structures that can be transferred 
// between different environments and even 
// across languages.See JSON for more details.

// More objects in the standard library
// JavaScript has a standard library of 
// built -in objects.Read the reference to 
// find out more about the built -in objects.

// Type coercion
// As mentioned above, JavaScript is a weakly 
// typed language.This means that you can often 
// use a value of one type where another type is 
// expected, and the language will convert it to 
// the right type for you.To do so, JavaScript 
// defines a handful of coercion rules.

// Primitive coercion
// The primitive coercion process is used where 
// a primitive value is expected, but there's no 
// strong preference for what the actual type should 
// be. This is usually when a string, a number, or 
// a BigInt are equally acceptable. For example:

// The Date() constructor, when it receives one 
// argument that's not a Date instance — strings 
// represent date strings, while numbers represent 
// timestamps.

// The + operator — if one operand is a string, 
// string concatenation is performed; otherwise,
//  numeric addition is performed.

//     The == operator — if one operand is a 
// primitive while the other is an object, the 
// object is converted to a primitive value with 
// no preferred type.

// This operation does not do any conversion 
// if the value is already a primitive.Objects 
// are converted to primitives by calling 
// its[@@toPrimitive]()(with "default" as hint),
//  valueOf(), and toString() methods, in that 
// order.Note that primitive conversion calls 
// valueOf() before toString(), which is similar 
// to the behavior of number coercion but different 
// from string coercion.

//The[@@toPrimitive]() method, if present, 
// must return a primitive — returning an 
// object results in a TypeError.For valueOf() 
// and toString(), if one returns an object, 
// the return value is ignored and the other's 
// return value is used instead; if neither is 
// present, or neither returns a primitive, 
// a TypeError is thrown. For example, in 
// the following code:

// JS
// Copy to Clipboard
console.log({} + []); // "[object Object]"
// Neither { } nor[] have a[@@toPrimitive]() 
// method.Both { } and[] inherit valueOf() from 
// Object.prototype.valueOf, which returns the 
// object itself.Since the return value is an 
// object, it is ignored.Therefore, toString() 
// is called instead. { }.toString() returns
//  "[object Object]", while [].toString() returns "", 
// so the result is their concatenation: "[object Object]".

//The[@@toPrimitive]() method always takes 
// precedence when doing conversion to any 
// primitive type.Primitive conversion generally 
// behaves like number conversion, because 
// valueOf() is called in priority; however, 
// objects with custom[@@toPrimitive]() methods 
// can choose to return any primitive.Date and 
// Symbol objects are the only built -in objects 
// that override the[@@toPrimitive]() 
// method.Date.prototype[@@toPrimitive]() 
// treats the "default" hint as if it's "string", 
// while Symbol.prototype[@@toPrimitive]() ignores 
// the hint and always returns a symbol.
// 

// Numeric coercion
// There are two numeric types: Number and 
// BigInt.Sometimes the language specifically 
// expects a number or a BigInt(such as 
// Array.prototype.slice(), where the index 
// must be a number); other times, it may 
// tolerate either and perform different 
// operations depending on the operand's type. 
// For strict coercion processes that do not 
// allow implicit conversion from the other type, 
// see number coercion and BigInt coercion.

// Numeric coercion is nearly the same as number 
// coercion, except that BigInts are returned as- is 
// instead of causing a TypeError.Numeric coercion 
// is used by all arithmetic operators, since they 
// are overloaded for both numbers and BigInts.The 
// only exception is unary plus, which always does 
// number coercion.

// Other coercions
// All data types, except Null, Undefined, and 
// Symbol, have their respective coercion 
// process.See string coercion, boolean coercion, 
// and object coercion for more details.

// As you may have noticed, there are three 
// distinct paths through which objects may 
// be converted to primitives:

// Primitive coercion: 
// [@@toPrimitive]("default") → valueOf() → toString()

// Numeric coercion, number coercion, 
// BigInt coercion: [@@toPrimitive]("number") → valueOf() → toString()

// String coercion: [@@toPrimitive]("string") → toString() → valueOf()

// In all cases, [@@toPrimitive](), if present, 
// must be callable and return a primitive, while 
// valueOf or toString will be ignored if they are 
// not callable or return an object.At the end of 
// the process, if successful, the result is guaranteed 
// to be a primitive.The resulting primitive is then 
// subject to further coercions depending on the context.

// Keyed collections
// This chapter introduces collections of data 
// which are indexed by a key; Map and Set objects 
// contain elements which are iterable in the order of insertion.

// Maps
// Map object
// A Map object is a simple key/value map 
// and can iterate its elements in insertion order.

// The following code shows some basic 
// operations with a Map. See also the Map 
// reference page for more examples and the 
// complete API. You can use a for...of loop 
// to return an array of [key, value] for each iteration.

// JS
// Copy to Clipboard
const sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0

// Certainly! Let's delve into the differences 
// between JavaScript **Map** and **Object**, 
// along with illustrative code examples 
// for each point:

// 1. **Keys and Values**:
//    - **Map**: Map objects allow keys of **any data type**, including strings, numbers, arrays, and even other objects.
//    - **Object**: Object keys are restricted to **strings or symbols**.
//    - **Example**:
//      ```javascript
const myMap = new Map();
const myObject = {};

const key1 = [1, 2, 3];
const key2 = { name: "John" };

myMap.set(key1, "Value for key1");
myObject[key2] = "Value for key2";

console.log(myMap.get(key1)); // "Value for key1"
console.log(myObject[key2]); // "Value for key2"
// ```
// 2. **Size**:
//    - **Map** provides a built-in `size` property to easily determine the number of entries.
//    - **Object** requires manual tracking of size.
//    - **Example**:
//      ```javascript
console.log(myMap.size); // 1
console.log(Object.keys(myObject).length); // 1
//      ```
// 3. **Iteration Order**:
//    - **Map** guarantees iteration in **insertion order** (useful for consistent behavior across browsers).
//    - **Object** does not guarantee any specific order.
//    - **Example**:
//      ```javascript
myMap.set("a", 1);
myMap.set("b", 2);

for (const [key, value] of myMap) {
  console.log(key, value);
}
// Output: "a" 1, "b" 2
//  ```
// 4. **Prototype Inheritance**:
//    - **Map** does not inherit any default keys (no prototype chain).
//    - **Object** inherits properties from its prototype (e.g., `Object.prototype`).
//    - **Example**:
//  ```javascript
const myEmptyMap = Object.create(null);
myEmptyMap["key"] = "Value"; // No prototype inheritance

console.log(myEmptyMap.key); // "Value"
//      ```
// 5. **Use Cases**:
//    - **Map**: Use when keys are unknown until runtime or when keys and values have varying data types.
//    - **Object**: Use when logic operates on individual elements or when all keys and values are of the same type.

// Use objects when there is logic that 
//operates on individual elements.

// Certainly! Let's explore why we might choose an **Object** over a **Map** in certain scenarios:

// 1. **Logic Operating on Individual Elements**:
//    - **Use Case**: When you need to perform specific logic or computations based on individual elements (keys and values).
//    - **Reason to Choose Object**:
//      - Objects allow you to define custom methods and behavior for specific properties.
//      - You can attach functions (methods) directly to object properties.
//      - Objects are well-suited for scenarios where you want to encapsulate behavior related to specific keys.
//    - **Example**:
//  ```javascript
const person = {
  name: "Alice",
  age: 30,
  occupation: "Engineer",
  // Custom method to check if the person is an adult
  isAdult() {
    return this.age >= 18;
  },
};

// Logic operating on individual elements
if (person.isAdult()) {
  console.log(`${person.name} is an adult.`);
} else {
  console.log(`${person.name} is a minor.`);
}
//    ```
//  - In this example, we've added a custom method `isAdult()` to the `person` object. This method encapsulates the logic for determining whether the person is an adult.

// 2. **Primitive Values as Keys**:
//    - **Use Case**: When you need to use primitive values (numbers, booleans, etc.) as keys.
//    - **Reason to Choose Object**:
//      - Objects treat any key (including primitive values) as a string.
//      - If you want to use non-string keys (e.g., numbers) directly, objects are more convenient.
//    - **Example**:
//      ```javascript
const scores = {
  1: "Low",
  2: "Medium",
  3: "High",
};

console.log(scores[2]); // "Medium"
//      ```
//    - Here, we use numeric keys directly in the object.

// 3. **Existing Prototype Chain**:
//    - **Use Case**: When you want to inherit properties from a prototype (e.g., `Object.prototype`).
//    - **Reason to Choose Object**:
//      - Objects have a prototype chain by default.
//      - If you need to access common methods or properties from the prototype, objects are suitable.
//    - **Example**:
//      ```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function () {
  console.log(`Hello, ${this.name}!`);
};

const alice = new Person("Alice");
alice.greet(); // "Hello, Alice!"
//      ```
//    - In this example, `alice` inherits the `greet` method from the prototype of `Person`.

// Remember that both **Map** and **Object** have their strengths, and the choice depends on your specific requirements. Use maps when you need flexible keys, consistent iteration order, and built-in size tracking. Use objects when you want to operate on individual elements or when you need prototype inheritance. 🤔🔍

// WeakMap object
// A WeakMap is a collection of key/value pairs 
// whose keys must be objects or non-registered 
// symbols, with values of any arbitrary JavaScript 
// type, and which does not create strong references 
// to its keys. That is, an object's presence as a key 
// in a WeakMap does not prevent the object from being 
// garbage collected. Once an object used as a key 
// has been collected, its corresponding values in 
// any WeakMap become candidates for garbage 
// collection as well — as long as they aren't 
// strongly referred to elsewhere. The only 
// primitive type that can be used as a WeakMap 
// key is symbol — more specifically, non-registered 
// symbols — because non-registered symbols are 
// guaranteed to be unique and cannot be re-created.

// The WeakMap API is essentially the same as the 
// Map API. However, a WeakMap doesn't allow 
// observing the liveness of its keys, which 
// is why it doesn't allow enumeration. So there 
// is no method to obtain a list of the keys in 
// a WeakMap. If there were, the list would depend 
// on the state of garbage collection, introducing 
// non-determinism.

// For more information and example code, see also 
// "Why WeakMap?" on the WeakMap reference page.

// One use case of WeakMap objects is to store 
// private data for an object, or to hide 
// implementation details. The following 
// example is from Nick Fitzgerald's blog 
// post "Hiding Implementation Details with 
// ECMAScript 6 WeakMaps". The private data 
// and methods belong inside the object and 
// are stored in the privates object, which 
// is a WeakMap. Everything exposed on the 
// instance and prototype is public; everything 
// else is inaccessible from the outside world 
// because privates is not exported from the module.

// JS
// Copy to Clipboard
const privates = new WeakMap();

function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};

module.exports = Public;
// Sets
// Set object
// Set objects are collections of unique values. 
// You can iterate its elements in insertion order. 
// A value in a Set may only occur once; it is 
// unique in the Set's collection.

// The following code shows some basic 
// operations with a Set. See also the Set 
// reference page for more examples and 
// the complete API.

// JS
// Copy to Clipboard
const mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2
const mySet = new Set();
console.log(typeof mySet)// object
console.log(Object.getPrototypeOf(mySet))
for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
// Converting between Array and Set
// You can create an Array from a Set 
// using Array.from or the spread syntax. 
// Also, the Set constructor accepts an 
// Array to convert in the other direction.

// Note: Set objects store unique values—so 
// any duplicate elements from an Array
//  are deleted when converting!

// JS
// Copy to Clipboard
Array.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
// Array and Set compared
// Traditionally, a set of elements has been
// stored in arrays in JavaScript in a lot of
// situations. The Set object, however, has some advantages:

// Deleting Array elements by value
// (arr.splice(arr.indexOf(val), 1)) is very slow.

// Set objects let you delete elements
// by their value. With an array, you would
// have to splice based on an element's index.

// The value NaN cannot be found with
// indexOf in an array.

// Set objects store unique values. You
// don't have to manually keep track of duplicates.

// WeakSet object
// WeakSet objects are collections of
// garbage-collectable values, including objects
// and non-registered symbols. A value in the
// WeakSet may only occur once. It is unique
// in the WeakSet's collection.

// The main differences to the Set object are:

// In contrast to Sets, WeakSets are collections
// of objects or symbols only, and not of arbitrary
// values of any type.

// The WeakSet is weak: References to objects in
// the collection are held weakly. If there is no
// other reference to an object stored in the WeakSet,
// they can be garbage collected. That also means that
// there is no list of current objects stored in the collection.

// WeakSets are not enumerable.
// The use cases of WeakSet objects are limited.
// They will not leak memory, so it can be safe
// to use DOM elements as a key and mark them for
// tracking purposes, for example.

// Key and value equality of Map and Set
// Both the key equality of Map objects and the
// value equality of Set objects are based on
// the SameValueZero algorithm:

// Equality works like the identity comparison operator ===.
// -0 and +0 are considered equal.
// NaN is considered equal to itself (contrary to ===).


// Memory management
// Low-level languages like C, have manual 
// memory management primitives such as 
// malloc() and free(). In contrast, JavaScript 
// automatically allocates memory when objects 
// are created and frees it when they are not 
// used anymore (garbage collection). This 
// automaticity is a potential source of 
// confusion: it can give developers the 
// false impression that they don't need to 
// worry about memory management.

// Memory life cycle
// Regardless of the programming language, 
// the memory life cycle is pretty much 
// always the same:

// Allocate the memory you need
// Use the allocated memory (read, write)
// Release the allocated memory when it 
// is not needed anymore
// The second part is explicit in all languages. 
// The first and last parts are explicit 
// in low-level languages but are mostly 
// implicit in high-level languages like JavaScript.

// Allocation in JavaScript
// Value initialization
// In order to not bother the programmer 
// with allocations, JavaScript will 
// automatically allocate memory when 
// values are initially declared.

// JS
// Copy to Clipboard
const n = 123; // allocates memory for a number
const s = "azerty"; // allocates memory for a string

const o = {
    a: 1,
    b: null,
}; // allocates memory for an object and contained values

// (like object) allocates memory 
// for the array and
// contained values
const a = [1, null, "abra"];

function f(a) {
    return a + 2;
} // allocates a function (which is a callable object)

// function expressions also allocate an object
someElement.addEventListener(
    "click",
    () => {
        someElement.style.backgroundColor = "blue";
    },
    false,
);
// Allocation via function calls
// Some function calls result in object allocation.

// JS
// Copy to Clipboard
const d = new Date(); // allocates a Date object

const e = document.createElement("div"); // allocates a DOM element
// Some methods allocate new values or objects:

// JS
// Copy to Clipboard
const s = "azerty";
const s2 = s.substr(0, 3); // s2 is a new string
// Since strings are immutable values,
// JavaScript may decide to not allocate memory,
// but just store the [0, 3] range.

const a = ["ouais ouais", "nan nan"];
const a2 = ["generation", "nan nan"];
const a3 = a.concat(a2);
// new array with 4 elements being
// the concatenation of a and a2 elements.
// Using values
// Using values basically means reading and 
// writing in allocated memory. This can be 
// done by reading or writing the value of 
// a variable or an object property or even 
// passing an argument to a function.

// Release when the memory is not needed anymore
// The majority of memory management issues 
// occur at this phase. The most difficult 
// aspect of this stage is determining when 
// the allocated memory is no longer needed.

// Low-level languages require the developer 
// to manually determine at which point in the 
// program the allocated memory is no longer 
// needed and to release it.

// Some high-level languages, such as JavaScript, 
// utilize a form of automatic memory management 
// known as garbage collection (GC). The purpose 
// of a garbage collector is to monitor memory 
// allocation and determine when a block of 
// allocated memory is no longer needed and 
// reclaim it. This automatic process is an 
// approximation since the general problem of 
// determining whether or not a specific piece
//  of memory is still needed is undecidable.

// Garbage collection
// As stated above, the general problem of 
// automatically finding whether some memory 
// "is not needed anymore" is undecidable. 
// As a consequence, garbage collectors 
// implement a restriction of a solution to 
// the general problem. This section will 
// explain the concepts that are necessary 
// for understanding the main garbage collection 
// algorithms and their respective limitations.

// References
// The main concept that garbage collection
//  algorithms rely on is the concept of reference. 
// Within the context of memory management, an 
// object is said to reference another object 
// if the former has access to the latter (either 
//implicitly or explicitly). For instance, 
//a JavaScript object has a reference to its 
// prototype (implicit reference) and to its 
// properties values (explicit reference).

// In this context, the notion of an "object" 
// is extended to something broader than regular 
// JavaScript objects and also contain function 
// scopes (or the global lexical scope).

// Reference-counting garbage collection
// Note: no modern JavaScript engine uses 
// reference-counting for garbage 
// collection anymore.

// This is the most naïve garbage collection 
// algorithm. This algorithm reduces the problem 
// from determining whether or not an object is 
// still needed to determining if an object still
//  has any other objects referencing it. An 
// object is said to be "garbage", or collectible 
// if there are zero references pointing to it.

// For example:

// JS
// Copy to Clipboard
let x = {
    a: {
        b: 2,
    },
};
// 2 objects are created. One is referenced 
// by the other as one of its properties.

// The other is referenced by virtue of being 
// assigned to the 'x' variable.
// Obviously, none can be garbage-collected.

let y = x;
// The 'y' variable is the second thing that 
// has a reference to the object.

x = 1;
// Now, the object that was originally in 'x' 
// has a unique reference
// embodied by the 'y' variable.

let z = y.a;
// Reference to 'a' property of the object.
// This object now has 2 references: one as a property,
// the other as the 'z' variable.

y = "mozilla";
// The object that was originally in 'x' has now zero
// references to it. It can be garbage-collected.
// However its 'a' property is still referenced by
// the 'z' variable, so it cannot be freed.

z = null;
// The 'a' property of the object originally in x
// has zero references to it. It can be garbage collected.
// There is a limitation when it comes 
// to circular references. In the following example, 
// two objects are created with properties that 
// reference one another, thus creating a cycle. 
// They will go out of scope after the function 
// call has completed. At that point they become 
// unneeded and their allocated memory should be 
// reclaimed. However, the reference-counting 
// algorithm will not consider them reclaimable 
// since each of the two objects has at least one 
// reference pointing to them, resulting in neither 
// of them being marked for garbage collection. 
// Circular references are a common cause 
// of memory leaks.

// JS
// Copy to Clipboard
function f() {
    const x = {};
    const y = {};
    x.a = y; // x references y
    y.a = x; // y references x

    return "azerty";
}

f();
// Mark-and-sweep algorithm
// This algorithm reduces the definition of 
// "an object is no longer needed" to "an 
// object is unreachable".

// This algorithm assumes the knowledge of 
// a set of objects called roots. In JavaScript, 
// the root is the global object. Periodically, 
// the garbage collector will start from these 
// roots, find all objects that are referenced 
// from these roots, then all objects referenced 
// from these, etc. Starting from the roots, 
// the garbage collector will thus find all 
// reachable objects and collect all 
// non-reachable objects.

// This algorithm is an improvement over the 
// previous one since an object having zero 
// references is effectively unreachable. The 
// opposite does not hold true as we have seen 
// with circular references.

// Currently, all modern engines ship a 
// mark-and-sweep garbage collector. All 
// improvements made in the field of JavaScript 
// garbage collection 
// (generational/incremental/concurrent/parallel 
// garbage collection) over the last few years 
// are implementation improvements of this 
// algorithm, but not improvements over the 
// garbage collection algorithm itself nor its 
// reduction of the definition of when "an 
// object is no longer needed".

// The immediate benefit of this approach is 
// that cycles are no longer a problem. In the 
// first example above, after the function call 
// returns, the two objects are no longer 
// referenced by any resource that is reachable 
// from the global object. Consequently, they 
// will be found unreachable by the garbage 
// collector and have their allocated 
// memory reclaimed.

// However, the inability to manually control 
// garbage collection remains. There are times 
// when it would be convenient to manually 
// decide when and what memory is released. 
// In order to release the memory of an object, 
// it needs to be made explicitly unreachable. 
// It is also not possible to programmatically 
// trigger garbage collection in JavaScript — 
// and will likely never be within the core 
// language, although engines may expose APIs 
// behind opt-in flags.

// Configuring an engine's memory model
// JavaScript engines typically offer flags 
// that expose the memory model. For example, 
// Node.js offers additional options and tools 
// that expose the underlying V8 mechanisms for 
// configuring and debugging memory issues. 
// This configuration may not be available in 
// browsers, and even less so for web pages (via 
// HTTP headers, etc.).

// The max amount of available heap memory can 
// be increased with a flag:

// BASH
// Copy to Clipboard
// node --max-old-space-size=6000 index.js
// We can also expose the garbage collector 
// for debugging memory issues using a flag 
// and the Chrome Debugger:

// BASH
// Copy to Clipboard
// node --expose-gc --inspect index.js
// Data structures aiding memory management
// Although JavaScript does not directly expose 
// the garbage collector API, the language offers 
// several data structures that indirectly observe 
// garbage collection and can be used to manage 
// memory usage.

// WeakMaps and WeakSets
// WeakMap and WeakSet are data structures 
// whose APIs closely mirror their non-weak 
// counterparts: Map and Set. WeakMap allows 
// you to maintain a collection of key-value 
// pairs, while WeakSet allows you to maintain 
// a collection of unique values, both with 
// performant addition, deletion, and querying.

// WeakMap and WeakSet got the name from 
// the concept of weakly held values. If x 
// is weakly held by y, it means that although 
// you can access the value of x via y, the 
// mark-and-sweep algorithm won't consider x as 
// reachable if nothing else strongly holds to 
// it. Most data structures, except the ones 
// discussed here, strongly holds to the objects 
// passed in so that you can retrieve them at any 
// time. The keys of WeakMap and WeakSet can be 
// garbage-collected (for WeakMap objects, the 
// values would then be eligible for garbage 
// collection as well) as long as nothing else 
// in the program is referencing the key. This 
// is ensured by two characteristics:

// WeakMap and WeakSet can only store objects 
// or symbols. This is because only objects 
// are garbage collected — primitive values 
// can always be forged (that is, 1 === 1 but {} !== {}),
//  making them stay in the collection forever. 
// Registered symbols (like Symbol.for("key")) 
// can also be forged and thus not garbage 
// collectable, but symbols created with 
// Symbol("key") are garbage collectable. 
// Well-known symbols like Symbol.iterator 
// come in a fixed set and are unique throughout 
// the lifetime of the program, similar to 
// intrinsic objects such as Array.prototype, 
// so they are also allowed as keys.
// 
// WeakMap and WeakSet are not iterable. This 
// prevents you from using 
// Array.from(map.keys()).length to observe the 
// liveliness of objects, or get hold of an 
// arbitrary key which should otherwise be 
// eligible for garbage collection. (Garbage 
// collection should be as invisible as possible.)
// In typical explanations of WeakMap and WeakSet 
// (such as the one above), it's often implied 
// that the key is garbage-collected first, 
// freeing the value for garbage collection 
// as well. However, consider the case of 
// the value referencing the key:

// JS
// Copy to Clipboard
const wm = new WeakMap();
const key = {};
wm.set(key, { key });
// Now `key` cannot be garbage collected,
// because the value holds a reference to the key,
// and the value is strongly held in the map!
// If key is stored as an actual reference, 
// it would create a cyclic reference and make 
// both the key and value ineligible for garbage 
// collection, even when nothing else references 
// key — because if key is garbage collected, it 
// means that at some particular instant, 
// value.key would point to a non-existent address, 
// which is not legal. To fix this, the entries 
// of WeakMap and WeakSet aren't actual references,
//  but ephemerons, an enhancement to the 
// mark-and-sweep mechanism. Barros et al. 
// offers a good summary of the algorithm (page 4). 
// To quote a paragraph:

// Ephemerons are a refinement of weak pairs 
// where neither the key nor the value can be 
// classified as weak or strong. The connectivity 
// of the key determines the connectivity of the 
// value, but the connectivity of the value does 
// not affect the connectivity of the key. […] when 
// the garbage collection offers support to ephemerons, 
// it occurs in three phases instead of 
// two (mark and sweep).

// As a rough mental model, think of a WeakMap 
// as the following implementation:

// Warning: This is not a polyfill nor is anywhere 
// close to how it's implemented in the engine 
// (which hooks into the garbage collection mechanism).

// JS
// Copy to Clipboard
class MyWeakMap {
    #marker = Symbol("MyWeakMapData");
    get(key) {
        return key[this.#marker];
    }
    set(key, value) {
        key[this.#marker] = value;
    }
    has(key) {
        return this.#marker in key;
    }
    delete(key) {
        delete key[this.#marker];
    }
}
// As you can see, the MyWeakMap never 
// actually holds a collection of keys. 
// It simply adds metadata to each object 
// being passed in. The object is then 
// garbage-collectable via mark-and-sweep. 
// Therefore, it's not possible to iterate 
// over the keys in a WeakMap, nor clear 
// the WeakMap (as that also relies on the 
// knowledge of the entire key collection).

// For more information on their APIs, see 
// the keyed collections guide.

// WeakRefs and FinalizationRegistry
// Note: WeakRef and FinalizationRegistry 
// offer direct introspection into the 
// garbage collection machinery. Avoid 
// using them where possible because the 
// runtime semantics are almost completely 
// unguaranteed.

// All variables with an object as value are 
// references to that object. However, such 
// references are strong — their existence 
// would prevent the garbage collector from 
// marking the object as eligible for collection. 
// A WeakRef is a weak reference to an object 
// that allows the object to be garbage 
// collected, while still retaining the 
// ability to read the object's content 
// during its lifetime.

// One use case for WeakRef is a cache 
// system which maps string URLs to large 
// objects. We cannot use a WeakMap for 
// this purpose, because WeakMap objects 
// have their keys weakly held, but not 
// their values — if you access a key, 
// you would always deterministically 
// get the value (since having access 
//to the key means it's still alive). 
// Here, we are okay to get undefined 
// for a key (if the corresponding value 
// is no longer alive) since we can just 
// re-compute it, but we don't want 
// unreachable objects to stay in the 
// cache. In this case, we can use a 
// normal Map, but with each value being 
// a WeakRef of the object instead of the 
// actual object value.

// JS
// Copy to Clipboard
function cached(getter) {
    // A Map from string URLs to WeakRefs of results
    const cache = new Map();
    return async (key) => {
        if (cache.has(key)) {
            return cache.get(key).deref();
        }
        const value = await getter(key);
        cache.set(key, new WeakRef(value));
        return value;
    };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));
// FinalizationRegistry provides an even 
// stronger mechanism to observe garbage 
// collection. It allows you to register 
// objects and be notified when they are 
// garbage collected. For example, for the 
// cache system exemplified above, even 
// when the blobs themselves are free for 
// collection, the WeakRef objects that 
// hold them are not — and over time, the 
// Map may accumulate a lot of useless 
// entries. Using a FinalizationRegistry 
// allows one to perform cleanup in this case.

// JS
// Copy to Clipboard
function cached(getter) {
    // A Map from string URLs to WeakRefs of results
    const cache = new Map();
    // Every time after a value is garbage collected, the callback is
    // called with the key in the cache as argument, allowing us to remove
    // the cache entry
    const registry = new FinalizationRegistry((key) => {
        // Note: it's important to test that the WeakRef is indeed empty.
        // Otherwise, the callback may be called after a new object has been
        // added with this key, and that new, alive object gets deleted
        if (!cache.get(key)?.deref()) {
            cache.delete(key);
        }
    });
    return async (key) => {
        if (cache.has(key)) {
            return cache.get(key).deref();
        }
        const value = await getter(key);
        cache.set(key, new WeakRef(value));
        registry.register(value, key);
        return value;
    };
}

const getImage = cached((url) => fetch(url).then((res) => res.blob()));
// Due to performance and security concerns, 
// there is no guarantee of when the callback 
// will be called, or if it will be called at all. 
// It should only be used for cleanup — and 
// non-critical cleanup. There are other ways for 
// more deterministic resource management, such 
// as try...finally, which will always execute 
// the finally block. WeakRef and FinalizationRegistry 
// exist solely for optimization of memory usage 
// in long-running programs.


// show me garbage collection in js ?
// Certainly! Let's explore **garbage collection in JavaScript**:

// 1. **What is Garbage Collection?**
//    - Garbage collection (GC) is the process of **automatically managing memory** in a programming language.
//    - It ensures that memory is allocated when needed, used during program execution, and released when no longer required.
//    - JavaScript is a **garbage-collected language**, meaning that the execution environment handles memory management.

// 2. **Memory Life Cycle**:
//    - The memory life cycle involves three major steps:
//      1. **Allocate the memory**: Reserve memory for variables, objects, and data structures.
//      2. **Use the allocated memory**: Read from or write to the allocated memory during program execution.
//      3. **Release the allocated memory**: Free up memory when it is no longer needed.

// 3. **Garbage Collection Algorithms**:
//    - JavaScript uses automated memory management through garbage collection. Let's explore some key concepts and algorithms:

//    - **Reference-Counting Garbage Collection**:
//      - Basic algorithm that scans memory to determine if an object has any other objects referring to it.
//      - An object with **zero references** is considered garbage and can be collected.
//      - Example:
//        ```javascript
// Consider the following example
const object1 = { object2: { object3: 7 } };
const object4 = object1;
object1 = 1;
const object5 = object4.object2;
object4 = "Geeks For Geeks";
object5 = null;
// Circular references can be an obstruction.
//        ```

//    - **Mark-and-Sweep Algorithm**:
//      - Most popular garbage collection method in JavaScript.
//      - It identifies **unreachable objects** by marking them during program execution.
//      - The garbage collector then sweeps through memory, freeing up unreachable objects.
//      - Circular references can be an issue.

// 4. **Why Use Garbage Collection?**
//    - Garbage collection ensures efficient memory usage and prevents memory leaks.
//    - It automatically detects and removes objects that are no longer reachable.
//    - JavaScript's garbage collector monitors all existing objects and removes those that become unreachable.

// Remember that garbage collection in JavaScript is essential for maintaining a healthy memory footprint and preventing memory-related issues. 🗑️🧹

// For more details, you can refer to the [GeeksforGeeks article](https://www.geeksforgeeks.org/garbage-collection-in-javascript/) on garbage collection in JavaScript¹..

// i mens show it via js code ?

// Certainly! Let's explore how **garbage collection** works in JavaScript using code examples:

// 1. **Reference-Counting Garbage Collection**:
//    - This algorithm scans memory to determine if an object has any other objects referring to it. An object with **zero references** is considered garbage and can be collected.
//    - Example:
//      ```javascript
// Consider the following example
const object1 = { object2: { object3: 7 } };
const object4 = object1;
object1 = 1;
const object5 = object4.object2;
object4 = "Geeks For Geeks";
object5 = null;
// Circular references can be an obstruction.
//      ```
//    - In this example:
//      - `object1` initially refers to an object with nested properties.
//      - `object4` also refers to the same object.
//      - We modify the references, and eventually, the object becomes unreachable and can be garbage-collected.

// 2. **Using WeakReferences**:
//    - Weak references allow objects to be garbage-collected even if they are used as keys in a `WeakMap`.
//    - Example:
//      ```javascript
// Using WeakReferences
let weakMap = new WeakMap();
let element = { component: "button" };
weakMap.set(element, "metadata");
// 'element' can be garbage-collected even if it's a key in 'weakMap'
//      ```

// 3. **Why Use Garbage Collection?**
//    - Garbage collection ensures efficient memory usage and prevents memory leaks.
//    - It automatically detects and removes objects that are no longer reachable.

// Remember that JavaScript's garbage collector monitors all existing objects and frees up memory for those that become unreachable. 🗑️🧹

// For more details, you can refer to the [GeeksforGeeks article](https://www.geeksforgeeks.org/garbage-collection-in-javascript/) on garbage collection in JavaScript¹. 📚

// how a weakmap looks like ?

// A **WeakMap** in JavaScript is a collection of key/value pairs where the keys must be objects or non-registered symbols, and the values can be of any arbitrary JavaScript type. Unlike regular maps, a WeakMap does not create strong references to its keys. This means that an object's presence as a key in a WeakMap does not prevent the object from being garbage collected.

// Here's how a WeakMap looks and behaves:

// 1. **Creating a WeakMap**:
//    ```javascript
const myWeakMap = new WeakMap();
//    ```

// 2. **Adding Key-Value Pairs**:
//    - You can associate values with specific keys (objects or non-registered symbols):
//      ```javascript
const key1 = {}; // An object
const key2 = Symbol("mySymbol"); // A non-registered symbol

myWeakMap.set(key1, "Value for key1");
myWeakMap.set(key2, "Value for key2");
//      ```

// 3. **Retrieving Values**:
//    - To get the value associated with a key:
//      ```javascript
console.log(myWeakMap.get(key1)); // "Value for key1"
console.log(myWeakMap.get(key2)); // "Value for key2"
//      ```

// 4. **Garbage Collection Behavior**:
//    - When the key object (e.g., `key1`) becomes unreachable (no other references to it), both the key and its associated value become eligible for garbage collection.
//    - WeakMaps allow garbage collection of values if their key objects are not strongly referenced elsewhere.

// 5. **Use Cases**:
//    - **Emulating Private Members**:
//      WeakMaps are often used to create private members in classes or objects.
//    - **Associating Metadata**:
//      You can associate metadata with an object without preventing the key object from being collected.

// Remember that a WeakMap doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. If you need a list of keys, consider using a regular **Map** instead. 🗺️🔍

// what are symbols in js ?
// **Symbols** in JavaScript are a **primitive data type** introduced in ECMAScript 6 (ES6). They serve several important purposes:

// 1. **Uniqueness**:
//    - Symbols are **immutable** (cannot be changed) and **unique**.
//    - Each symbol value is guaranteed to be different from any other symbol value.
//    - For example:
//      ```javascript
const value1 = Symbol('hello');
const value2 = Symbol('hello');
console.log(value1 === value2); // false
//      ```

// 2. **Creating Symbols**:
//    - You create a symbol using the `Symbol()` function:
//      ```javascript
const mySymbol = Symbol();
//      ```

// 3. **Symbol Description**:
//    - You can pass an optional string as a **description** when creating a symbol:
//      ```javascript
const namedSymbol = Symbol('hey');
console.log(namedSymbol); // Symbol(hey)
console.log(namedSymbol.description); // "hey"
//      ```

// 4. **Use Cases**:
//    - **Unique Object Keys**:
//      - Symbols are often used to add **unique property keys** to an object.
//      - They won't collide with keys added by other code.
//      - Example:
//        ```javascript
const id = Symbol('id');
const person = {
    name: 'Jack',
    [id]: 123, // Using symbol as a key
};
console.log(person); // { name: 'Jack', Symbol(id): 123 }
//        ```

//    - **Avoiding Duplication Issues**:
//      - Symbols help avoid duplication issues when multiple programs use the same object.
//      - Example:
//        ```javascript
// Program 1
const person1 = { name: 'Jack' };
const id = Symbol('id');
person1[id] = 12;

// Program 2 (using the same object)
const person2 = { name: 'Jack' };
person2[id] = 'Another value'; // No duplication issue
//        ```

// 5. **Symbol Methods**:
//    - Some useful methods related to symbols:
//      - `for()`: Searches for existing symbols.
//      - `keyFor()`: Returns a shared symbol key from the global symbol registry.
//      - `toSource()`: Returns a string containing the source of the Symbol object.
//      - `toString()`: Returns a string containing the description of the Symbol.

// In summary, symbols provide a way to create unique, hidden properties in objects, avoiding conflicts and enabling weak encapsulation. 🌟🔑

// For more details, you can refer to the [MDN documentation on Symbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)³. 📚

// and waht is it used for , i means what are the practical use cases for it ?

// Certainly! Let's explore the practical use cases for **JavaScript symbols**:

// 1. **Unique Property Values**:
//    - Symbols are often used to create **unique property keys** in objects.
//    - Unlike regular string keys, symbols won't accidentally clash with other property names.
//    - Example:
//      ```javascript
const id = Symbol('id');
const person = {
    name: 'Alice',
    [id]: 123, // Using a symbol as a key
};
console.log(person); // { name: 'Alice', Symbol(id): 123 }
//      ```

// 2. **Avoiding Name Clashes**:
//    - Symbols help prevent naming conflicts.
//    - For system-level properties (e.g., iteration protocol methods), using symbols ensures they won't collide with user-defined names.
//    - Example:
//  ```javascript
const iterable = {
    [Symbol.iterator]: function* () {
        yield 1;
        yield 2;
    },
};
for (const value of iterable) {
    console.log(value); // 1, 2
}
//      ```

// 3. **Emulating Private Properties**:
//    - Although not truly private, symbols can be used to create properties that are less likely to be accessed accidentally.
//    - Example:
//      ```javascript
const privateProperty = Symbol('private');
class MyClass {
    constructor() {
        this[privateProperty] = 'Secret value';
    }
    getPrivateValue() {
        return this[privateProperty];
    }
}
const instance = new MyClass();
console.log(instance.getPrivateValue()); // "Secret value"
//      ```

// 4. **Extension Hooks**:
//    - Symbols allow ECMAScript itself to introduce extension hooks without risking clashes with user-defined names.
//    - For example, symbols can define custom iteration behavior.
//    - Example (hypothetical):
//      ```javascript
const myIterable = {
    [Symbol.iterator]: function* () {
        // Custom iteration logic
    },
};
//      ```

// 5. **Custom Metadata**:
//    - Symbols can be used to associate metadata with objects.
//    - Libraries and frameworks often use symbols for internal bookkeeping.
//    - Example:
//      ```javascript
const metadataSymbol = Symbol('metadata');
const myObject = {};
myObject[metadataSymbol] = 'Some metadata';
//      ```

// Remember that while symbols were initially introduced for private properties, their primary use today is to create unique keys and avoid naming conflicts. They provide a way to extend JavaScript without polluting the global namespace. 🌟🔑

// How does garbage collection work in JavaScript?

// The short answer is: When a block of 
// memory (an object, say) is no longer 
// reachable, it is eligible to be reclaimed. 
// When, how, or whether it is reclaimed 
// is entirely up to the implementation, 
// and different implementations do it 
// differently. But at a language level, 
// it's automatic.

// For example:

function foo() {
    var bar;

    bar = new ReallyMassiveObject();
    bar.someCall();
}
// When foo returns, the object bar 
// points to is automatically available 
// for garbage collection because there 
// is nothing left that has 
// a reference to it.

// Contrast with:

function foo() {
    var bar;

    bar = new ReallyMassiveObject();
    bar.someCall();
    return bar;
}
// elsewhere
var b = foo();
// ...now a reference to the object 
// survives the call, and persists 
// until/unless the caller assigns 
// something else to b or b goes 
// out of scope.

// Also contrast with:

function foo() {
    var bar;

    bar = new ReallyMassiveObject();
    bar.someCall();
    setTimeout(function() {
        alert("Three seconds have passed");
    }, 3000);
}
// Here, even after foo returns, the 
// timer mechanism has a reference to 
// the timer callback, and the timer 
// callback — a closure — has a reference 
// to the context where it was created, 
// which in turn contains the bar variable.
//  As a result, in theory, what bar refers 
// to isn't available for garbage collection 
// immediately when foo returns. Instead, 
// it's kept around until the timer fires 
// and releases its reference to the callback, 
// making the callback and the context it 
// refers to eligible for GC. (In practice, 
// modern JavaScript engines can and do 
// optimize closures where they can. For 
// instance, in the above, static analysis 
// shows the callback doesn't refer to bar, 
// and doesn't contain any eval or 
// new Function code that might refer to 
// it dynamically at runtime, so the 
// JavaScript engine can safely leave bar 
// out of the context the function refers to, 
// thus making what it refers to eligible 
// for GC — and modern ones do). (More about 
// closures in this article.)

// JavaScript has no problem handling 
// cleaning up circular references, 
// btw, so for instance:

function foo() {
    var a, b;

    a = {};
    b = {};
    b.refa = a;
    a.refb = b;
}
// When foo returns, the fact that a 
// is referring to b and vice-versa isn't 
// a problem. Since nothing else refers 
// to either of them, they can both get 
// cleaned up. On IE, this is not true 
// if one of the objects is a host-provided 
// object (such as a DOM element or something 
// created via new ActiveXObject) instead of 
// a JavaScript object. (So for instance, 
// if you put a JavaScript object reference 
// on a DOM element and the JavaScript object 
// refers back to the DOM element, they keep 
// each other in memory even when no one is 
// referencing either of them.) But that's 
// an IE bugissue, not a JavaScript thing.

// Re:

// is it because the vbscript GC is bad 
// that people reverted to javascript as 
// their standard client side api?

// JavaScript was the original client-side 
// web scripting language. VBScript only 
// came later, when Microsoft came out 
// with a browser, and was only ever 
// supported in Microsoft browsers. 
// JavaScript was and is the only 
// client-side scripting game in town 
// if you want to work with the broadest 
// range of browsers. <subjective>It's 
// also about eight times the language 
// classic VBScript ever was. ;-) </subjective>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// What is JavaScript garbage collection?

// How Do The Script Garbage Collectors Work?
// Article
// 09/17/2003
// UPDATE: This article was written in 2003. 
// Since that time the JScript garbage 
// collector has been completely rewritten 
// so as to be more performant in general, 
// to handle the larger working sets entailed 
// by modern web applications that we had 
// absolutely no idea were coming when we 
// designed the JScript GC back in 1995, 
// to be better at predicting when there is 
// garbage that needs collecting, and to be 
// better at handling circular references 
// involving browser objects. I did not do 
// any of that work; I haven't worked on the 
// script team for almost a decade now. I do 
// not know how the modern JScript GC works; 
// I've had the architect describe the basics 
// to me but I am not an expert on it. This 
// article should be considered "for historical 
// purposes only"; it does not reflect how 
// JScript works today.

// JScript and VBScript both are automatic 
// storage languages. Unlike, say, C++, the 
// script developer does not have to worry 
// about explicitly allocating and freeing 
// each chunk of memory used by the program. 
// The internal device in the engine which 
// takes care of this task for the developer 
// is called the garbage collector.

// Interestingly enough though, JScript and 
// VBScript have completely different garbage 
// collectors. Occasionally people ask me how 
// the garbage collectors work and what 
// the differences are.

// JScript uses a nongenerational 
// mark-and-sweep garbage collector. 
// It works like this:

// Every variable which is "in scope" 
// is called a "scavenger". A scavenger 
// may refer to a number, an object, a string, 
// whatever. We maintain a list of scavengers 
// -- variables are moved on to the scav list 
// when they come into scope and off the scav 
// list when they go out of scope.

// Every now and then the garbage collector runs. 
// First it puts a "mark" on every object, 
// variable, string, etc – all the memory 
// tracked by the GC. (JScript uses the 
// VARIANT data structure internally and 
// there are plenty of extra unused bits 
// in that structure, so we just set one of them.)

// Second, it clears the mark on the scavengers 
// and the transitive closure of scavenger 
// references. So if a scavenger object 
// references a nonscavenger object then 
// we clear the bits on the nonscavenger, 
// and on everything that it refers to. (I 
// am using the word "closure" in a different 
// sense than in my earlier post.)

// At this point we know that all the memory 
// still marked is allocated memory which 
// cannot be reached by any path from any 
// in-scope variable. All of those objects 
// are instructed to tear themselves down, 
// which destroys any circular references.

// Actually it is a little more complex than 
// that, as we must worry about details like 
// "what if freeing an item causes a message 
// loop to run, which handles an event, which 
// calls back into the script, which runs code, 
// which triggers another garbage collection?" 
// But those are just implementation details. 
// (Incidentally, every JScript engine running 
// on the same thread shares a GC, which 
// complicates the story even further.)

// You'll note that I hand-waved a bit there 
// when I said "every now and then..." Actually 
// what we do is keep track of the number of 
// strings, objects and array slots allocated. 
// We check the current tallies at the beginning 
// of each statement, and when the numbers exceed 
// certain thresholds we trigger a collection.

// The benefits of this approach are numerous, 
// but the principle benefit is that circular 
// references are not leaked unless the circular 
// reference involves an object not owned by JScript.

// However, there are some down sides as well. 
// Performance is potentially not good on 
// large-working-set applications -- if you 
// have an app where there are lots of 
// long-term things in memory and lots of 
// short-term objects being created and 
// destroyed then the GC will run often and 
// will have to walk the same network of long-term 
// objects over and over again. That's not fast.

// The opposite problem is that perhaps a GC 
// will not run when you want one to. If you 
// say "blah = null" then the memory owned by 
// blah will not be released until the GC 
// releases it. If blah is the sole remaining 
// reference to a huge array or network of 
// objects, you might want it to go away as 
// soon as possible. Now, you can force the 
// JScript garbage collector to run with the 
// CollectGarbage() method, but I don't 
// recommend it. The whole point of JScript 
// having a GC is that you don't need to worry 
// about object lifetime. If you do worry about 
// it then you're probably using the wrong 
// tool for the job.

// VBScript, on the other hand, has a much 
// simpler stack-based garbage collector. 
// Scavengers are added to a stack when they 
// come into scope, removed when they go out 
// of scope, and any time an object is discarded 
// it is immediately freed.

// You might wonder why we didn't put a 
// mark-and-sweep GC into VBScript. There 
// are two reasons. First, VBScript did not 
// have classes until version 5, but JScript 
// had objects from day one; VBScript did not 
// need a complex GC because there was no way 
// to get circular references in the first 
// place! Second, VBScript is supposed to 
// be like VB6 where possible, and VB6 does 
// not have a mark-n-sweep collector either.

// The VBScript approach pretty much has the 
// opposite pros and cons. It is fast, simple 
// and predictable, but circular references 
// of VBScript objects are not broken until 
// the engine itself is shut down.

// The CLR GC is also mark-n-sweep but it 
// is generational – the more collections
//  an object survives, the less often it 
// is checked for life.  This dramatically 
// improves performance for large-working-set 
// applications. Of course, the CLR GC was 
// designed for industrial-grade applications,
//  the JScript GC was designed for simple 
// little web pages.

// What happens when you have a web page, 
// ASP page or WSH script with both VBScript 
// and JScript? JScript and VBScript know 
// nothing about each others garbage collection 
// semantics. A VBScript program which gets a 
// reference to a JScript object just sees 
// another COM object. The same for a VBScript 
// object passed to JScript. A circular 
// reference between VBScript and JScript 
// objects would not be broken and the memory 
// would leak (until the engines were shut down). 
// A noncircular reference will be freed when 
// the object in question goes out of scope 
// in both language (and the JS GC runs.)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// What is JavaScript garbage collection?

// Beware of circular references when DOM 
// objects are involved:

// Memory leak patterns in JavaScript

// Keep in mind that memory can only be 
// reclaimed when there are no active references 
// to the object. This is a common pitfall with 
// closures and event handlers, as some JS engines 
// will not check which variables actually are 
// referenced in inner functions and just keep 
// all local variables of the enclosing functions.

// Here's a simple example:

function init() {
    var bigString = new Array(1000).join('xxx');
    var foo = document.getElementById('foo');
    foo.onclick = function() {
        // this might create a closure over `bigString`,
        // even if `bigString` isn't referenced anywhere!
    };
}
// A naive JS implementation can't collect 
// bigString as long as the event handler 
// is around. There are several ways to solve 
// this problem, eg setting bigString = null 
// at the end of init() (delete won't work 
// for local variables and function arguments: 
// delete removes properties from objects, and 
// the variable object is inaccessible - ES5 in 
// strict mode will even throw a ReferenceError 
// if you try to delete a local variable!).

// I recommend to avoid unnecessary closures 
// as much as possible if you care for 
// memory consumption.


// Good quote taken from a blog

// The DOM component is "garbage collected", 
// as is the JScript component, which means 
// that if you create an object within either 
// component, and then lose track of that object, 
// it will eventually be cleaned up.

// For example:

function makeABigObject() {
var bigArray = new Array(20000);
}
// When you call that function, the JScript 
// component creates an object (named bigArray) 
// that is accessible within the function. As 
// soon as the function returns, though, you 
// "lose track" of bigArray because there's 
// no way to refer to it anymore. Well, 
// the JScript component realizes that 
// you've lost track of it, and so bigArray 
// is cleaned up--its memory is reclaimed. 
// The same sort of thing works in the DOM 
// component. If you say document.createElement('div'), 
// or something similar, then the DOM component 
// creates an object for you. Once you lose track 
// of that object somehow, the DOM component will 
// clean up the related.


// 8

// garbage collection (GC) is a form of 
// automatic memory management by removing 
// the objects that no needed anymore.

// any process deal with memory 
// follow these steps:

// 1 - allocate your memory space you need

// 2 - do some processing

// 3 - free this memory space

// there are two main algorithm used 
// to detect which objects no needed anymore.

// Reference-counting garbage collection: 
// this algorithm reduces the definition of 
// "an object is not needed anymore" to 
// "an object has no other object referencing to it", 
// the object will removed if no reference point to it

// Mark-and-sweep algorithm: connect each 
// objects to root source. any object doesn't 
// connect to root or other object. this object 
// will be removed.

// currently most modern browsers using 
// the second algorithm.


// 3

// Reference types do not store the object 
// directly into the variable to which it 
// is assigned, so the object variable in 
// the example below, doesn’t actually 
// contain the object instance. Instead, 
// it holds a pointer (or reference) to 
// the location in memory, where the 
// object exists.

var object = new Object();
// if you assign one reference typed 
// variable to another, each variable 
// gets a copy of the pointer, and both 
// still reference to the same object in memory.

var object1 = new Object();
var object2 = object1;

// JavaScript is a garbage-collected 
// language, so you don’t really need 
// to worry about memory allocations 
// when you use reference types. However, 
// it’s best to dereference objects that 
// you no longer need so that the garbage 
// collector can free up that memory. The 
// best way to do this is to set the object 
// variable to null.

var object1 = new Object();
// do something
object1 = null; // dereference
// Dereferencing objects is especially
//  important in very large applications 
// that use millions of objects.


// What is the motivation for bringing Symbols to ES6?

// I don't understand the motivation. Could someone 
// explain to me whether we really need symbols in 
// JavaScript?


// The original motivation for introducing symbols to 
// Javascript was to enable private properties.

// Unfortunately, they ended up being severely downgraded. 
// They are no longer private, since you can find them via
//  reflection, for example, using Object.getOwnPropertySymbols or proxies.

// They are now known as unique symbols and their only 
// intended use is to avoid name clashes between properties. 
// For example, ECMAScript itself can now introduce extension
//  hooks via certain methods that you can put on objects 
// (e.g. to define their iteration protocol) without risking 
// them to clash with user names.

// Whether that is strong enough a motivation to add symbols 
// to the language is debatable.

// Symbols do not guarantee true privacy but can be used to 
// separate public and internal properties of objects. Let's 
// take an example where we can use Symbol for having private
//  properties.

// Let's take an example where a property of an object is
//  not private.

var Pet = (function() {
  function Pet(type) {
    this.type = type;
  }
  Pet.prototype.getType = function() {
    return this.type;
  }
  return Pet;
}());

var a = new Pet('dog');
console.log(a.getType());//Output: dog
a.type = null;
//Modified outside
console.log(a.getType());//Output: null
// Above, the Pet class property type is not private.
//  To make it private we have to create a closure.
//  The below example illustrates how we can make 
// type private using a closure.

var Pet = (function() {
  function Pet(type) {
    this.getType = function(){
      return type;
    };
  }
  return Pet;
}());

var b = new Pet('dog');
console.log(b.getType());//dog
b.type = null;
//Stays private
console.log(b.getType());//dog
// Disadvantage of above approach: We are introducing 
// an extra closure for each Pet instance created, 
// which can harm performance.

// Now we introduce Symbol. This can help us make 
// a property private without using extra unnecessary 
// closures. Code example below:

var Pet = (function() {
  var typeSymbol = Symbol('type');
  function Pet(type) {
    this[typeSymbol] = type;
  }
  Pet.prototype.getType = function(){
    return this[typeSymbol];
  }
  return Pet;
}());

var a = new Pet('dog');
console.log(a.getType());//Output: dog
a.type = null;
//Stays private
console.log(a.getType());//Output: dog

// This post is about the Symbol(), supplied with actual
//  examples I could find/make and facts & definitions 
// I could find.

// TLDR;
// The Symbol() is the data type, introduced with the 
// release of ECMAScript 6 (ES6).

// There're two curious facts about the Symbol.

// the first data type and only data type in JavaScript 
// which has got no literal

// any variable, defined with Symbol(), gets unique content, 
// but it's not really private.

// any data has its own Symbol, and for the same data the 
// Symbols would be the same. More info in the following 
// paragraph, otherwise it's not a TLRD; :)

// How do I initialise the symbol?
// 1. To get a unique identifier with a debuggable value
// You can do it either this way:

var mySymbol1 = Symbol();
// Or this way:

var mySymbol2 = Symbol("some text here");
// The "some text here" string can't be extracted from 
// the symbol, it's just a description for debugging 
// purposes. It doesn't change the behaviour of symbol 
// in any way. Although, you could console.log it (which 
// is fair, since the value is for debugging, so as not 
// to mistake that log with some other log entry):

console.log(mySymbol2);
// Symbol(some text here)
// 2. To obtain a symbol for some string data
// In this case the value of symbol is actually taken 
// into account and this way two symbols may be non-unique.

var a1 = Symbol.for("test");
var a2 = Symbol.for("test");
console.log(a1 == a2); //true!
// Let's call those symbols "second-type" symbols. They do 
// not intersect with the "first-type" symbols (i.e. the 
// ones defined with Symbol(data)) in any way.

// The next two paragraphs pertain only the first-type symbol.

// How do I benefit from using Symbol instead of the older
//  data types?
// Let's first consider an object, a standard data type. 
// We could define some key-values pairs there and have 
// an access to the values by specifying the key.

var persons = {"peter":"pan","jon":"doe"};
console.log(persons.peter);
// pan
// What if we have two persons with the name Peter?

// Doing this:

var persons = {"peter":"first", "peter":"pan"};
// wouldn't make much sense.

// So, appears to be a problem of two absolutely different 
// persons having a same name. Let's then refer out 
// new Symbol(). It's like a person in real life - any 
// person is unique, but their names can be equal. Let's 
// define two "persons".

 var a = Symbol("peter");
 var b = Symbol("peter");
// Now we have got two different persons with the same name.
//  Are our persons different indeed? They are; you can 
// check this:

 console.log(a == b);
 // false
// How do we benefit there?

// We can make two entries in your object for the different 
// persons and they can't be mistaken in any way.

 var firstPerson = Symbol("peter");
 var secondPerson = Symbol("peter");
 var persons = {[firstPerson]:"first", [secondPerson]:"pan"};
// Note:
// It's worth to notice, though, that stringifying the 
// object with JSON.stringify will drop all the pairs 
// initialised with a Symbol as a key.

// Executing Object.keys won't either return such 
// Symbol()->value pairs.

// Using this initialisation, it's absolutely impossible 
// to mistake the entries for the first and second persons. 
// Calling console.log for them will correctly output their 
// second names.

 console.log(persons[a]);
 // first
 console.log(persons[b]);
 // pan
// When used in object, how it is different compared to 
// defining non-enumerable property?

// Indeed, there already existed a way to define a property 
// to be hidden from Object.keys and enumeration. Here it is:

var anObject = {};
var fruit = "apple";    

Object.defineProperty( anObject, fruit, {
    enumerable: false,
    value: "green"
});
// What difference does Symbol() bring there? The difference 
// is that you can still get the property defined with 
// Object.defineProperty in the usual way:

console.log(anObject[fruit]); //green
console.log(anObject["apple"]); //green
console.log(anObject.apple); //green
// And if defined with Symbol as in previous paragraph:

fruit = Symbol("apple");
// You will have an ability to receive its value only if knowing its variable, i.e.

console.log(anObject[fruit]); //green
console.log(anObject["apple"]); //undefined
console.log(anObject.apple); //undefined
// Moreover, defining another property under the key 
// "apple" will make the object drop the older one (and
//  if hard-coded, it could throw an error). So, no more
//  apples! That's a pity. Referring the previous paragraph,
//  the Symbols are unique and defining a key as Symbol() 
// will make it unique.

// Type conversion and checking
// Unlike other data types, it's impossible to convert 
// the Symbol() to any other data type.

// It's possible to "make" a symbol based on primitive 
// data type by calling Symbol(data).

// In terms of checking the type, nothing changes.

 function isSymbol ( variable ) {
     return typeof someSymbol === "symbol";
 }

 var a_Symbol = Symbol("hey!");
 var totally_Not_A_Symbol = "hey";

 console.log(isSymbol(a_Symbol)); //true
 console.log(isSymbol(totally_Not_A_Symbol)); //false

//  Symbols are a new, special kind of object that 
// can be used as a unique property name in objects. 
// Using symbols instead of a strings allows different
//  modules to create properties that don’t conflict with 
// one another. Symbols can also be made effectively private,
//  so that their properties can’t be accessed by anyone who
//  doesn’t already have direct access to the symbol.

// Symbols are a new primitive, just like the number, 
// string, and boolean primitives. Unlike the other
//  primitives, symbols do not have a literal syntax 
// (e.g. how string has '') — the only way to create
//  them is with the Symbol constructor in the following way:

let symbol = Symbol();
// In reality, symbols are just a slightly different way 
// to attach properties to an object — you could easily 
// provide the well-known symbols as standard methods, 
// just like Object.prototype.hasOwnProperty, which 
// appears in everything that inherits from Object.

// Here are some of the benefits of the Symbol primitive type.

// Symbols have debuggability built in
// Symbols can be given a description, which is really 
// just used for debugging to make life a little easier
//  when logging them to a console.

// Symbols can be used as object keys
// This is where symbols get really interesting. They 
// are heavily intertwined with objects. Symbols can 
// be assigned as keys to objects, meaning you can assign
//  an unlimited number of unique symbols to an object 
// and be guaranteed that these will never conflict with 
// string keys, or other unique symbols.

// Symbols can be used as unique values
// Let’s assume you have a logging library, which includes 
// multiple log levels such as logger.levels.DEBUG, 
// logger.levels.INFO, logger.levels.WARN and so on. 
// In ES5 code you’d like make these strings
//  (so logger.levels.DEBUG === 'debug'), or numbers 
// (logger.levels.DEBUG === 10). Both of these aren’t
//  ideal as those values aren’t unique values, but 
// symbols are! So logger.levels simply becomes:

log.levels = {
  DEBUG: Symbol('debug'),
  INFO: Symbol('info'),
  WARN: Symbol('warn'),
};
log(log.levels.DEBUG, 'debug message');
log(log.levels.INFO, 'info message');


// What are the actual uses of ES6 WeakMap?

// What are the actual uses of the WeakMap data 
// structure introduced in ECMAScript 6?

// Since a key of a weak map creates a strong reference
//  to its corresponding value, ensuring that a value 
// which has been inserted into a weak map will never 
// disappear as long as its key is still alive, it can't 
// be used for memo tables, caches or anything else that
//  you would normally use weak references, maps with weak
//  values, etc. for.

// It seems to me that this:

weakmap.set(key, value);
// ...is just a roundabout way of saying this:

key.value = value;
// What concrete use cases am I missing?

// 658

// Fundamentally
// WeakMaps provide a way to extend objects from the
//  outside without interfering with garbage collection. 
// Whenever you want to extend an object but can't because
//  it is sealed - or from an external source - a WeakMap 
// can be applied.

// A WeakMap is a map (dictionary) where the keys are weak
//  - that is, if all references to the key are lost and 
// there are no more references to the value - the value 
// can be garbage collected. Let's show this first through 
// examples, then explain it a bit and finally finish with
//  real use.

// Let's say I'm using an API that gives me a certain object:

var obj = getObjectFromLibrary();
Now, I have a method that uses the object:

function useObj(obj){
   doSomethingWith(obj);
}
// I want to keep track of how many times the method
//  was called with a certain object and report if it
//  happens more than N times. Naively one would think
//  to use a Map:

var map = new Map(); // maps can have object keys
function useObj(obj){
    doSomethingWith(obj);
    var called = map.get(obj) || 0;
    called++; // called one more time
    if(called > 10) report(); // Report called more than 10 times
    map.set(obj, called);
}
// This works, but it has a memory leak - we now keep
//  track of every single library object passed to the
//  function which keeps the library objects from ever 
// being garbage collected. Instead - we can use a WeakMap:

var map = new WeakMap(); // create a weak map
function useObj(obj){
    doSomethingWith(obj);
    var called = map.get(obj) || 0;
    called++; // called one more time
    if(called > 10) report(); // Report called more than 10 times
    map.set(obj, called);
}
// And the memory leak is gone.

// Use cases
// Some use cases that would otherwise cause a memory 
// leak and are enabled by WeakMaps include:

// Keeping private data about a specific object and only
//  giving access to it to people with a reference to the Map. A more ad-hoc approach is coming with the private-symbols proposal but that's a long time from now.

// Keeping data about library objects without changing 
// them or incurring overhead.

// Keeping data about a small set of objects where many
//  objects of the type exist to not incur problems with
//  hidden classes JS engines use for objects of the same
//  type.

// Keeping data about host objects like DOM nodes in the
//  browser.

// Adding a capability to an object from the outside (like
//  the event emitter example in the other answer).
// Let's look at a real use
// It can be used to extend an object from the outside. 
// Let's give a practical (adapted, sort of real - to 
// make a point) example from the real world of Node.js.

// Let's say you're Node.js and you have Promise objects -
//  now you want to keep track of all the currently rejected
//  promises - however, you do not want to keep them from 
// being garbage collected in case no references exist to 
// them.

// Now, you don't want to add properties to native objects 
// for obvious reasons - so you're stuck. If you keep 
// references to the promises you're causing a memory leak 
// since no garbage collection can happen. If you don't keep
//  references then you can't save additional information 
// about individual promises. Any scheme that involves 
// saving the ID of a promise inherently means you need 
// a reference to it.

// Enter WeakMaps
// WeakMaps mean that the keys are weak. There are no
//  ways to enumerate a weak map or to get all its values.
//  In a weak map, you can store the data based on a key 
// and when the key gets garbage collected so do the values.

// This means that given a promise you can store state 
// about it - and that object can still be garbage collected. 
// Later on, if you get a reference to an object you can
//  check if you have any state relating to it and report it.

// This was used to implement unhandled rejection hooks by
//  Petka Antonov as this:

process.on('unhandledRejection', function(reason, p) {
    console.log("Unhandled Rejection at: Promise ", p, " reason: ", reason);
    // application specific logging, throwing an error, or other logic here
});
// We keep information about promises in a map and 
// can know when a rejected promise was handled.


// This answer seems to be biased and unusable in a 
// real world scenario. Please read it as is, and don't
//  consider it as an actual option for anything else 
// than experimentation

// A use case could be to use it as a dictionary for 
// listeners, I have a coworker who did that. It is very
//  helpful because any listener is directly targetted 
// with this way of doing things. Goodbye listener.on.

// But from a more abstract point of view, WeakMap is 
// especially powerful to dematerialize access to basically
//  anything, you don't need a namespace to isolate its 
// members since it is already implied by the nature of 
// this structure. I'm pretty sure you could do some major
//  memory improvements by replacing awkwards redundant 
// object keys (even though deconstructing does the work 
// for you).

// Before reading what is next
// I do now realize my emphasize is not exactly the best
//  way to tackle the problem and as Benjamin Gruenbaum 
// pointed out (check out his answer, if it's not already 
// above mine :p), this problem could not have been solved 
// with a regular Map, since it would have leaked, thus the
//  main strength of WeakMap is that it does not interfere 
// with garbage collection given that they do not keep a 
// reference.

// Here is the actual code of my coworker (thanks to him for
//  sharing)

// Full source here, it's about listeners management I 
// talked about above (you can also take a look at the specs)

var listenableMap = new WeakMap();


export function getListenable (object) {
    if (!listenableMap.has(object)) {
        listenableMap.set(object, {});
    }

    return listenableMap.get(object);
}


export function getListeners (object, identifier) {
    var listenable = getListenable(object);
    listenable[identifier] = listenable[identifier] || [];

    return listenable[identifier];
}


export function on (object, identifier, listener) {
    var listeners = getListeners(object, identifier);

    listeners.push(listener);
}


export function removeListener (object, identifier, listener) {
    var listeners = getListeners(object, identifier);

    var index = listeners.indexOf(listener);
    if(index !== -1) {
        listeners.splice(index, 1);
    }
}


export function emit (object, identifier, ...args) {
    var listeners = getListeners(object, identifier);

    for (var listener of listeners) {
        listener.apply(object, args);
    }
}


// WeakMap works well for encapsulation and information 
// hiding

// WeakMap is only available for ES6 and above. 
// A WeakMap is a collection of key and value pairs 
// where the key must be an object. In the following 
// example, we build a WeakMap with two items:

var map = new WeakMap();
var pavloHero = {first: "Pavlo", last: "Hero"};
var gabrielFranco = {first: "Gabriel", last: "Franco"};
map.set(pavloHero, "This is Hero");
map.set(gabrielFranco, "This is Franco");
console.log(map.get(pavloHero));//This is Hero

// We used the set() method to define an association 
// between an object and another item (a string in our case). 
// We used the get() method to retrieve the item associated 
// with an object. The interesting aspect of the WeakMaps 
// is the fact that it holds a weak reference to the key 
// inside the map. A weak reference means that if the object 
// is destroyed, the garbage collector will remove the entire
//  entry from the WeakMap, thus freeing up memory.
// 

var TheatreSeats = (function() {
  var priv = new WeakMap();
  var _ = function(instance) {
    return priv.get(instance);
  };

  return (function() {
      function TheatreSeatsConstructor() {
        var privateMembers = {
          seats: []
        };
        priv.set(this, privateMembers);
        this.maxSize = 10;
      }
      TheatreSeatsConstructor.prototype.placePerson = function(person) {
        _(this).seats.push(person);
      };
      TheatreSeatsConstructor.prototype.countOccupiedSeats = function() {
        return _(this).seats.length;
      };
      TheatreSeatsConstructor.prototype.isSoldOut = function() {
        return _(this).seats.length >= this.maxSize;
      };
      TheatreSeatsConstructor.prototype.countFreeSeats = function() {
        return this.maxSize - _(this).seats.length;
      };
      return TheatreSeatsConstructor;
    }());
})()


// 𝗠𝗲𝘁𝗮𝗱𝗮𝘁𝗮
// Weak Maps can be used to store metadata about DOM 
// elements without interfering with garbage collection
//  or making coworkers mad at your code. For example, 
// you could use them to numerically index all of the
//  elements in a webpage.

// 𝗪𝗶𝘁𝗵𝗼𝘂𝘁 𝗪𝗲𝗮𝗸𝗠𝗮𝗽𝘀 𝗼𝗿 𝗪𝗲𝗮𝗸𝗦𝗲𝘁𝘀:
var elements = document.getElementsByTagName('*'),
  i = -1, len = elements.length;

while (++i !== len) {
  // Production code written this poorly makes me want to cry:
  elements[i].lookupindex = i;
  elements[i].elementref = [];
  elements[i].elementref.push( elements[(i * i) % len] );
}

// Then, you can access the lookupindex's
// For those of you new to javascirpt, I hope the comments below help explain 
// how the ternary operator (?:) works like an inline if-statement
document.write(document.body.lookupindex + '<br />' + (
    (document.body.elementref.indexOf(document.currentScript) !== -1)
    ? // if(document.body.elementref.indexOf(document.currentScript) !== -1){
    "true"
    : // } else {
    "false"
  )   // }
);
// Expand snippet
// 𝗨𝘀𝗶𝗻𝗴 𝗪𝗲𝗮𝗸𝗠𝗮𝗽𝘀 𝗮𝗻𝗱 𝗪𝗲𝗮𝗸𝗦𝗲𝘁𝘀:
var DOMref = new WeakMap(),
  __DOMref_value = Array,
  __DOMref_lookupindex = 0,
  __DOMref_otherelement = 1,
  elements = document.getElementsByTagName('*'),
  i = -1, len = elements.length, cur;

while (++i !== len) {
  // Production code written this well makes me want to 😊:
  cur = DOMref.get(elements[i]);
  if (cur === undefined)
    DOMref.set(elements[i], cur = new __DOMref_value)

  cur[__DOMref_lookupindex] = i;
  cur[__DOMref_otherelement] = new WeakSet();
  cur[__DOMref_otherelement].add( elements[(i * i) % len] );
}

// Then, you can access the lookupindex's
cur = DOMref.get(document.body)
document.write(cur[__DOMref_lookupindex] + '<br />' + (
    cur[__DOMref_otherelement].has(document.currentScript)
    ? // if(cur[__DOMref_otherelement].has(document.currentScript)){
    "true"
    : // } else {
    "false"
  )   // }
);
// Expand snippet
// 𝗧𝗵𝗲 𝗗𝗶𝗳𝗳𝗲𝗿𝗲𝗻𝗰𝗲
// The difference may look negligible, aside from 
// the fact that the weakmap version is longer, however
//  there is a major difference between the two pieces 
// of code shown above. In the first snippet of code, 
// without weak maps, the piece of code stores references 
// every which way between the DOM elements. This prevents 
// the DOM elements from being garbage collected. 
// (i * i) % len may seem like an oddball that nobody
//  would use, but think again: plenty of production 
// code has DOM references that bounce all over the document. 
// Now, for the second piece of code, because all the 
// references to the elements are weak, when you a remove
//  a node, the browser is able to determine that the node
//  is not used (not able to be reached by your code),
//  and thus delete it from memory. The reason for why 
// you should be concerned about memory usage, and memory 
// anchors (things like the first snippet of code where
//  unused elements are held in memory) is because more 
// memory usage means more browser GC-attempts (to try 
// to free up memory to avert a browser crash) means slower 
// browsing experience and sometimes a browser crash.

// As for a polyfill for these, I would recommend my own
//  library (found here @ github). It is a very lightweight
//  library that will simply polyfill it without any of the 
// way-overly-complex frameworks you might find in other 
// polyfills.
// 

// I use WeakMap for the cache of worry-free memoization
//  of functions that take in immutable objects as their 
// parameter.

// Memoization is fancy way of saying "after you compute
//  the value, cache it so you don't have to compute it 
// again".

// Here's an example:

// Show code snippet

// A few things to note:

// Immutable.js objects return new objects (with a 
// new pointer) when you modify them so using them as
//  keys in a WeakMap is guarantees the same computed value.

// The WeakMap is great for memos because once the object
//  (used as the key) gets garbage collected, so does the
//  computed value on the WeakMap.

// I have this simple feature based use case/Example 
// for WeakMaps.

// MANAGE A COLLECTION OF USERS
// I started off with a User Object whose properties
//  include a fullname, username, age, gender and a method 
// called print which prints a human readable summary of 
// the other properties.

// /**
// Basic User Object with common properties.
// */
function User(username, fullname, age, gender) {
    this.username = username;
    this.fullname = fullname;
    this.age = age;
    this.gender = gender;
    this.print = () => console.log(`${this.fullname} is a ${age} year old ${gender}`);
}
// I then added a Map called users to keep a collection 
// of multiple users which are keyed by username.

/**
Collection of Users, keyed by username.
*/
var users = new Map();
// Addition of the Collection also required helper functions
//  to add, get, delete a User and even a function to print
//  all the users for sake of completeness.

/**
Creates an User Object and adds it to the users Collection.
*/
var addUser = (username, fullname, age, gender) => {
    let an_user = new User(username, fullname, age, gender);
    users.set(username, an_user);
}

/**
Returns an User Object associated with the given username in the Collection.
*/
var getUser = (username) => {
    return users.get(username);
}

/**
Deletes an User Object associated with the given
 username in the Collection.
*/
var deleteUser = (username) => {
    users.delete(username);
}

/**
Prints summary of all the User Objects in the Collection.
*/
var printUsers = () => {
    users.forEach((user) => {
        user.print();
    });
}
// With all of the above code running in, say NodeJS, 
// only the users Map has the reference to the User 
// Objects within the entire process. There is no 
// other reference to the individual User Objects.

// Running this code an interactive NodeJS shell, just 
// as an Example I add four users and print them:

// see it on the site , its vary intriguing 

// WEAKMAP: keep in mind weakMap is all about memory 
// allocation and garbage collection and only related
//  to key of object type in javascript when u store 
// values in key-value pair array, map, set, etc... a 
// memory allocated to all key-value pair and this memory 
// will not be free even if you delete or set null to that
//  key consider this as a strongmap keys are strongly 
// attache to memory below is example

let john = { name: "yusuf" };

let map = new Map();
map.set(yusuf, "xyz"); //here "yusuf" is the key and "xyz" is value

yusuf= null; // overwrite the reference

// the object previously referenced by yusuf is stored inside the array
// therefore it won't be garbage-collected
// we can get it using map.keys()
// but this is not the case with weakMap in here memory
//  will be free

let john = { name: "yusuf" };

let map = new WeakMap();
map.set(yusuf, "...");

yusuf= null; // overwrite the reference

// yusuf is removed from memory!

// USE CASE : you will use it in javascript where u want 
// to manage memory in more efficient way

// If we’re working with an object that “belongs” to 
// another code, maybe even a third-party library, and
//  would like to store some data associated with it,
//  that should only exist while the object is alive – 
// then WeakMap is exactly what’s needed.

// We put the data to a WeakMap, using the object as the
//  key, and when the object is garbage collected, that
//  data will automatically disappear as well.

weakMap.set(yusuf, "secret documents");
// if yusuf dies, secret documents will be destroyed automatically

const aNormalMap = new Map();
function pushToMap() {
  for (let i = 0; i < 10; i++) {
    aNormalMap.set({}, i);
  }
}

const aWeakMap = new WeakMap();
function pushToWeakMap() {
  for (let i = 0; i < 10; i++) {
    aWeakMap.set({}, i);
  }
}

function main() {
  pushToMap();
  /**
   * After the call the pushToMap
   */
  pushToWeakMap();
    /**
   * After the call the pushToWeakMap
   */
}
// After the call to pushToMap, there is NO WAY to fetch
//  the aNormalMap by key, because the key (i.e.{}) is 
// local to pushToWeakMap, after the pushToMap exists, 
// the key(i.e.{}) because unaccessible, let me reiterate
//  the point

// The key (i.e.{}) is not accessible after the function
//  exist, it should be garbage collected

// However, such an "unaccessible" key will exist in memory
//  FOREVER, because even though the key itself is
//  inaccessible, we can still get the key by enumerating
//  the aNormalMap. So the "unaccessible" can not be GC

// On the other hand, the "inaccessible" key will NOT
//  reside in memory even though it is held by aWeakMap,
//  because it is WEAK


// ECMAScript 6: what is WeakSet for?

// The WeakSet is supposed to store elements by 
// weak reference. That is, if an object is not 
// referenced by anything else, it should be cleaned
//  from the WeakSet.

// I have written the following test:

var weakset = new WeakSet(),
    numbers = [1, 2, 3];

weakset.add(numbers);
weakset.add({name: "Charlie"});

console.log(weakset);

numbers = undefined;

console.log(weakset);
// Even though my [1, 2, 3] array is not referenced
//  by anything, it's not being removed from the WeakSet.
//  The console prints:

// WeakSet {[1, 2, 3], Object {name: "Charlie"}}
// WeakSet {[1, 2, 3], Object {name: "Charlie"}}

// Why is that?
// Plus, I have one more question. What is the point
//  of adding objects to WeakSets directly, like this:

weakset.add({name: "Charlie"});
// Are those Traceur's glitches or am I missing something?

// Most likely because the garbage collector has 
// not yet run. However, you say you are using Traceur,
//  so it just might be that they're not properly supported.
//  I wonder how the console can show the contents of 
// a WeakSet anyway.

// What is the point of adding objects to WeakSets directly?

// There is absolutely no point of adding object literals
//  to WeakSets.

// What is the practical use of WeakSet if we cannot even 
// iterate through it nor get the current size?
// All you can get is one bit of information: Is the 
// object (or generically, value) contained in the set?
// This can be useful in situations where you want to "tag" 
// objects without actually mutating them (setting a 
// property on them). Lots of algorithms contain some 
// sort of "if x was already seen" condition 
// (a JSON.stringify cycle detection might be a good example),
//  and when you work with user-provided values the use of
//  a Set/WeakSet would be advisable. The advantage of 
// a WeakSet here is that its contents can be
//  garbage-collected while your algorithm is still running,
//  so it helps to reduce memory consumption (or even 
// prevents leaks) when you are dealing with lots of data
//  that is lazily (possibly even asynchronously) produced.


// This is a really hard question. To be completely honest 
// I had no idea in the context of JavaScript so I asked in
//  esdiscuss and got a convincing answer from Domenic.

// WeakSets are useful for security and validation reasons.
//  If you want to be able to isolate a piece of JavaScript.
//  They allow you to tag an object to indicate it belongs 
// to a special set of object.

// Let's say I have a class ApiRequest:

class ApiRequest {
  constructor() {
    // bring object to a consistent state, use platform code you have no direct access to
  }

  makeRequest() {
    // do work 
  }
}
// Now, I'm writing a JavaScript platform - my platform 
// allows you to run JavaScript to make calls - to make 
// those calls you need a ApiRequest - I only want you 
// to make ApiRequests with the objects I give you so 
// you can't bypass any constraints I have in place.

// However, at the moment nothing is stopping you from doing:

ApiRequest.prototype.makeRequest.call(null, args); // make request as function
Object.create(ApiRequest.prototype).makeRequest(); // no initialization
function Foo(){}; Foo.prototype = ApiRequest.prototype; new Foo().makeRequest(); // no super
// And so on, note that you can't keep a normal list 
// or array of ApiRequest objects since that would 
// prevent them from being garbage collected. Other
//  than a closure, anything can be achieved with public 
// methods like Object.getOwnPropertyNames or 
// Object.getOwnSymbols. So you one up me and do:

const requests = new WeakSet();
class ApiRequest {
  constructor() {
    requests.add(this);
  }

  makeRequest() {
    if(!request.has(this)) throw new Error("Invalid access");
    // do work
  }
}
// Now, no matter what I do - I must hold a valid 
// ApiRequest object to call the makeRequest method 
// on it. This is impossible without a WeakMap/WeakSet.

// So in short - WeakMaps are useful for writing platforms
//  in JavaScript. Normally this sort of validation is done 
// on the C++ side but adding these features will enable 
// moving and making things in JavaScript.

// (Of course, everything a WeakSet does a WeakMap that 
// maps values to true can also do, but that's true for 
// any map/set construct)


// By definition, WeakSet has only three key functionalities

// Weakly link an object into the set
// Remove a link to an object from the set
// Check if an object has already been linked to the set
// Sounds more pretty familiar?

// In some application, developers may need to implement 
// a quick way to iterate through a series of data which 
// is polluted by lots and lots of redundancy but you want 
// to pick only ones which have not been processed before 
// (unique). WeakSet could help you. See an example below:

var processedBag = new WeakSet();
var nextObject = getNext();
while (nextObject !== null){
    // Check if already processed this similar object?
    if (!processedBag.has(nextObject)){
        // If not, process it and memorize 
        process(nextObject);
        processedBag.add(nextObject);
    }
    nextObject = getNext();
}
// One of the best data structure for application above
//  is Bloom filter which is very good for a massive data 
// size. However, you can apply the use of WeakSet for this
//  purpose as well.

// A "weak" set or map is useful when you need to keep 
// an arbitrary collection of things but you don't want 
// their presence in the collection from preventing those 
// things from being garbage-collected if memory gets tight. 
// (If garbage collection does occur, the "reaped" objects 
// will silently disappear from the collection, so you can
//  actually tell if they're gone.)

// They are excellent, for example, for use as a look-aside 
// cache: "have I already retrieved this record, recently?" 
// Each time you retrieve something, put it into the map,
//  knowing that the JavaScript garbage collector will be 
// the one responsible for "trimming the list" for you, and 
// that it will automatically do so in response to prevailing
//  memory conditions (which you can't reasonably anticipate).

// The only drawback is that these types are 
// not "enumerable." You can't iterate over a list of entries
//  – probably because this would likely "touch" those 
// entries and so defeat the purpose. But, that's a small 
// price to pay (and you could, if need be, "code around it").

// WeakSet is a simplification of WeakMap for where your 
// value is always going to be boolean true. It allows you 
// to tag JavaScript objects so to only do something with 
// them once or to maintain their state in respect to a
//  certain process. In theory as it doesn't need to hold 
// a value it should use a little less memory and perform 
// slightly faster than WeakMap.

var [touch, untouch] = (() => {
    var seen = new WeakSet();
    return [
        value => seen.has(value)) || (seen.add(value), !1),
        value => !seen.has(value) || (seen.delete(value), !1)
    ];
})();

function convert(object) {
    if(touch(object)) return;
    extend(object, yunoprototype); // Made up.
};

function unconvert(object) {
    if(untouch(object)) return;
    del_props(object, Object.keys(yunoprototype)); // Never do this IRL.
};

// Your console was probably incorrectly showing the 
// contents due to the fact that the garbage collection
//  did not take place yet. Therefore since the object 
// wasn't garbage collected it would show the object still
//  in weakset.

// If you really want to see if a weakset still has a 
// reference to a certain object then use the 
// WeakSet.prototype.has() method. This method, as the 
// name implies returns a boolean indicating wether the
//  object still exists in the weakset.

// Example:
var weakset = new WeakSet(),
    numbers = [1, 2, 3];

weakset.add(numbers);
weakset.add({name: "Charlie"});

console.log(weakset.has(numbers));

numbers = undefined;

console.log(weakset.has(numbers));

// C:\Users\rekha\OneDrive\Desktop\js-topics-code-main\js_Entirity\2.Absolute_knowledge---References\References_JavaScript_Reference_Standard built-in objects\13.Array



// show me all the array methods and how they work with example .
// also specify the combo's of method  i means suits for certain scenarios 
// tell me what is the difference between the deep and sallow copy 
// and explin that with the code . 




let marks_class_12 = [91, 82, 63, 84, false, "Not Present"]
console.log(marks_class_12[0])
console.log(marks_class_12[1])
console.log(marks_class_12[2])
console.log(marks_class_12[3])
console.log(marks_class_12[4])
console.log(marks_class_12[5])
console.log(marks_class_12[6]) // Will be undefined because index 6 does not exist
console.log("The length of marks_class_12 is", marks_class_12.length)
marks_class_12[6] = 89 // Adding a new value to the array
marks_class_12[0] = 96 // Changing the value of an array
console.log(marks_class_12)
console.log(typeof marks_class_12)
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// 51 most commolnly used array methods in javascript with what they do ?
// 1.concat()
// 2.copywithin 
// 3.entries
// 4.every 
// 5.fill 
// 6.filter 
// 7.find 
// 8.findindddex 
// 9.flat 
// 10.flatmap 
// 11.from 
// 12.includes 
// 13.indesof 
// 14.join 
// 15.keys 
// 16.indesof 
// 17.map 
// 18.pop 
// 19.push 
// 20.reduce 
// 21.reduceright 
// 22.reverse 
// 23.shift 
// 24.slicr 
// 25.some 
// 26.splice 
// 27.telocalstring 
// 28.tostring 
// 29.unshift 
// 30.values 
// 31.flatmap 
// 32.filter 
// 33.find 
// 34.findindex 
// 35.foreach 
// 36.includes 
// 37.indexof 
// 38.join 
// 39.keys 
// 40.lastindexof 
// 41.map 
// 42.pop 
// 43.push 
// 44.reduce 
// 45.reduceend 
// 46.shift  
// 47.slice
// 48.reduce + map 
// 49.every + some 
// 50.foreach + push 
// 51. filter +reduce 
// 53. some + indexof 
// 54.slice + conact 
// 55. find +map 
// 56. every + filter 
// 57. foreach + slice 
// 58. indexof + splice 

// filter() + map(): Filters the array and maps the filtered elements into a new array.
// findIndex() + splice(): Finds the index of an element and removes it from the array.
// every() + some(): Checks if all elements pass a test and if at least

// reduce() + map(): Reduces the array to a single value while transforming each element.
// forEach() + push(): Iterates over the array and pushes elements to a new array or modifies the existing array.
// filter() + reduce(): Filters the array based on a condition and reduces the filtered elements to a single value.
// some() + indexOf(): Checks if an element exists in the array by using indexOf() inside a some() callback function.
// slice() + concat(): Extracts a section of an array and concatenates it with another array or elements.
// map() + join(): Transforms each element in the array and joins them into a string.
// reduce() + filter(): Reduces the array to a single value based on a condition specified in the filter() callback function.
// find() + map(): Finds an element in the array and transforms it using the map() callback function.
// every() + filter(): Checks if all elements pass a condition specified in the filter() callback function.
// forEach() + slice(): Iterates over the array and extracts a portion of the array for each iteration.
// reduceRight() + concat(): Reduces the array from right to left and concatenates the values into a new array.
// filter() + map() + reduce(): Filters the array, transforms the filtered elements, and reduces them to a single value.
// some() + map(): Checks if at least one element satisfies a condition and transforms the matching elements.
// indexOf() + splice(): Finds the index of an element and removes it from the array using splice().
// 1.concat(): Concatenates two or more arrays and returns a new array.
    // var myArray = ['Hello', 'World'];
    // var myString = '!';
    // var newArray = myArray.concat(myString);

    // console.log(newArray); // Output: ['Hello', 'World', '!']
// 2.copyWithin(): non-mutator method 
// Copies elements within an array to another position in the same array.
    // var myArray = ['apple', 'banana', 'cherry', 'date', 'elderberry'];
    // myArray.copyWithin(2, 0, 3);
                        // target , start , end     
    // console.log(myArray); // Output: ['apple', 'banana', 'apple', 'banana', 'cherry']
    // -----------------------
    //One practical real case where the copyWithin() function in JavaScript is commonly used is for efficiently copying and rearranging elements within an array.
    // Consider a scenario where you have an array representing a sequence of numbers, and you want to rearrange some elements within the array without creating a new array or using multiple temporary variables.
    // In this case, the copyWithin() function is called on the numbers array. The first argument, 2, specifies the index where the copied elements will be placed. The second argument, 5, represents the starting index of the elements to be copied. The third argument, 8, indicates the ending index (exclusive) of the elements to be copied.
    // After executing the copyWithin() function, the array will be modified as follows:
    // The copyWithin() function is particularly useful when you need to efficiently manipulate arrays by copying elements within the same array structure. It allows you to avoid creating a new array and efficiently update the existing array's elements.
    // Some practical applications of copyWithin() include rearranging and shuffling elements within a deck of cards, reordering items in a list, or implementing algorithms that require in-place modifications to array elements.

    // Here's an example:
    // var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    // numbers.copyWithin(2, 5, 8);
    // Outut:  [1, 2, 6, 7, 8, 6, 7, 8, 9]
    // The elements at indices 5, 6, and 7 (6, 7, 8) are copied and placed starting from index 2, resulting in the rearrangement of elements within the array.


// 3.entries(): Returns a new array iterator that contains key/value pairs for each index in the array.
    // const fruits = ['apple', 'banana', 'cherry'];

    // const iterator = fruits.entries();

    // for (let entry of iterator) {
    //   console.log(entry);
    // }
// ------------------
    // One practical real case where the entries() function in JavaScript is commonly used is for iterating over the key-value pairs of an object or entries of a Map and performing operations based on those pairs.
    // Let's say you have an object representing a student record with properties like name, age, and grade, and you want to iterate over the key-value pairs of the object to perform some calculations or generate a report.
    
    // Here's an example:

    // var student = {
    //   name: "John Doe",
    //   age: 18,
    //   grade: "A"
    // };
    // var studentEntries = Object.entries(student);
    // for (var [key, value] of studentEntries) {
    //   console.log(key + ": " + value);
    // }
    // In this case, the entries() function is used to 
    //obtain an array of key-value pairs from the student object. 
    //The Object.entries() function converts the object into an array of arrays, 
    // where each inner array contains the key-value pair.
    // By iterating over the studentEntries array using destructuring assignment, 
    // we can access each key-value pair. In the example, we simply log the key and value to the console.

    // The output will be:

    // name: John Doe
    // age: 18
    // grade: A
    // The entries() function is commonly used in scenarios
    //  where you need to process or analyze the properties and 
    // values of an object or entries of a Map. 
    // It allows you to dynamically iterate over the key-value pairs, 
    // perform calculations or transformations, generate reports, or 
    // implement algorithms based on the data contained in the entries.
    // Using entries(), you can work with the structured data 
    // in a more flexible and dynamic manner, 
    // making it useful in a wide range of applications, including data processing, form submissions, configuration settings, and more.

    // note focus on of , bcz if you write in then this happens 
    
// entries are mostly used iterate over key-value pair(object)
// iterating over an object 
var student = {
    name: "John Doe",
    age: 18,
    grade: "A"
  };
let studentEntries = Object.entries(student)
console.log(studentEntries) 
console.log(typeof studentEntries) // object 
//  so  studentEntries is a object
// that's why the output of for-in is wrong 
// and   the output of for-of is just is wanted 
// as for-in cant go in(iterate) the object 

for (let [x,y] in studentEntries){
  // console.log(`key: ${x} , value: ${y}`)
  console.log(x+":"+y)
}
// 0:undefined
// 1:undefined
// 3:undefined



for (var [key, value] of studentEntries) {
  console.log(key + ": " + value);
}
// name: John Doe
//  age: 18
//  grade: A

console.log("Array methods , join, concat   ")

const fruits = ['apple', 'banana', 'cherry'];

// entries on array  
const iterator = fruits.entries();
console.log(iterator) // Array Iterator {} : iterable iterator 
for (let entry of iterator) {
    console.log(entry);
}
// [0, 'apple']
// [1, 'banana']
// [2, 'cherry']


//  entries on object 
var student = {
  name: "John Doe",
  age: 18,
  grade: "A"
};
let studentEntries = Object.entries(student)
console.log(studentEntries,"-> .entries converted objecct into array of arrays ")
console.log("where each inner array contains the key-value pair.")
for (let x of  studentEntries) {
    console.log(x) 
    // when for-in ,  0 1 2 
    // when for-of ,  ['name', 'John Doe'] , ['age', 18] ,['grade', 'A'] 
}
for (let [x,y] of studentEntries){
    console.log(x,":",y,`/ key: ${x} , value: ${y}`)
    // name : John Doe
    // age : 18
    // grade : A
}




// 4.every():

// every  - this method is used to check if every element 
//satisfies a certaian condition or not ? 
//  returns true or false - It returns a Boolean value
const numbers = [2, 4, 6, 8, 10];
console.log(numbers.every(
    function (num){
        //  num%2 === 0 //false 
        return num%2 === 0 //true 
    }
))

// why it is returning false ?  .. every array element seems
// to have remainder of 0 .  The every() method in JavaScript 
// tests whether all elements in the array pass the test implemented 
//by the provided function. It returns a Boolean value.
// In your function, you’re checking if each number in 
// the array is even (i.e., num % 2 === 0). However, your 
// function doesn’t return anything. In JavaScript, if 
// a function doesn’t have a return statement, it returns 
// undefined by default, which is a falsy value. That’s 
// why every() is returning false.
// and that is why even if evey element passes the test 
// it will return false .


//  Checks if all elements in the array satisfy a given condition.
    // const numbers = [2, 4, 6, 8, 10];
    // const allEven = numbers.every(function(number) {
    //   return number % 2 === 0;
    // });

    // console.log(allEven); // Output: true
    // // --------------------------
    // One practical real case where the every() function in JavaScript is commonly used is for validating whether all elements in an array satisfy a specific condition or criteria.
    // For example, let's consider a scenario where you have an array of numbers representing students' exam scores, and you want to check if all the students passed the exam by ensuring that their scores are above a certain threshold.
    // Here's an example:

    // var scores = [85, 90, 78, 92, 88];
    // var allPassed = scores.every(function(score) {
    //   return score >= 70;
    // });
    // In this case, the every() function is called on the scores array. The provided callback function checks if each score is greater than or equal to 70, which is the passing threshold.
    // The every() function iterates through each element of the array and returns true if all elements satisfy the condition specified by the callback function. Otherwise, it returns false.
    // In the example, the allPassed variable will be true since all scores are above 70.
    // The every() function is commonly used for validation purposes, such as checking if all elements in an array meet certain criteria, constraints, or conditions. It is helpful in scenarios where you need to ensure that a specific condition is satisfied by every element before proceeding with further operations or decisions.
    // Other practical applications of every() include checking if all checkboxes in a form are selected, validating input data, or performing quality checks on datasets.
// 5.fill(): mutator method . 
// Fills all or a portion of an array with a specified value.
    // Certainly! Here's an example that demonstrates the usage of the fill() method on an array in JavaScript:

//  array fill method  - fills a certain part of the array with a specified number 
// fill is a mutator method . 
console.log(numbers) //[1,2,3,5,6]
console.log(numbers.fill(0,2,4)) // [1, 2, 0, 0, 6]
// fourth index excluded means it will not vhange 
// The fill() method is useful when you want to set a
    //  specific range of elements in an array to a particular 
    //value without modifying the length of the array.

    // The fill() method is useful when you want to set a
    //  specific range of elements in an array to a particular 
    //value without modifying the length of the array.
    // -----------------
    //One practical real case where the fill() function in JavaScript is commonly used is for initializing or modifying array elements with a specific value.
    // For example, let's say you have an array 
    //representing a game board with empty spaces, 
    //and you want to fill the entire board with a 
    //specific symbol or marker to indicate that the 
    //spaces are occupied.

    // Here's an example:

    // javascript
    // Copy code
    // var board = ["", "", "", "", "", "", "", "", ""];

    // board.fill("X");
    // In this case, the fill() function is called on the board array, and the argument "X" specifies the value to be filled in for all array elements.

    // After executing the fill() function, the board array will be modified as follows:

    // javascript
    // Copy code
    // ["X", "X", "X", "X", "X", "X", "X", "X", "X"]
    // All the empty spaces in the array are replaced with the 
    //value "X".
    // The fill() function is commonly used in scenarios where 
    //you need to initialize or modify array elements with 
    //a specific value. It allows you to quickly set all
    // or a portion of the array to a predefined value without using loops or manual assignment.
// 6.filter(): non-mutator 
//  Creates a new array with all elements that pass a test.
    // const numbers = [1, 2, 3, 4, 5];

    // const evenNumbers = numbers.filter(function(number) {
    //   return number % 2 === 0;
    // });

    // console.log(evenNumbers); // Output: [2, 4]
// -------------------------------
        // One practical real case where the filter() function in JavaScript is commonly used is for filtering elements in an array based on specific conditions or criteria.
        // For example, let's say you have an array of products, and you want to filter out all products that are out of stock or have a price higher than a certain threshold.
        // In this case, the filter() function is called on the products array. The provided callback function checks if each product is in stock (inStock property is true) and if its price is less than or equal to 500.
        // The filter() function iterates through each element of the array and returns a new array containing only the elements that satisfy the condition specified by the callback function.
        // In the example, the availableProducts array will contain the filtered products that are both in stock and have a price of 500 or less:
        // The filter() function is commonly used for data filtering and selection, where you need to extract a subset of elements from an array based on specific conditions. It allows you to easily extract and work with the elements that meet certain criteria, facilitating data analysis, searching, or performing operations on specific subsets of data.
        // Other practical applications of filter() include implementing search functionality, removing duplicates, or selecting specific data points based on various criteria in applications such as e-commerce, data visualization, or data manipulation.
        // Here's an example:

        // var products = [
        //   { name: "iPhone", price: 999, inStock: true },
        //   { name: "Laptop", price: 1499, inStock: false },
        //   { name: "Headphones", price: 199, inStock: true },
        //   { name: "Smartwatch", price: 299, inStock: false }
        // ];

        // var availableProducts = products.filter(function(product) {
        //   return product.inStock && product.price <= 500;
        // });
        // In this case, the filter() function is called on the products array. The provided callback function checks if each product is in stock (inStock property is true) and if its price is less than or equal to 500.
        // The filter() function iterates through each element of the array and returns a new array containing only the elements that satisfy the condition specified by the callback function.
        // In the example, the availableProducts array will contain the filtered products that are both in stock and have a price of 500 or less:


        // [
        //   { name: "Headphones", price: 199, inStock: true }
        // ]
        // The filter() function is commonly used for data filtering and selection, where you need to extract a subset of elements from an array based on specific conditions. It allows you to easily extract and work with the elements that meet certain criteria, facilitating data analysis, searching, or performing operations on specific subsets of data.
        // Other practical applications of filter() include implementing search functionality, removing duplicates, or selecting specific data points based on various criteria in applications such as e-commerce, data visualization, or data manipulation.
// 7.find(): Returns the first element in the array that satisfies a provided testing function.
    // const numbers = [1, 2, 3, 4, 5];

    // const foundNumber = numbers.find(function(number) {
    //   return number > 3;
    // });

    // console.log(foundNumber); // Output: 4
// -------------------------------
    // One practical real case where the find() function in JavaScript is commonly used is for searching and retrieving the first element in an array that satisfies a specific condition or criteria.
    // Let's consider a scenario where you have an array of user objects, and you want to find a specific user by their unique identifier.
    // In this case, the find() function is called on the users array. The provided callback function checks if each user's id property matches the desired userId.
    // The find() function iterates through each element of the array and returns the first element that satisfies the condition specified by the callback function.
    // In the example, the foundUser variable will contain the user object with an id of 3:
    // The find() function stops iterating and returns the first matching element it encounters, so it is particularly useful when you only need to retrieve the first occurrence that meets a specific condition.
    // The find() function is commonly used in scenarios where you need to search and retrieve a specific element from an array based on a particular condition. It allows you to easily locate and access the desired element, facilitating tasks such as user lookups, data retrieval, or filtering data based on specific criteria.
    // Other practical applications of find() include searching for specific items in an inventory, identifying matches in a list, or finding objects based on specific properties in various real-world applications, such as e-commerce, data management, or search functionalities.
    // Here's an example:

    // var users = [
    //   { id: 1, name: "John" },
    //   { id: 2, name: "Jane" },
    //   { id: 3, name: "Alex" },
    //   { id: 4, name: "Emily" }
    // ];

    // var userId = 3;

    // var foundUser = users.find(function(user) {
    //   return user.id === userId;
    // });
    // In this case, the find() function is called on the users array. The provided callback function checks if each user's id property matches the desired userId.
    // The find() function iterates through each element of the array and returns the first element that satisfies the condition specified by the callback function.
    // In the example, the foundUser variable will contain the user object with an id of 3:

    // { id: 3, name: "Alex" }
    // The find() function stops iterating and returns the first matching element it encounters, so it is particularly useful when you only need to retrieve the first occurrence that meets a specific condition.
    // The find() function is commonly used in scenarios where you need to search and retrieve a specific element from an array based on a particular condition. It allows you to easily locate and access the desired element, facilitating tasks such as user lookups, data retrieval, or filtering data based on specific criteria.
    // Other practical applications of find() include searching for specific items in an inventory, identifying matches in a list, or finding objects based on specific properties in various real-world applications, such as e-commerce, data management, or search functionalities.
// 8.findIndex(): Returns the index of the first element in the array that satisfies a provided testing function.
    // const numbers = [1, 2, 3, 4, 5];

    // const index = numbers.findIndex(function(number) {
    //   return number > 3;
    // });

    // console.log(index); // Output: 3
    // -------------------------------
    // One practical real case where the find() function in JavaScript is commonly used is for searching and retrieving the first element in an array that satisfies a specific condition or criteria.
    // Let's consider a scenario where you have an array of user objects, and you want to find a specific user by their unique identifier.
    // In this case, the find() function is called on the users array. The provided callback function checks if each user's id property matches the desired userId.
    // The find() function iterates through each element of the array and returns the first element that satisfies the condition specified by the callback function.
    // In the example, the foundUser variable will contain the user object with an id of 3:
    // only need to retrieve the first occurrence that meets a specific condition.
    // The find() function is commonly used in scenarios where you need to search and retrieve a specific element from an array based on a particular condition. It allows you to easily locate and access the desired element, facilitating tasks such as user lookups, data retrieval, or filtering data based on specific criteria.
    // Other practical applications of find() include searching for specific items in an inventory, identifying matches in a list, or finding objects based on specific properties in various real-world applications, such as e-commerce, data management, or search functionalities.
    // Here's an example:

    // var users = [
    //   { id: 1, name: "John" },
    //   { id: 2, name: "Jane" },
    //   { id: 3, name: "Alex" },
    //   { id: 4, name: "Emily" }
    // ];

    // var userId = 3;

    // var foundUser = users.find(function(user) {
    //   return user.id === userId;
    // });
    // In this case, the find() function is called on the users array. The provided callback function checks if each user's id property matches the desired userId.
    // The find() function iterates through each element of the array and returns the first element that satisfies the condition specified by the callback function.
    // In the example, the foundUser variable will contain the user object with an id of 3:

    // { id: 3, name: "Alex" }
    // The find() function stops iterating and returns the first matching element it encounters, so it is particularly useful when you only need to retrieve the first occurrence that meets a specific condition.
    // The find() function is commonly used in scenarios where you need to search and retrieve a specific element from an array based on a particular condition. It allows you to easily locate and access the desired element, facilitating tasks such as user lookups, data retrieval, or filtering data based on specific criteria.
    // Other practical applications of find() include searching for specific items in an inventory, identifying matches in a list, or finding objects based on specific properties in various real-world applications, such as e-commerce, data management, or search functionalities.





    // User
    // state me one good  practical real  case where  findIndex  of js are used 

    // One practical real case where the findIndex() function in JavaScript is commonly used is for finding the index of the first element in an array that satisfies a specific condition or criteria.

    // For example, let's say you have an array of numbers representing exam scores, and you want to find the index of the first score that is above a certain threshold.// In this case, the findIndex() function is called on the scores array. The provided callback function checks if each score is greater than the passingScore threshold./ The findIndex() function iterates through each element of the array and returns the index of the first element that satisfies the condition specified by the callback function. If no element satisfies the condition, it returns -1.


    // Here's an example:

    // var scores = [65, 72, 80, 88, 92];
    // var passingScore = 75;
    // var firstPassingIndex = scores.findIndex(function(score) {
    //   return score > passingScore;
    // });
    // In this case, the findIndex() function is called on the scores array. The provided callback function checks if each score is greater than the passingScore threshold.

    // The findIndex() function iterates through each element of the array and returns the index of the first element that satisfies the condition specified by the callback function. If no element satisfies the condition, it returns -1.

    // In the example, the firstPassingIndex variable will contain the index of the first score that is above 75, which is 2.

    // The findIndex() function is particularly useful when you need to locate the index of the first occurrence that meets a specific condition or criteria. It allows you to quickly find the position of an element within an array based on a particular condition.

    // The findIndex() function is commonly used in scenarios where you need to search for the position of a specific element within an array, perform conditional operations based on the element's index, or retrieve related data associated with that index.

    // Other practical applications of findIndex() include implementing pagination, identifying the index of specific elements for further processing, or managing data relationships in applications such as data analysis, task management, or data-driven web applications.

// 9.flat(): 

// const numbers = [1, 2, [3, 4], 5, [6, [7, 8]]];
// console.log(numbers)
// console.log(numbers.flat(2)) // [1, 2, 3, 4, 5, 6, 7, 8]
// console.log(numbers) // non-mutator 

//  Creates a new array by flattening a nested array to a specified depth.
    // const numbers = [1, 2, [3, 4], 5, [6, [7, 8]]];

    // const flattenedArray = numbers.flat();

    // console.log(flattenedArray); // Output: [1, 2, 3, 4, 5, 6, 7, 8]

    // -------------------------------
    // One practical real case where the flat() function in JavaScript is commonly used is for flattening nested arrays into a single-level array.// Let's say you have an array that contains nested arrays, and you want to flatten it to obtain a single-level array with all the elements combined.
    // The flat() function is particularly useful when you have nested arrays and you want to simplify the data structure by combining all elements into a single array. It provides a convenient way to access and process all the elements without having to deal with nested levels of arrays.

    // The flat() function is commonly used in scenarios where you need to work with flattened data, such as when manipulating JSON data structures, processing recursive data structures, or performing operations that require a flat representation of the data.

    // Other practical applications of flat() include merging arrays, working with hierarchical data, handling tree structures, or transforming data between different formats or representations in various real-world applications, such as data processing, data visualization, or working with APIs.

    // Here's an example:

    // var nestedArray = [1, [2, 3], [4, [5, 6]]];
    // var flattenedArray = nestedArray.flat();
    // In this case, the flat() function is called on the nestedArray. It recursively flattens the nested arrays into a single-level array.

    // After executing the flat() function, the flattenedArray variable will contain a single-level array:

    // [1, 2, 3, 4, 5, 6]
    // The flat() function is particularly useful when you have nested arrays and you want to simplify the data structure by combining all elements into a single array. It provides a convenient way to access and process all the elements without having to deal with nested levels of arrays.

    // The flat() function is commonly used in scenarios where you need to work with flattened data, such as when manipulating JSON data structures, processing recursive data structures, or performing operations that require a flat representation of the data.

    // Other practical applications of flat() include merging arrays, working with hierarchical data, handling tree structures, or transforming data between different formats or representations in various real-world applications, such as data processing, data visualization, or working with APIs.

//10. flatMap():

// const numbers = [1, 2, 3, 4, 5]
// console.log(numbers.map(number => { return [number, number * 2] }))// [Array(2), Array(2), Array(2), Array(2), Array(2)]
// console.log((numbers.map(number => { return [number, number * 2] }).flat())) // [1, 2, 2, 4, 3, 6, 4, 8, 5, 10]
// // and this is map + flat = flatmap 
// console.log(numbers.flatMap(number => { return [number, number * 2] })) // [1, 2, 2, 4, 3, 6, 4, 8, 5, 10]

// flatMap => map + flat 

//  Maps each element using a mapping function, then flattens the result into a new array.
    // const numbers = [1, 2, 3, 4, 5];

    // const doubledNumbers = numbers.flatMap(function(number) {
    //   return [number, number * 2];
    // });

    // console.log(doubledNumbers); // Output: [1, 2, 2, 4, 3, 6, 4, 8, 5, 10]
    // -------------------------------
        // One practical real case where the flatMap() function in JavaScript is commonly used is when you have an array of objects and you want to extract a specific property from each object and flatten the results into a single array.// For example, let's say you have an array of user objects, and you want to extract all the unique tags associated with each user and store them in a single array./ In this case, the flatMap() function is called on the users array. The provided callback function returns the tags property of each user object.
        
        // The flatMap() function applies the callback function to each element of the array and then flattens the resulting arrays into a single array. It handles the flattening process automatically, eliminating the need for an additional step of manually flattening the results.
        
        // After executing the flatMap() function, the uniqueTags variable will contain a single array with all the unique tags:
        
        // ["developer", "javascript", "designer", "ux", "developer", "python"]
        // The flatMap() function is particularly useful when you need to extract and flatten specific properties or values from objects within an array. It provides a concise way to perform both the extraction and flattening operations in a single step.
        
        // The flatMap() function is commonly used in scenarios where you need to work with nested or hierarchical data structures, extract specific properties or values, transform data, or perform operations that require a flat representation of the extracted values.
        
        // Other practical applications of flatMap() include working with arrays of arrays, handling nested data structures, processing data from APIs or databases, or performing data manipulations in various real-world applications, such as data analysis, data transformation, or data visualization.
        
        
        
        // Here's an example:
        
        // var users = [
        //   { id: 1, name: "John", tags: ["developer", "javascript"] },
        //   { id: 2, name: "Jane", tags: ["designer", "ux"] },
        //   { id: 3, name: "Alex", tags: ["developer", "python"] }
        // ];
        
        // var uniqueTags = users.flatMap(function(user) {
        //   return user.tags;
        // });
        // In this case, the flatMap() function is called on the users array. The provided callback function returns the tags property of each user object.
        
        // The flatMap() function applies the callback function to each element of the array and then flattens the resulting arrays into a single array. It handles the flattening process automatically, eliminating the need for an additional step of manually flattening the results.
        
        // After executing the flatMap() function, the uniqueTags variable will contain a single array with all the unique tags:
        
        // ["developer", "javascript", "designer", "ux", "developer", "python"]
        // The flatMap() function is particularly useful when you need to extract and flatten specific properties or values from objects within an array. It provides a concise way to perform both the extraction and flattening operations in a single step.
        
        // The flatMap() function is commonly used in scenarios where you need to work with nested or hierarchical data structures, extract specific properties or values, transform data, or perform operations that require a flat representation of the extracted values.
        
        // Other practical applications of flatMap() include working with arrays of arrays, handling nested data structures, processing data from APIs or databases, or performing data manipulations in various real-world applications, such as data analysis, data transformation, or data visualization.
        
        
    
    
    
// 11.forEach(): Executes a provided function once for each array element.
    // const numbers = [1, 2, 3, 4, 5];

    // numbers.forEach(function(number) {
    //   console.log(number);
    // });

    // // Output:
    // // 1
    // // 2
    // // 3
    // // 4
    // // 5
    // -------------------------------
        // One practical real case where the forEach() function in JavaScript is commonly used is for iterating over elements in an array and performing a specific operation or action on each element.

        // For example, let's say you have an array of user objects, and you want to display a greeting message for each user in the console.
        
        // In this case, the forEach() function is called on the users array. The provided callback function is executed for each element in the array, and it logs a greeting message to the console for each user.
        
        // The forEach() function iterates through each element of the array and applies the specified callback function to each element.
        
        // When executing the code, you will see the following output in the console:
        // The forEach() function is commonly used when you need to perform a specific action or operation on each element of an array, such as updating values, making API calls, performing calculations, or manipulating data.
        
        // It provides a convenient way to iterate over array elements without the need for manual indexing or maintaining a separate loop counter.
        
        // Other practical applications of forEach() include updating the DOM elements, handling events, processing data, or performing any operation that needs to be applied to each element in an array or collection in various real-world applications, such as web development, data manipulation, or task automation.
        // Here's an example:
        
        // var users = [
        //   { id: 1, name: "John" },
        //   { id: 2, name: "Jane" },
        //   { id: 3, name: "Alex" }
        // ];
        
        // users.forEach(function(user) {
        //   console.log("Hello, " + user.name + "!");
        // });
        // In this case, the forEach() function is called on the users array. The provided callback function is executed for each element in the array, and it logs a greeting message to the console for each user.
        
        // The forEach() function iterates through each element of the array and applies the specified callback function to each element.
        
        // When executing the code, you will see the following output in the console:
        
      
        // Hello, John!
        // Hello, Jane!
        // Hello, Alex!
        // The forEach() function is commonly used when you need to perform a specific action or operation on each element of an array, such as updating values, making API calls, performing calculations, or manipulating data.
        
        // It provides a convenient way to iterate over array elements without the need for manual indexing or maintaining a separate loop counter.
        
        // Other practical applications of forEach() include updating the DOM elements, handling events, processing data, or performing any operation that needs to be applied to each element in an array or collection in various real-world applications, such as web development, data manipulation, or task automation.
// 12.from(): Creates a new array from an array-like or iterable object.
    // const str = 'Hello, World!';
    // const strArray = Array.from(str);

    // console.log(strArray); // Output: ['H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!']
    // -------------------------------
    // One practical real case where the forEach() function in JavaScript is commonly used is for iterating over elements in an array and performing a specific operation or action on each element.// For example, let's say you have an array of user objects, and you want to display a greeting message for each user in the console.
    // In this case, the forEach() function is called on the users array. The provided callback function is executed for each element in the array, and it logs a greeting message to the console for each user.
    // The forEach() function iterates through each element of the array and applies the specified callback function to each element.
    // The forEach() function is commonly used when you need to perform a specific action or operation on each element of an array, such as updating values, making API calls, performing calculations, or manipulating data.
    
    // It provides a convenient way to iterate over array elements without the need for manual indexing or maintaining a separate loop counter.
    
    // Other practical applications of forEach() include updating the DOM elements, handling events, processing data, or performing any operation that needs to be applied to each element in an array or collection in various real-world applications, such as web development, data manipulation, or task automation.
    // Here's an example:
    
    // javascript
    // Copy code
    // var users = [
    //   { id: 1, name: "John" },
    //   { id: 2, name: "Jane" },
    //   { id: 3, name: "Alex" }
    // ];
    
    // users.forEach(function(user) {
    //   console.log("Hello, " + user.name + "!");
    // });
    // In this case, the forEach() function is called on the users array. The provided callback function is executed for each element in the array, and it logs a greeting message to the console for each user.
    // The forEach() function iterates through each element of the array and applies the specified callback function to each element.
    
    // When executing the code, you will see the following output in the console:
    
    // Copy code
    // Hello, John!
    // Hello, Jane!
    // Hello, Alex!
    // The forEach() function is commonly used when you need to perform a specific action or operation on each element of an array, such as updating values, making API calls, performing calculations, or manipulating data.
    
    // It provides a convenient way to iterate over array elements without the need for manual indexing or maintaining a separate loop counter.
    
    // Other practical applications of forEach() include updating the DOM elements, handling events, processing data, or performing any operation that needs to be applied to each element in an array or collection in various real-world applications, such as web development, data manipulation, or task automation.
// 13.includes(): Checks if an array contains a specific element.
    // const numbers = [1, 2, 3, 4, 5];

    // const includesThree = numbers.includes(3);
    // const includesTen = numbers.includes(10);

    // console.log(includesThree); // Output: true
    // console.log(includesTen); // Output: false
    // -------------------------------
    //One practical real case where the includes() function in JavaScript is commonly used is for checking if a specific value exists in an array or string.// For example, let's say you have an array of numbers representing product IDs, and you want to check if a given product ID is present in the array.
    // In this case, the includes() function is called on the productIds array. It checks if the productIdToCheck is present in the array.

    // The includes() function returns a boolean value indicating whether the specified value is found in the array. If the value is present, it returns true; otherwise, it returns false.

    // In the example, the isIncluded variable will contain true because the productIdToCheck of 456 is included in the productIds array.

    // The includes() function is particularly useful when you need to perform a simple presence check for a specific value in an array or string. It provides a concise way to determine if an element exists without requiring a manual loop or conditional checks.

    // The includes() function can also be used to check if a substring exists within a larger string.

    // Other practical applications of includes() include search functionalities, input validation, conditional rendering of elements, or filtering based on specific values in various real-world applications, such as e-commerce, form validation, data processing, or search functionality implementations.
    // Here's an example:

    // var productIds = [123, 456, 789, 1011];
    // var productIdToCheck = 456;
    // var isIncluded = productIds.includes(productIdToCheck);
    // In this case, the includes() function is called on the productIds array. It checks if the productIdToCheck is present in the array.

    // The includes() function returns a boolean value indicating whether the specified value is found in the array. If the value is present, it returns true; otherwise, it returns false.

    // In the example, the isIncluded variable will contain true because the productIdToCheck of 456 is included in the productIds array.

    // The includes() function is particularly useful when you need to perform a simple presence check for a specific value in an array or string. It provides a concise way to determine if an element exists without requiring a manual loop or conditional checks.

    // The includes() function can also be used to check if a substring exists within a larger string.

    // Other practical applications of includes() include search functionalities, input validation, conditional rendering of elements, or filtering based on specific values in various real-world applications, such as e-commerce, form validation, data processing, or search functionality implementations.
// 14.indexOf(): Returns the first index at which a given element is found in the array.
    // const fruits = ['apple', 'banana', 'orange', 'apple'];

    // const indexOfApple = fruits.indexOf('apple');
    // const indexOfMango = fruits.indexOf('mango');

    // console.log(indexOfApple); // Output: 0
    // console.log(indexOfMango); // Output: -1
    // -------------------------------
    // One practical real case where the indexOf() function in JavaScript is commonly used is for searching and retrieving the index of a specific value within an array or string.// For example, let's say you have an array of usernames, and you want to find the index of a particular username.
    // In this case, the indexOf() function is called on the usernames array. It searches for the position of the usernameToFind within the array.
    // The indexOf() function returns the index of the first occurrence of the specified value in the array. If the value is not found, it returns -1.
    
    // In the example, the index variable will contain the value 2 because the username "alex" is located at index 2 within the usernames array.
    
    // The indexOf() function is particularly useful when you need to locate the position of a specific value within an array or find the first occurrence of a value in a string.
    
    // It allows you to easily retrieve the index of an element, which can be useful for various purposes such as data retrieval, conditional checks, or manipulating array elements at a specific position.
    
    // Here's an example:
    
    // var usernames = ["john", "jane", "alex", "emily"];
    // var usernameToFind = "alex";
    // var index = usernames.indexOf(usernameToFind);
    // In this case, the indexOf() function is called on the usernames array. It searches for the position of the usernameToFind within the array.
    // The indexOf() function returns the index of the first occurrence of the specified value in the array. If the value is not found, it returns -1.
    
    // In the example, the index variable will contain the value 2 because the username "alex" is located at index 2 within the usernames array.
    
    // The indexOf() function is particularly useful when you need to locate the position of a specific value within an array or find the first occurrence of a value in a string.
    
    // It allows you to easily retrieve the index of an element, which can be useful for various purposes such as data retrieval, conditional checks, or manipulating array elements at a specific position.
    
    // The indexOf() function is commonly used in scenarios where you need to search for the position of a specific value within an array or string, perform conditional operations based on the element's index, or retrieve related data associated with that index.
    
    // Other practical applications of indexOf() include removing elements from an array, validating the uniqueness of values, identifying the occurrence of specific elements, or implementing search functionality in various real-world applications such as data management, filtering, or user input validation.
// 15.join(): Joins all elements of an array into a string.
    // const fruits = ['apple', 'banana', 'orange'];

    // const joinedString = fruits.join(', ');

    // console.log(joinedString); // Output: "apple, banana, orange"
    // -------------------------------
    // One practical real case where the join() function in JavaScript is commonly used is for converting an array of values into a string representation, with each element joined by a specified delimiter.
    // For example, let's say you have an array of tags representing different categories, and you want to display them as a comma-separated string.
    // In this case, the join() function is called on the tags array. It joins each element of the array into a single string, with a comma and space as the delimiter between each element.
    // After executing the join() function, the tagString variable will contain the following string:
    // In this case, the join() function is called on the tags array. It joins each element of the array into a single string, with a comma and space as the delimiter between each element.
    // After executing the join() function, the tagString variable will contain the following string:

    // "javascript, html, css"
    // The join() function is particularly useful when you need to convert an array of values into a string representation for display, storage, or transmission.
    
    // It provides a convenient way to concatenate array elements into a single string with a specified delimiter, without the need for manual iteration or concatenation operations.
    
    // The join() function can also be used to concatenate other types of values, such as numbers or objects, into a string representation.
    
    // Other practical applications of join() include generating CSV (comma-separated values) files, constructing URL query strings, creating formatted output, or generating dynamic strings in various real-world applications, such as data manipulation, report generation, or string formatting.
    // Here's an example:
    // var tags = ["javascript", "html", "css"];
    
    // var tagString = tags.join(", ");
    // In this case, the join() function is called on the tags array. It joins each element of the array into a single string, with a comma and space as the delimiter between each element.
    // After executing the join() function, the tagString variable will contain the following string:

    // "javascript, html, css"
    // The join() function is particularly useful when you need to convert an array of values into a string representation for display, storage, or transmission.
    
    // It provides a convenient way to concatenate array elements into a single string with a specified delimiter, without the need for manual iteration or concatenation operations.
    
    // The join() function can also be used to concatenate other types of values, such as numbers or objects, into a string representation.
    
    // Other practical applications of join() include generating CSV (comma-separated values) files, constructing URL query strings, creating formatted output, or generating dynamic strings in various real-world applications, such as data manipulation, report generation, or string formatting.
// 16.keys(): Returns a new array iterator that contains the keys of the array.
    // const fruits = ['apple', 'banana', 'orange'];

    // const keys = fruits.keys();

    // for (const key of keys) {
    //   console.log(key);
    // }

    // // Output:
    // // 0
    // // 1
    // // 2
    // -------------------------------
    // One practical real case where the keys() function in JavaScript is commonly used is for obtaining an array of keys from an object.
    // For example, let's say you have an object that represents a user profile, and you want to retrieve an array of all the keys present in the object.
    // In this case, the keys() function is called on the Object object. It retrieves an array of keys present in the userProfile object.
    // After executing the keys() function, the keysArray variable will contain the following array:
    // The keys() function is particularly useful when you need to extract and work with the keys of an object dynamically. It allows you to access the keys without having to know them beforehand, which can be useful for tasks such as object manipulation, data validation, or iterating over object properties.
    
    // By obtaining an array of keys, you can easily perform operations on specific properties or loop over the object's properties using the retrieved keys.
    
    // Other practical applications of keys() include dynamic property access, object comparison, object cloning, or performing operations on object properties in various real-world applications such as data processing, object manipulation, or building dynamic user interfaces.
    // Here's an example:
   
    // var userProfile = {
    //   username: "john_doe",
    //   firstName: "John",
    //   lastName: "Doe",
    //   age: 30,
    //   email: "john.doe@example.com"
    // };
    
    // var keysArray = Object.keys(userProfile);
    // In this case, the keys() function is called on the Object object. It retrieves an array of keys present in the userProfile object.
    
    // After executing the keys() function, the keysArray variable will contain the following array:
    
    // javascript
    // Copy code
    // ["username", "firstName", "lastName", "age", "email"]
    // The keys() function is particularly useful when you need to extract and work with the keys of an object dynamically. It allows you to access the keys without having to know them beforehand, which can be useful for tasks such as object manipulation, data validation, or iterating over object properties.
    
    // By obtaining an array of keys, you can easily perform operations on specific properties or loop over the object's properties using the retrieved keys.
    
    // Other practical applications of keys() include dynamic property access, object comparison, object cloning, or performing operations on object properties in various real-world applications such as data processing, object manipulation, or building dynamic user interfaces.
// 17.lastIndexOf(): Returns the last index at which a given element is found in the array.
    // const numbers = [1, 2, 3, 4, 5, 3, 6, 7];

    // const lastIndexThree = numbers.lastIndexOf(3);
    // const lastIndexTen = numbers.lastIndexOf(10);

    // console.log(lastIndexThree); // Output: 5
    // console.log(lastIndexTen); // Output: -1
//-----------------------------
    // One practical real case where the lastIndexOf() function in JavaScript is commonly used is for finding the last occurrence of a specific value within an array or string.
    // For example, let's say you have an array of numbers representing product IDs, and you want to find the index of the last occurrence of a particular product ID.
    // In this case, the lastIndexOf() function is called on the productIds array. It searches for the last position of the productIdToFind within the array.

    // The lastIndexOf() function returns the index of the last occurrence of the specified value in the array. If the value is not found, it returns -1.

    // In the example, the lastIndex variable will contain the value 3 because the product ID 456 is found at the last position in the productIds array.

    // The lastIndexOf() function is particularly useful when you need to locate the position of the last occurrence of a specific value within an array or find the last occurrence of a value in a string.

    // It allows you to easily retrieve the index of the last element, which can be useful for various purposes such as data retrieval, conditional checks, or manipulating array elements based on their last occurrence.

    // The lastIndexOf() function is commonly used in scenarios where you need to search for the position of the last occurrence of a specific value within an array or string, perform conditional operations based on the element's index, or retrieve related data associated with that index.

    // Other practical applications of lastIndexOf() include removing elements from an array based on their last occurrence, validating the uniqueness of values from the end of an array, identifying the last occurrence of specific elements, or implementing search functionality from the end of a string in various real-world applications such as data management, filtering, or user input validation.


    // Here's an example:

    // var productIds = [123, 456, 789, 456, 1011];
    // var productIdToFind = 456;
    // var lastIndex = productIds.lastIndexOf(productIdToFind);
    // In this case, the lastIndexOf() function is called on the productIds array. It searches for the last position of the productIdToFind within the array.

    // The lastIndexOf() function returns the index of the last occurrence of the specified value in the array. If the value is not found, it returns -1.

    // In the example, the lastIndex variable will contain the value 3 because the product ID 456 is found at the last position in the productIds array.

    // The lastIndexOf() function is particularly useful when you need to locate the position of the last occurrence of a specific value within an array or find the last occurrence of a value in a string.

    // It allows you to easily retrieve the index of the last element, which can be useful for various purposes such as data retrieval, conditional checks, or manipulating array elements based on their last occurrence.

    // The lastIndexOf() function is commonly used in scenarios where you need to search for the position of the last occurrence of a specific value within an array or string, perform conditional operations based on the element's index, or retrieve related data associated with that index.

    // Other practical applications of lastIndexOf() include removing elements from an array based on their last occurrence, validating the uniqueness of values from the end of an array, identifying the last occurrence of specific elements, or implementing search functionality from the end of a string in various real-world applications such as data management, filtering, or user input validation.





// 18.map(): Creates a new array with the results of calling a provided function on each element.
    // const numbers = [1, 2, 3, 4, 5];

    // const doubledNumbers = numbers.map((num) => num * 2);

    // console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]
    // -------------------------------
        // One practical real case where the map() function in JavaScript is commonly used is for transforming each element of an array into a new array based on a specific mapping logic.
        // For example, let's say you have an array of numbers representing temperatures in Celsius, and you want to convert them into Fahrenheit.// In this case, the map() function is called on the celsiusTemperatures array. It applies a transformation logic to each element of the array and returns a new array containing the converted Fahrenheit temperatures.
        // The map() function iterates over each element of the array and applies the specified mapping function to each element, creating a new array with the results.
        // The map() function is particularly useful when you need to perform a one-to-one transformation on each element of an array, such as converting units, applying formulas, or transforming data into a different format.
                
        // It allows you to create a new array based on the modified elements of the original array without modifying the original array itself.
        
        // The map() function can also be used to perform more complex transformations, such as extracting specific properties from objects, manipulating strings, or creating new objects based on existing ones.
        
        // Other practical applications of map() include data normalization, formatting data for display, performing calculations on arrays, or creating derived data from existing data in various real-world applications such as data processing, data visualization, or building dynamic user interfaces.
        
        // Here's an example:
        
        // var celsiusTemperatures = [25, 30, 15, 20];
        // var fahrenheitTemperatures = celsiusTemperatures.map(function(celsius) {
        // return (celsius * 9/5) + 32;
        // });
        // In this case, the map() function is called on the celsiusTemperatures array. It applies a transformation logic to each element of the array and returns a new array containing the converted Fahrenheit temperatures.
        // The map() function iterates over each element of the array and applies the specified mapping function to each element, creating a new array with the results.
        
        // After executing the map() function, the fahrenheitTemperatures array will contain the following values:
        
        // [77, 86, 59, 68]
        // The map() function is particularly useful when you need to perform a one-to-one transformation on each element of an array, such as converting units, applying formulas, or transforming data into a different format.
        
        // It allows you to create a new array based on the modified elements of the original array without modifying the original array itself.
        
        // The map() function can also be used to perform more complex transformations, such as extracting specific properties from objects, manipulating strings, or creating new objects based on existing ones.
        
        // Other practical applications of map() include data normalization, formatting data for display, performing calculations on arrays, or creating derived data from existing data in various real-world applications such as data processing, data visualization, or building dynamic user interfaces.
// 19.pop(): Removes the last element from the array and returns it.
    // const fruits = ['apple', 'banana', 'orange'];

    // const removedFruit = fruits.pop();

    // console.log(fruits); // Output: ['apple', 'banana']
    // console.log(removedFruit); // Output: 'orange'
    // -------------------------------
    // One practical real case where the pop() function in JavaScript is commonly used is for removing the last element from an array and retrieving that element.
    // For example, let's say you have an array of tasks representing a to-do list, and you want to remove and retrieve the last task from the list.// In this case, the pop() function is called on the tasks array. It removes the last element from the array and returns that element.
    // After executing the pop() function, the lastTask variable will contain the value "Task 4", which was the last task in the tasks array.
    // The pop() function is particularly useful when you need to remove the last element from an array and perform some operation with that element, such as displaying it, processing it, or updating other data based on its value.
    // By using pop(), you can easily retrieve and manipulate the last element in an array without needing to manually track the index or modify the array's length.
    // Other practical applications of pop() include implementing stack data structures, removing and processing items in reverse order, implementing undo/redo functionality, or managing dynamic data in various real-world applications such as task management systems, chat applications, or data manipulation tools.
    // Here's an example:
    
    // var tasks = ["Task 1", "Task 2", "Task 3", "Task 4"];
    // var lastTask = tasks.pop();
    // In this case, the pop() function is called on the tasks array. It removes the last element from the array and returns that element.
    // After executing the pop() function, the lastTask variable will contain the value "Task 4", which was the last task in the tasks array.
    // The pop() function is particularly useful when you need to remove the last element from an array and perform some operation with that element, such as displaying it, processing it, or updating other data based on its value.
    // By using pop(), you can easily retrieve and manipulate the last element in an array without needing to manually track the index or modify the array's length.
    // Other practical applications of pop() include implementing stack data structures, removing and processing items in reverse order, implementing undo/redo functionality, or managing dynamic data in various real-world applications such as task management systems, chat applications, or data manipulation tools.
// 20.push(): Adds one or more elements to the end of the array and returns the new length.
    // const fruits = ['apple', 'banana'];
    // fruits.push('orange');
    // console.log(fruits); // Output: ['apple', 'banana', 'orange']
    // -------------------------------
    // One practical real case where the push() function in JavaScript is commonly used is for adding elements to the end of an array.
    // For example, let's say you have an array representing a shopping cart, and you want to add items to the cart.
    // The push() function is particularly useful when you need to dynamically add elements to an array. It allows you to append items to the end of the array without having to manually manage the array's length or index.
    
    // By using push(), you can easily add new elements to an array, such as when adding items to a shopping cart, adding messages to a chat log, or appending data to a dynamic list.
    
    // Other practical applications of push() include implementing stack or queue data structures, managing dynamic lists, appending data to an array, or maintaining a history of actions in various real-world applications such as e-commerce platforms, chat applications, or data collection systems.
    // Here's an example:
   
    // var shoppingCart = ["Item 1", "Item 2", "Item 3"];
    // shoppingCart.push("Item 4");
    // In this case, the push() function is called on the shoppingCart array. It adds the specified item to the end of the array.
    // After executing the push() function, the shoppingCart array will be updated with the new item, and it will contain the following elements:
    
    // ["Item 1", "Item 2", "Item 3", "Item 4"]
    // The push() function is particularly useful when you need to dynamically add elements to an array. It allows you to append items to the end of the array without having to manually manage the array's length or index.
    
    // By using push(), you can easily add new elements to an array, such as when adding items to a shopping cart, adding messages to a chat log, or appending data to a dynamic list.
    
    // Other practical applications of push() include implementing stack or queue data structures, managing dynamic lists, appending data to an array, or maintaining a history of actions in various real-world applications such as e-commerce platforms, chat applications, or data collection systems.
// 21.reduce(): Applies a function to reduce the array to a single value.
    // const numbers = [1, 2, 3, 4, 5];

    // const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);

    // console.log(sum); // Output: 15
    // -------------------------------
        // One practical real case where the reduce() function in JavaScript is commonly used is for aggregating or calculating a single value from an array of values.

        // For example, let's say you have an array of numbers representing the prices of items in a shopping cart, and you want to calculate the total cost of all the items.
         
        // The reduce() function takes two arguments: a callback function and an initial value for the accumulator. The callback function receives the accumulator and each element of the array, and it returns the updated value of the accumulator.
        
        // After executing the reduce() function, the totalCost variable will contain the value 28.46, which is the sum of all the prices in the prices array.
        
        // The reduce() function is particularly useful when you need to perform calculations or aggregations on an array of values, such as calculating totals, averages, maximum or minimum values, or any other operation that requires combining multiple values into a single result.
        
        // It allows you to reduce an array of values into a single value by iteratively applying a calculation or operation to each element of the array.
        
        // Other practical applications of reduce() include finding the highest or lowest value in an array, counting occurrences of specific values, concatenating strings, grouping data, or performing custom calculations on array elements in various real-world applications such as data analysis, reporting, or financial calculations.
        // Here's an example:
        
        // var prices = [10.99, 5.99, 7.49, 3.99];
        // var totalCost = prices.reduce(function(acc, price) {
        //   return acc + price;
        // }, 0);
        // In this case, the reduce() function is called on the prices array. It iterates over each element of the array and accumulates a running total by adding each element to the accumulator (acc in the example).
        
        // The reduce() function takes two arguments: a callback function and an initial value for the accumulator. The callback function receives the accumulator and each element of the array, and it returns the updated value of the accumulator.
        
        // After executing the reduce() function, the totalCost variable will contain the value 28.46, which is the sum of all the prices in the prices array.
        
        // The reduce() function is particularly useful when you need to perform calculations or aggregations on an array of values, such as calculating totals, averages, maximum or minimum values, or any other operation that requires combining multiple values into a single result.
        
        // It allows you to reduce an array of values into a single value by iteratively applying a calculation or operation to each element of the array.
        
        // Other practical applications of reduce() include finding the highest or lowest value in an array, counting occurrences of specific values, concatenating strings, grouping data, or performing custom calculations on array elements in various real-world applications such as data analysis, reporting, or financial calculations.
// 22.reduceRight(): Applies a function to reduce the array from right to left to a single value.
    // const numbers = [1, 2, 3, 4, 5];

    // const concatenatedString = numbers.reduceRight((accumulator, currentValue) => accumulator + currentValue.toString(), '');

    // console.log(concatenatedString); // Output: "54321"
    // -------------------------------
    // One practical real case where the reduceRight() function in JavaScript is commonly used is for aggregating or calculating a single value from an array of values, starting from the right side of the array.
    // For example, let's say you have an array of strings representing the steps of a recipe, and you want to concatenate them in reverse order to display the recipe instructions.// In this case, the reduceRight() function is called on the recipeSteps array. It iterates over each element of the array starting from the right side and accumulates a result by concatenating each step with the accumulator (acc in the example).

    // The reduceRight() function takes two arguments: a callback function and an initial value for the accumulator. The callback function receives the accumulator and each element of the array, and it returns the updated value of the accumulator.// The reduceRight() function is particularly useful when you need to perform calculations or aggregations on an array of values, but starting from the right side of the array instead of the left side.

    // It allows you to reduce an array of values into a single value by iteratively applying a calculation or operation to each element of the array, starting from the right side.

    // Other practical applications of reduceRight() include concatenating strings in reverse order, performing calculations on data in reverse order, building hierarchical structures from arrays, or processing data in reverse chronological order in various real-world applications such as generating reports, building navigational menus, or manipulating time-series data.

    // Here's an example:

    // var recipeSteps = ["Step 1: Preheat the oven", "Step 2: Mix the ingredients", "Step 3: Bake the cake"];
    // var reversedInstructions = recipeSteps.reduceRight(function(acc, step) {
    //   return acc + "\n" + step;
    // }, "");
    // In this case, the reduceRight() function is called on the recipeSteps array. It iterates over each element of the array starting from the right side and accumulates a result by concatenating each step with the accumulator (acc in the example).

    // The reduceRight() function takes two arguments: a callback function and an initial value for the accumulator. The callback function receives the accumulator and each element of the array, and it returns the updated value of the accumulator.

    // After executing the reduceRight() function, the reversedInstructions variable will contain the following string:

    // vbnet
    // Copy code
    // Step 3: Bake the cake
    // Step 2: Mix the ingredients
    // Step 1: Preheat the oven
    // The reduceRight() function is particularly useful when you need to perform calculations or aggregations on an array of values, but starting from the right side of the array instead of the left side.

    // It allows you to reduce an array of values into a single value by iteratively applying a calculation or operation to each element of the array, starting from the right side.

    // Other practical applications of reduceRight() include concatenating strings in reverse order, performing calculations on data in reverse order, building hierarchical structures from arrays, or processing data in reverse chronological order in various real-world applications such as generating reports, building navigational menus, or manipulating time-series data.

// 23.reverse(): Reverses the order of the elements in the array.
    // const fruits = ['apple', 'banana', 'orange'];

    // fruits.reverse();

    // console.log(fruits); // Output: ['orange', 'banana', 'apple']
    // -------------------------------


// 24.shift(): Removes the first element from the array and returns it.
    // const fruits = ['apple', 'banana', 'orange'];

    // const shiftedElement = fruits.shift();

    // console.log(fruits); // Output: ['banana', 'orange']
    // console.log(shiftedElement); // Output: 'apple'
    // -------------------------------
    // One practical real case where the shift() function in JavaScript is commonly used is for removing and retrieving the first element from an array.

    // For example, let's say you have an array of strings representing a queue of tasks, and you want to process each task one by one, starting from the first task in the queue.
    // In this case, the shift() function is called on the taskQueue array. It removes the first element from the array and returns that element.
    
    // After executing the shift() function, the currentTask variable will contain the value "Task 1", which was the first task in the taskQueue array.
    
    // The shift() function is particularly useful when you need to process items in a queue-like manner, where the first item added to the array should be the first item to be processed.
    
    // By using shift(), you can easily retrieve and remove the first element from an array without manually tracking the index or modifying the array's length.
    
    // Other practical applications of shift() include implementing queue data structures, processing items in a specific order, managing task queues, or implementing message queues in various real-world applications such as job scheduling systems, message processing systems, or asynchronous operations handling.
    
    // Here's an example:
    
    // var taskQueue = ["Task 1", "Task 2", "Task 3"];
    // var currentTask = taskQueue.shift();
    // In this case, the shift() function is called on the taskQueue array. It removes the first element from the array and returns that element.
    
    // After executing the shift() function, the currentTask variable will contain the value "Task 1", which was the first task in the taskQueue array.
    
    // The shift() function is particularly useful when you need to process items in a queue-like manner, where the first item added to the array should be the first item to be processed.
    
    // By using shift(), you can easily retrieve and remove the first element from an array without manually tracking the index or modifying the array's length.
    
    // Other practical applications of shift() include implementing queue data structures, processing items in a specific order, managing task queues, or implementing message queues in various real-world applications such as job scheduling systems, message processing systems, or asynchronous operations handling.
    
    
    
    
    
// 25.slice(): Extracts a section of an array and returns a new array.
    // const fruits = ['apple', 'banana', 'orange', 'mango', 'kiwi'];

    // const slicedFruits = fruits.slice(1, 4);

    // console.log(slicedFruits); // Output: ['banana', 'orange', 'mango']
        // -------------------------------

    // One practical real case where the slice() function in JavaScript is commonly used is for extracting a portion of an array without modifying the original array.
    // For example, let's say you have an array of user records, and you want to retrieve a subset of users based on a specific condition, such as users with a certain age range.
 // In this case, the slice() function is called on the userRecords array. It extracts a portion of the array starting from the index specified by the first argument (1 in the example) up to, but not including, the index specified by the second argument (4 in the example).
    // The slice() function is particularly useful when you need to create a new array that contains a subset of the elements from an existing array.
    
    // It allows you to extract a portion of an array without modifying the original array itself, which can be helpful for filtering, paginating, or manipulating data while preserving the integrity of the original array.
    
    // Other practical applications of slice() include pagination, sorting and extracting a range of elements, creating copies of arrays, splitting arrays, or manipulating subsets of data in various real-world applications such as data filtering, data presentation, or data analysis.
    
    // Here's an example:
    
    // var userRecords = [
    //   { name: "John", age: 25 },
    //   { name: "Alice", age: 32 },
    //   { name: "Bob", age: 40 },
    //   { name: "Emily", age: 28 },
    //   { name: "Mike", age: 35 }
    // ];
    
    // var middleAgedUsers = userRecords.slice(1, 4);
    // In this case, the slice() function is called on the userRecords array. It extracts a portion of the array starting from the index specified by the first argument (1 in the example) up to, but not including, the index specified by the second argument (4 in the example).
    
    // After executing the slice() function, the middleAgedUsers variable will contain a new array with the following elements:
    
    // [
    //   { name: "Alice", age: 32 },
    //   { name: "Bob", age: 40 },
    //   { name: "Emily", age: 28 }
    // ]
    // The slice() function is particularly useful when you need to create a new array that contains a subset of the elements from an existing array.
    
    // It allows you to extract a portion of an array without modifying the original array itself, which can be helpful for filtering, paginating, or manipulating data while preserving the integrity of the original array.
    
    // Other practical applications of slice() include pagination, sorting and extracting a range of elements, creating copies of arrays, splitting arrays, or manipulating subsets of data in various real-world applications such as data filtering, data presentation, or data analysis.
// 26.some(): Checks if at least one element in the array satisfies a given condition.
    // const numbers = [1, 2, 3, 4, 5];

    // const hasEvenNumber = numbers.some((number) => number % 2 === 0);

    // console.log(hasEvenNumber); // Output: true
    // -------------------------------
    // One practical real case where the some() function in JavaScript is commonly used is for checking if at least one element in an array satisfies a specific condition.
    // For example, let's say you have an array of numbers representing temperatures, and you want to determine if there is at least one temperature above a certain threshold.
        // In this case, the some() function is called on the temperatures array. It iterates over each element of the array and checks if the temperature is greater than 25.
    
    // The some() function takes a callback function as an argument. The callback function is called with each element of the array, and it returns a boolean value indicating if the condition is true for at least one element.
    
    // After executing the some() function, the isHot variable will contain true if at least one temperature in the temperatures array is above 25, and false otherwise.
    
    // The some() function is particularly useful when you need to perform a condition check on an array and determine if at least one element satisfies the condition.
    
    // It allows you to quickly and efficiently determine the presence of a desired condition without needing to iterate over the entire array or manually track the result.
    
    // Other practical applications of some() include validation checks, determining if an array contains any elements that meet specific criteria, checking for the existence of certain values, or implementing conditional logic based on array content in various real-world applications such as form validation, data filtering, or access control.
    // Here's an example:
    
    // var temperatures = [23, 25, 21, 28, 20];
    // var isHot = temperatures.some(function(temperature) {
    //   return temperature > 25;
    // });
    // In this case, the some() function is called on the temperatures array. It iterates over each element of the array and checks if the temperature is greater than 25.
    
    // The some() function takes a callback function as an argument. The callback function is called with each element of the array, and it returns a boolean value indicating if the condition is true for at least one element.
    
    // After executing the some() function, the isHot variable will contain true if at least one temperature in the temperatures array is above 25, and false otherwise.
    
    // The some() function is particularly useful when you need to perform a condition check on an array and determine if at least one element satisfies the condition.
    
    // It allows you to quickly and efficiently determine the presence of a desired condition without needing to iterate over the entire array or manually track the result.
    
    // Other practical applications of some() include validation checks, determining if an array contains any elements that meet specific criteria, checking for the existence of certain values, or implementing conditional logic based on array content in various real-world applications such as form validation, data filtering, or access control.
// 27.sort(): Sorts the elements of the array in place.
    // const fruits = ['apple', 'banana', 'orange', 'mango'];

    // fruits.sort();

    // console.log(fruits); // Output: ['apple', 'banana', 'mango', 'orange']
    // -------------------------------
    // One practical real case where the sort() function in JavaScript is commonly used is for sorting an array of elements in a specific order.
    // For example, let's say you have an array of objects representing products, and you want to sort them based on their prices in ascending order.
    // In this case, the sort() function is called on the products array. It sorts the array based on the comparison of the price property of each object.
    
    // The sort() function takes a callback function as an argument. The callback function compares two elements from the array and returns a negative value if the first element should come before the second element, a positive value if the second element should come before the first element, or zero if the elements are equal.
    // The sort() function is particularly useful when you need to arrange the elements of an array in a specific order, such as sorting a list of items based on their properties, values, or custom comparison criteria.
    
    // It allows you to easily sort an array without having to implement your own sorting algorithm or manually reorganize the array elements.
    
    // Other practical applications of sort() include sorting arrays of strings, dates, or any other comparable values, implementing custom sorting logic, arranging data for display or analysis, or organizing data in a specific order for various real-world applications such as e-commerce platforms, data visualization, or data processing.
    // Here's an example:
    
    // var products = [
    //   { name: "Product A", price: 20.99 },
    //   { name: "Product B", price: 15.99 },
    //   { name: "Product C", price: 25.99 },
    //   { name: "Product D", price: 10.99 }
    // ];
    
    // products.sort(function(a, b) {
    //   return a.price - b.price;
    // });
    // In this case, the sort() function is called on the products array. It sorts the array based on the comparison of the price property of each object.
    
    // The sort() function takes a callback function as an argument. The callback function compares two elements from the array and returns a negative value if the first element should come before the second element, a positive value if the second element should come before the first element, or zero if the elements are equal.
    
    // After executing the sort() function, the products array will be sorted in ascending order based on the prices:
    
    // [
    //   { name: "Product D", price: 10.99 },
    //   { name: "Product B", price: 15.99 },
    //   { name: "Product A", price: 20.99 },
    //   { name: "Product C", price: 25.99 }
    // ]
    // The sort() function is particularly useful when you need to arrange the elements of an array in a specific order, such as sorting a list of items based on their properties, values, or custom comparison criteria.
    
    // It allows you to easily sort an array without having to implement your own sorting algorithm or manually reorganize the array elements.
    
    // Other practical applications of sort() include sorting arrays of strings, dates, or any other comparable values, implementing custom sorting logic, arranging data for display or analysis, or organizing data in a specific order for various real-world applications such as e-commerce platforms, data visualization, or data processing.
// 28.splice(): Changes the content of an array by removing, replacing, or adding elements.
    // const numbers = [1, 2, 3, 4, 5];
    // const removedElements = numbers.splice(2, 2);

    // console.log(numbers); // Output: [1, 2, 5]
    // console.log(removedElements); // Output: [3, 4]
    // -------------------------------
    // One practical real case where the splice() function in JavaScript is commonly used is for modifying an array by adding, removing, or replacing elements at specific positions.
    // For example, let's say you have an array of numbers representing a list of scores, and you want to remove a specific score from the array and replace it with a new score.
        // In this case, the splice() function is called on the scores array. It removes one element at the index specified by the first argument (2 in the example), and then inserts a new element (92 in the example) at the same position.
    
    // The splice() function takes three arguments: the index at which to start the modification, the number of elements to remove, and the elements to add at that position.

    // Here's an example:
    
    // var scores = [80, 85, 90, 95, 100];
    // // Remove the score at index 2 (90) and replace it with a new score of 92
    // scores.splice(2, 1, 92);
    // In this case, the splice() function is called on the scores array. It removes one element at the index specified by the first argument (2 in the example), and then inserts a new element (92 in the example) at the same position.
    
    // The splice() function takes three arguments: the index at which to start the modification, the number of elements to remove, and the elements to add at that position.
    
    // The splice() function is particularly useful when you need to modify an array by adding, removing, or replacing elements at specific positions.
    
    // It allows you to modify an array in-place, without creating a new array or manually manipulating individual elements.
    
    // Other practical applications of splice() include adding new elements to an array at specific positions, removing multiple elements at once, extracting a subset of elements from an array, or implementing advanced data manipulation logic in various real-world applications such as CRUD operations, data modeling, or interactive user interfaces.
    
    // After executing the splice() function, the scores array will be modified as follows:
    
    // [80, 85, 92, 95, 100]
    // The element at index 2 (90) is removed, and the new score of 92 is inserted at that position.
    
    // The splice() function is particularly useful when you need to modify an array by adding, removing, or replacing elements at specific positions.
    
    // It allows you to modify an array in-place, without creating a new array or manually manipulating individual elements.
    
    // Other practical applications of splice() include adding new elements to an array at specific positions, removing multiple elements at once, extracting a subset of elements from an array, or implementing advanced data manipulation logic in various real-world applications such as CRUD operations, data modeling, or interactive user interfaces.
// 29.toLocaleString(): Returns a string representing the elements of the array formatted according to the current locale.
    // const numbers = [1000, 2000, 3000, 4000];

    // const formattedNumbers = numbers.toLocaleString();

    // console.log(formattedNumbers); // Output: "1,000, 2,000, 3,000, 4,000"
    // -------------------------------
    // One practical real case where the toLocaleString() function in JavaScript is commonly used is for formatting numbers, dates, or currencies according to the user's locale or specific formatting requirements.
    // For example, let's say you have a web application that displays sales data to users in different countries. You want to format the sales figures according to each user's preferred number formatting, including decimal separators, thousands separators, and locale-specific symbols.
    // The toLocaleString() function takes one or two arguments. The first argument is the locale code, which determines the formatting rules to apply. The second argument (optional) is an options object that allows you to specify additional formatting preferences, such as the currency code.
    
    // After executing the toLocaleString() function, the formattedSales variable will contain the sales value formatted as a currency string according to the 'en-US' locale:
    
    // The toLocaleString() function is particularly useful when you need to present numbers, dates, or currencies in a user-friendly and culturally appropriate format.
    
    // It automatically adapts the formatting based on the user's locale, taking into account language conventions, number systems, and symbol usage.
    
    // Other practical applications of toLocaleString() include formatting dates in different date and time formats, customizing the number of decimal places, applying percentage or scientific notation, or implementing multi-lingual support in various real-world applications such as e-commerce platforms, financial systems, or internationalized web applications.
    // Here's an example:
    
    // var sales = 1500000;
    // var formattedSales = sales.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
    // In this case, the toLocaleString() function is called on the sales number. It formats the number according to the specified locale ('en-US' in the example) and the desired formatting options.
    
    // The toLocaleString() function takes one or two arguments. The first argument is the locale code, which determines the formatting rules to apply. The second argument (optional) is an options object that allows you to specify additional formatting preferences, such as the currency code.
    
    // After executing the toLocaleString() function, the formattedSales variable will contain the sales value formatted as a currency string according to the 'en-US' locale:
    
    // $1,500,000.00
    // The number is formatted with a thousands separator (comma), a decimal separator (dot), and the currency symbol for USD ($).
    
    // The toLocaleString() function is particularly useful when you need to present numbers, dates, or currencies in a user-friendly and culturally appropriate format.
    
    // It automatically adapts the formatting based on the user's locale, taking into account language conventions, number systems, and symbol usage.
    
    // Other practical applications of toLocaleString() include formatting dates in different date and time formats, customizing the number of decimal places, applying percentage or scientific notation, or implementing multi-lingual support in various real-world applications such as e-commerce platforms, financial systems, or internationalized web applications.
// 30.toString(): Returns a string representing the array and its elements.
    // const fruits = ['apple', 'banana', 'orange'];

    // const fruitsString = fruits.toString();

    // console.log(fruitsString); // Output: "apple,banana,orange"
    // -------------------------------
    // One practical real case where the toString() function in JavaScript is commonly used is for converting an object or a value into its string representation.// For example, let's say you have a date object representing a specific date and time, and you want to convert it into a string to display it in a user-friendly format.
    // In this case, the toString() function is called on the currentDate object. It converts the date object into a string representation based on the implementation-defined format.
    
    // After executing the toString() function, the dateString variable will contain the string representation of the current date and time:
    // The toString() function is particularly useful when you need to obtain a human-readable string representation of an object or a value.
    
    // It is commonly used with date objects, providing a default string representation of the date and time. However, it can also be used with other types of objects or values to obtain their default string representations.
    
    // Other practical applications of toString() include converting numbers to strings, converting arrays to strings, obtaining string representations of custom objects, or implementing custom string conversions in various real-world applications such as data serialization, logging, debugging, or displaying information to users.
    // Here's an example:
   
    // var currentDate = new Date();
    // var dateString = currentDate.toString();
    // In this case, the toString() function is called on the currentDate object. It converts the date object into a string representation based on the implementation-defined format.
    
    // After executing the toString() function, the dateString variable will contain the string representation of the current date and time:
    
    // arduino
    // Copy code
    // "Wed Jun 05 2023 13:24:45 GMT+0000 (Coordinated Universal Time)"
    // The toString() function is particularly useful when you need to obtain a human-readable string representation of an object or a value.
    
    // It is commonly used with date objects, providing a default string representation of the date and time. However, it can also be used with other types of objects or values to obtain their default string representations.
    
    // Other practical applications of toString() include converting numbers to strings, converting arrays to strings, obtaining string representations of custom objects, or implementing custom string conversions in various real-world applications such as data serialization, logging, debugging, or displaying information to users.
// 31.unshift(): Adds one or more elements to the beginning of the array and returns the new length.
    // const fruits = ['banana', 'orange'];

    // fruits.unshift('apple');

    // console.log(fruits); // Output: ['apple', 'banana', 'orange']
    // -------------------------------
    // One practical real case where the unshift() function in JavaScript is commonly used is for adding elements to the beginning of an array.// For example, let's say you have an array representing a to-do list, and you want to add a new task to the beginning of the list.// In this case, the unshift() function is called on the todoList array. It adds a new element ("New Task" in the example) to the beginning of the array, shifting all existing elements to higher indices.
    // After executing the unshift() function, the todoList array will be modified as follows:
    // The unshift() function is particularly useful when you need to prepend new elements to an array and maintain the order of existing elements.
    
    // It allows you to easily add elements to the beginning of an array without needing to manually shift the indices or create a new array.
    
    // Other practical applications of unshift() include building dynamic lists, implementing stack-like behavior, adding header elements to tables or lists, or maintaining a history of actions in various real-world applications such as task management systems, chat applications, or interactive interfaces.
    
    // Here's an example:
   
    // var todoList = ["Task 1", "Task 2", "Task 3"];
    // // Add a new task at the beginning of the list
    // todoList.unshift("New Task");
    // In this case, the unshift() function is called on the todoList array. It adds a new element ("New Task" in the example) to the beginning of the array, shifting all existing elements to higher indices.
    
    // After executing the unshift() function, the todoList array will be modified as follows:
    
    // ["New Task", "Task 1", "Task 2", "Task 3"]
    // The new task is added to the beginning of the array, pushing the existing tasks one position higher.
    
    // The unshift() function is particularly useful when you need to prepend new elements to an array and maintain the order of existing elements.
    
    // It allows you to easily add elements to the beginning of an array without needing to manually shift the indices or create a new array.
    
    // Other practical applications of unshift() include building dynamic lists, implementing stack-like behavior, adding header elements to tables or lists, or maintaining a history of actions in various real-world applications such as task management systems, chat applications, or interactive interfaces.
// 32.values(): Returns a new array iterator that contains the values of the array.
    // const numbers = [1, 2, 3, 4, 5];

    // const iterator = numbers.values();

    // console.log(iterator.next().value); // Output: 1
    // console.log(iterator.next().value); // Output: 2
    // console.log(iterator.next().value); // Output: 3
    // console.log(iterator.next().value); // Output: 4
    // console.log(iterator.next().value); // Output: 5
        // -------------------------------
        // One practical real case where the values() function in JavaScript is commonly used is for iterating over the values of an object or a data structure that supports iteration.// For example, let's say you have an object that represents a collection of user information, and you want to iterate over the values of that object to perform some operations on each value.
        // In this case, the values() function is called on the Object global object, passing the user object as an argument. It returns an array containing the values of the properties in the user object.
        
        // The forEach() function is then called on the userValues array, and a callback function is passed as an argument. The callback function logs each value to the console.
        
        // When executed, the code will output the values of the name, age, and email properties of the user object:
                // The values() function is particularly useful when you need to extract and work with the values of an object or a data structure.
        
        // It allows you to easily access and iterate over the values without needing to manually extract them or write custom iteration logic.
        
        // Other practical applications of values() include extracting values from arrays, maps, or sets, performing operations or transformations on values, filtering or searching for specific values, or implementing data processing or analysis in various real-world applications such as data manipulation, object-oriented programming, or working with external APIs and data sources.

        // Here's an example:
        
        // var user = {
        //   name: "John",
        //   age: 30,
        //   email: "john@example.com"
        // };
        
        // var userValues = Object.values(user);
        
        // userValues.forEach(function(value) {
        //   console.log(value);
        // });
        // In this case, the values() function is called on the Object global object, passing the user object as an argument. It returns an array containing the values of the properties in the user object.
        
        // The forEach() function is then called on the userValues array, and a callback function is passed as an argument. The callback function logs each value to the console.
        
        // When executed, the code will output the values of the name, age, and email properties of the user object:
        
        // css
        // Copy code
        // John
        // 30
        // john@example.com
        // The values() function is particularly useful when you need to extract and work with the values of an object or a data structure.
        
        // It allows you to easily access and iterate over the values without needing to manually extract them or write custom iteration logic.
        
        // Other practical applications of values() include extracting values from arrays, maps, or sets, performing operations or transformations on values, filtering or searching for specific values, or implementing data processing or analysis in various real-world applications such as data manipulation, object-oriented programming, or working with external APIs and data sources.

// 33.flatmap(): Maps each element using a mapping function, then flattens the result into a new array.
    // const numbers = [1, 2, 3, 4, 5];

    // const multipliedNumbers = numbers.flatMap(num => [num, num * 2]);

    // console.log(multipliedNumbers); // Output: [1, 2, 2, 4, 3, 6, 4, 8, 5, 10]
        // -------------------------------
        // One practical real case where the flatMap() function in JavaScript is commonly used is for flattening and transforming arrays in a single step.// For example, let's say you have an array of objects representing books, and each book has an array of tags associated with it. You want to extract all the unique tags from the books and create a flattened array of tags.
        // In this case, the flatMap() function is called on the books array. It applies a transformation function to each book, returning the tags array of each book. The flatMap() function then flattens the resulting arrays into a single, one-dimensional array.
        
        // After executing the flatMap() function, the uniqueTags variable will contain an array of unique tags extracted from the books:

        // Here's an example:
        
        // var books = [
        //   { title: "Book 1", tags: ["fiction", "adventure"] },
        //   { title: "Book 2", tags: ["fiction", "mystery"] },
        //   { title: "Book 3", tags: ["fantasy", "adventure"] }
        // ];
        
        // var uniqueTags = books.flatMap(book => book.tags).filter((tag, index, self) => self.indexOf(tag) === index);
        // In this case, the flatMap() function is called on the books array. It applies a transformation function to each book, returning the tags array of each book. The flatMap() function then flattens the resulting arrays into a single, one-dimensional array.
        
        // After executing the flatMap() function, the uniqueTags variable will contain an array of unique tags extracted from the books:
        // The flatMap() function is particularly useful when you need to perform a combination of mapping (extracting values from objects) and flattening (creating a one-dimensional array) in a single operation.
        
        // It allows you to handle nested arrays and extract values from them while creating a flat result array.
        
        // Other practical applications of flatMap() include working with nested arrays of data, transforming and merging arrays, handling asynchronous operations, or implementing data preprocessing and transformation in various real-world applications such as data analysis, data visualization, or working with complex data structures.

        // css
        // Copy code
        // ["fiction", "adventure", "mystery", "fantasy"]
        // The flatMap() function is particularly useful when you need to perform a combination of mapping (extracting values from objects) and flattening (creating a one-dimensional array) in a single operation.
        
        // It allows you to handle nested arrays and extract values from them while creating a flat result array.
        
        // Other practical applications of flatMap() include working with nested arrays of data, transforming and merging arrays, handling asynchronous operations, or implementing data preprocessing and transformation in various real-world applications such as data analysis, data visualization, or working with complex data structures.

// 34.filter(): Creates a new array with all elements that pass a test.
    // const numbers = [1, 2, 3, 4, 5];
    // const evenNumbers = numbers.filter(num => num % 2 === 0);

    // console.log(evenNumbers); // Output: [2, 4]
    // -------------------------------
    // One practical real case where the filter() function in JavaScript is commonly used is for filtering and extracting elements from an array based on specific criteria.// For example, let's say you have an array of numbers representing test scores, and you want to filter out the scores that are below a certain threshold.
    // In this case, the filter() function is called on the scores array. It applies a filtering condition to each score in the array, retaining only the scores that satisfy the condition (in this case, scores greater than or equal to 80).
    // In this case, the filter() function is called on the scores array. It applies a filtering condition to each score in the array, retaining only the scores that satisfy the condition (in this case, scores greater than or equal to 80).
    
    // After executing the filter() function, the passingScores variable will contain an array of scores that passed the filtering criteria:
    // The filter() function is particularly useful when you need to select or exclude elements from an array based on specific conditions.
    
    // It allows you to easily create new arrays containing only the elements that meet certain criteria, without modifying the original array.
    
    // Other practical applications of filter() include searching for specific values, removing duplicates, implementing data validation or sanitization, performing data analysis or data processing operations, or implementing user-driven filtering in various real-world applications such as e-commerce platforms, data-driven interfaces, or data visualization tools.
    // Here's an example:
    // var scores = [85, 92, 78, 95, 88, 72, 90];
    // var passingScores = scores.filter(score => score >= 80);
    
    
    // [85, 92, 95, 88, 90]
    // The filter() function is particularly useful when you need to select or exclude elements from an array based on specific conditions.
    
    // It allows you to easily create new arrays containing only the elements that meet certain criteria, without modifying the original array.
    
    // Other practical applications of filter() include searching for specific values, removing duplicates, implementing data validation or sanitization, performing data analysis or data processing operations, or implementing user-driven filtering in various real-world applications such as e-commerce platforms, data-driven interfaces, or data visualization tools.
// 35.find(): Returns the first element in the array that satisfies a provided testing function.
    // const fruits = ['apple', 'banana', 'orange', 'mango'];

    // const foundFruit = fruits.find(fruit => fruit === 'orange');

    // console.log(foundFruit); // Output: orange
    // -------------------------------
    // One practical real case where the find() function in JavaScript is commonly used is for searching and retrieving a specific element from an array based on a condition.// For example, let's say you have an array of objects representing products, and you want to find a product with a specific ID.
    // In this case, the find() function is called on the products array. It applies a condition to each object in the array, searching for the first object that satisfies the condition (in this case, the object with the id matching productId).
    
    // After executing the find() function, the product variable will contain the object that matches the specified condition:
// In this case, the find() function is called on the products array. It applies a condition to each object in the array, searching for the first object that satisfies the condition (in this case, the object with the id matching productId).
    
    // After executing the find() function, the product variable will contain the object that matches the specified condition:
// The find() function is particularly useful when you need to search for a specific element in an array based on a given condition.
    
    // It allows you to easily retrieve the first matching element without needing to manually iterate over the array or write custom search logic.
    
    // Other practical applications of find() include searching for objects based on multiple criteria, implementing user-driven search functionality, retrieving data from large datasets, or implementing data lookup in various real-world applications such as inventory management systems, search engines, or filtering and querying data in databases.
    // Here's an example:
    
    // var products = [
    //   { id: 1, name: "Product 1" },
    //   { id: 2, name: "Product 2" },
    //   { id: 3, name: "Product 3" }
    // ];
    
    // var productId = 2;
    
    // var product = products.find(item => item.id === productId);
    
    
    // { id: 2, name: "Product 2" }
    // The find() function is particularly useful when you need to search for a specific element in an array based on a given condition.
    
    // It allows you to easily retrieve the first matching element without needing to manually iterate over the array or write custom search logic.
    
    // Other practical applications of find() include searching for objects based on multiple criteria, implementing user-driven search functionality, retrieving data from large datasets, or implementing data lookup in various real-world applications such as inventory management systems, search engines, or filtering and querying data in databases.
// 36.findIndex(): Returns the index of the first element in the array that satisfies a provided testing function.
    // const numbers = [10, 20, 30, 40, 50];

    // const index = numbers.findIndex(num => num > 30);

    // console.log(index); // Output: 3
    // -------------------------------
    // -------------------------------
    // One practical real case where the findIndex() function in JavaScript is commonly used is for finding the index of a specific element in an array based on a condition.
    // For example, let's say you have an array of numbers representing test scores, and you want to find the index of the first score that exceeds a certain threshold.
// In this case, the findIndex() function is called on the scores array. It applies a condition to each score in the array, searching for the first score that satisfies the condition (in this case, a score greater than the threshold).
    
    // After executing the findIndex() function, the index variable will contain the index of the first score that meets the specified condition. In this example, the score of 95 has the index of 3.
    // The findIndex() function is particularly useful when you need to find the index of an element in an array based on a specific condition.
    
    // It allows you to easily locate the first occurrence of an element that meets the criteria without needing to manually iterate over the array or write custom search logic.
    
    // Other practical applications of findIndex() include searching for multiple occurrences of an element, implementing user-driven search functionality with index retrieval, finding the index of specific values in sorted arrays, or implementing data lookup and referencing in various real-world applications such as data manipulation, algorithms, or search algorithms.

    // Here's an example:
    
    // var scores = [85, 92, 78, 95, 88, 72, 90];
    // var threshold = 90;
    
    // var index = scores.findIndex(score => score > threshold);
    // In this case, the findIndex() function is called on the scores array. It applies a condition to each score in the array, searching for the first score that satisfies the condition (in this case, a score greater than the threshold).
    
    // After executing the findIndex() function, the index variable will contain the index of the first score that meets the specified condition. In this example, the score of 95 has the index of 3.
    

    // index = 3
    // The findIndex() function is particularly useful when you need to find the index of an element in an array based on a specific condition.
    
    // It allows you to easily locate the first occurrence of an element that meets the criteria without needing to manually iterate over the array or write custom search logic.
    
    // Other practical applications of findIndex() include searching for multiple occurrences of an element, implementing user-driven search functionality with index retrieval, finding the index of specific values in sorted arrays, or implementing data lookup and referencing in various real-world applications such as data manipulation, algorithms, or search algorithms.
// 37.forEach(): Executes a provided function once for each array element.
    // const colors = ['red', 'green', 'blue'];

    // colors.forEach(color => {
    //   console.log(color);
    // });

    // // Output:
    // // red
    // // green
    // // blue
    // -------------------------------
    // One practical real case where the forEach() function in JavaScript is commonly used is for iterating over elements in an array or a collection and performing a specific action for each element.// For example, let's say you have an array of numbers representing sales figures for each month, and you want to calculate the total sales for the year.
    // In this case, the forEach() function is called on the sales array. It iterates over each element in the array, and for each element, it performs the specified action (in this case, adding the sale value to the totalSales variable).
    
    // After executing the forEach() function, the totalSales variable will contain the sum of all the sales figures:
        // The forEach() function is particularly useful when you need to perform a specific operation on each element of an array or a collection without modifying the original array.
    
    // It allows you to easily iterate over the elements, access their values, and perform custom actions or calculations for each element.
    
    // Other practical applications of forEach() include data processing, performing calculations, updating UI elements based on data, logging or displaying information, or implementing custom algorithms or logic for each element in various real-world applications such as data analysis, data visualization, or working with user-generated data.
    // Here's an example:
    
    // var sales = [1000, 1500, 1200, 2000, 1800, 1600, 1900, 1700, 1300, 1100, 1400, 1800];
    
    // var totalSales = 0;
    
    // sales.forEach(function(sale) {
    //   totalSales += sale;
    // });
    // In this case, the forEach() function is called on the sales array. It iterates over each element in the array, and for each element, it performs the specified action (in this case, adding the sale value to the totalSales variable).
    
    // After executing the forEach() function, the totalSales variable will contain the sum of all the sales figures:
    
    // makefile
    // Copy code
    // totalSales = 19100
    // The forEach() function is particularly useful when you need to perform a specific operation on each element of an array or a collection without modifying the original array.
    
    // It allows you to easily iterate over the elements, access their values, and perform custom actions or calculations for each element.
    
    // Other practical applications of forEach() include data processing, performing calculations, updating UI elements based on data, logging or displaying information, or implementing custom algorithms or logic for each element in various real-world applications such as data analysis, data visualization, or working with user-generated data.
// 38.includes(): Checks if an array contains a specific element.
    // const numbers = [1, 2, 3, 4, 5];

    // const includesThree = numbers.includes(3);
    // console.log(includesThree); // Output: true

    // const includesTen = numbers.includes(10);
    // console.log(includesTen); // Output: false
        // -------------------------------

    // One practical real case where the includes() function in JavaScript is commonly used is for checking if an element exists in an array.// For example, let's say you have an array of usernames and you want to check if a specific username is present in the array.
     // In this case, the includes() function is called on the usernames array. It checks if the searchUsername exists in the array and returns a boolean value indicating the result.
    // After executing the includes() function, the exists variable will contain true if the searchUsername is found in the usernames array, or false if it's not found.
    // The includes() function is particularly useful when you need to quickly check if an array contains a specific element.
    
    // It allows you to easily determine the presence or absence of an element without needing to manually iterate over the array or write custom search logic.
    
    // Other practical applications of includes() include checking for the existence of specific values, validating user input or data, implementing conditional logic based on element presence, or filtering arrays based on specific criteria in various real-world applications such as form validation, user authentication, data filtering, or data deduplication.

    // Here's an example:
    
    // var usernames = ["John", "Jane", "Mike", "Emily", "Tom"];
    
    // var searchUsername = "Mike";
    
    // var exists = usernames.includes(searchUsername);
    // In this case, the includes() function is called on the usernames array. It checks if the searchUsername exists in the array and returns a boolean value indicating the result.
    // After executing the includes() function, the exists variable will contain true if the searchUsername is found in the usernames array, or false if it's not found.
    
    // exists = true
    // The includes() function is particularly useful when you need to quickly check if an array contains a specific element.
    
    // It allows you to easily determine the presence or absence of an element without needing to manually iterate over the array or write custom search logic.
    
    // Other practical applications of includes() include checking for the existence of specific values, validating user input or data, implementing conditional logic based on element presence, or filtering arrays based on specific criteria in various real-world applications such as form validation, user authentication, data filtering, or data deduplication.

// 39.indexOf(): Returns the first index at which a given element is found in the array.
    // const fruits = ['apple', 'banana', 'orange', 'banana'];

    // const indexOfOrange = fruits.indexOf('orange');
    // console.log(indexOfOrange); // Output: 2

    // const indexOfBanana = fruits.indexOf('banana');
    // console.log(indexOfBanana); // Output: 1

//40.join(): Joins all elements of an array into a string.
    // const fruits = ['apple', 'banana', 'orange'];

    // const joinedString = fruits.join(', ');
    // console.log(joinedString); // Output: "apple, banana, orange"

//41. keys(): Returns a new array iterator that contains the keys of the array.
    // const fruits = ['apple', 'banana', 'orange'];

    // const joinedString = fruits.join(', ');
    // console.log(joinedString); // Output: "apple, banana, orange"

//42.lastIndexOf(): Returns the last index at which a given element is found in the array.
    // const numbers = [1, 2, 3, 4, 3, 5];

    // const lastIndexThree = numbers.lastIndexOf(3);
    // console.log(lastIndexThree); // Output: 4

    // const lastIndexTen = numbers.lastIndexOf(10);
    // console.log(lastIndexTen); // Output: -1

// 43.map(): Creates a new array with the results of calling a provided function on each element.
    // const numbers = [1, 2, 3, 4, 5];

    // const squaredNumbers = numbers.map(num => num ** 2);
    // console.log(squaredNumbers); // Output: [1, 4, 9, 16, 25]

// 44.pop(): Removes the last element from the array and returns it.
    // const fruits = ['apple', 'banana', 'orange'];

    // const removedFruit = fruits.pop();
    // console.log(removedFruit); // Output: "orange"

    // console.log(fruits); // Output: ["apple", "banana"]

// 45.push(): Adds one or more elements to the end of the array and returns the new length.
    // const fruits = ['apple', 'banana'];

    // fruits.push('orange', 'kiwi');
    // console.log(fruits); // Output: ["apple", "banana", "orange", "kiwi"]

//46. reduce(): Applies a function to reduce the array to a single value.
    // const numbers = [1, 2, 3, 4, 5];

    // const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
    // console.log(sum); // Output: 15

//47. reduceRight(): Applies a function to reduce the array from right to left to a single value.
    // const numbers = [1, 2, 3, 4, 5];

    // const concatenatedString = numbers.reduceRight((accumulator, currentValue) => accumulator + currentValue.toString(), '');
    // console.log(concatenatedString); // Output: "54321"

// 48.reverse(): Reverses the order of the elements in the array.
    // const fruits = ['apple', 'banana', 'orange'];

    // fruits.reverse();
    // console.log(fruits); // Output: ["orange", "banana", "apple"]

// 49.shift(): Removes the first element from the array and returns it.
    // const colors = ['red', 'green', 'blue'];

    // const shiftedElement = colors.shift();
    // console.log(shiftedElement); // Output: "red"
    // console.log(colors); // Output: ["green", "blue"]

//50. slice(): Extracts a section of an array and returns a new array.
    // const numbers = [1, 2, 3, 4, 5];

    // const slicedNumbers = numbers.slice(1, 4);
    // console.log(slicedNumbers); // Output: [2, 3, 4]
    // console.log(numbers); // Output: [1, 2, 3, 4, 5]

// 51.some(): Checks if at least one element in the array satisfies a given condition.
    // const numbers = [1, 2, 3, 4, 5];

    // const hasEvenNumber = numbers.some((number) => number % 2 === 0);
    // console.log(hasEvenNumber); // Output: true


