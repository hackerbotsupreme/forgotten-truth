// async function* expression

// Syntax
async function* (param0, param1, /* …, */ paramN) {
    statements
}
async function* name(param0, param1, /* …, */ paramN) {
    statements
}
// Example
// Copy to Clipboard
const x = async function* (y) {
    yield Promise.resolve(y * y);
};
x(6)
    .next()
    .then((res) => console.log(res.value)); // 36


// async function expression
async function (param0, param1, /* …, */ paramN) {
    statements
}
async function name(param0, param1, /* …, */ paramN) {
    statements
}
// Example
function resolveAfter2Seconds(x) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(x);
        }, 2000);
    });
}

// async function expression assigned to a variable
const add = async function (x) {
    const a = await resolveAfter2Seconds(20);
    const b = await resolveAfter2Seconds(30);
    return x + a + b;
};

add(10).then((v) => {
    console.log(v); // prints 60 after 4 seconds.
});

// await
// The await operator is used to wait for 
// a Promise and get its fulfillment value. 
await expression
// expression
// A Promise to wait for.
// the await expression never blocks the main thread 

// Awaiting a promise to be fulfilled
function resolveAfter2Seconds(x) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(x);
        }, 2000);
    });
}

async function f1() {
    const x = await resolveAfter2Seconds(10);
    console.log(x); // 10
}

f1();
// Conversion to promise
// If the value is not a Promise, await converts the value to a resolved Promise, 
//and waits for it. The awaited value's identity doesn't change as long as 
//it doesn't have a then property that's callable.
async function f3() {
    const y = await 20;
    console.log(y); // 20

    const obj = {};
    console.log((await obj) === obj); // true
}

f3();
// Handling rejected promises
async function f4() {
    try {
        const z = await Promise.reject(30);
    } catch (e) {
        console.error(e); // 30
    }
}

f4();
// You can handle rejected promises without 
//a try block by chaining a catch() handler 
//before awaiting the promise.
const response = await promisedFunction().catch((err) => {
    console.error(err);
    return "default response";
});
// However, if promisedFunction() does throw 
//an error synchronously, the error won't be 
//caught by the catch() handler. In this case, 
//the try...catch statement is necessary.


// fetch request
const colors = fetch("../data/colors.json").then((response) => response.json());
export default await colors;

// a nice example 

// Control flow effects of await
// When an await is encountered in code (either in an async function or in a module), //the awaited expression is executed, while all code that depends 
// on the expression's value is paused and pushed into the microtask queue. 
// The main thread is then freed for the next task in the event loop. 
// This happens even if the awaited value is an already-resolved promise 
// or not a promise. For example, consider the following code:

// JS
// Copy to Clipboard
async function foo(name) {
    console.log(name, "start");
    console.log(name, "middle");
    console.log(name, "end");
}

foo("First");
foo("Second");

// First start
// First middle
// First end
// Second start
// Second middle
// Second end

// In this case, the two async functions are synchronous in effect, 
// because they don't contain any await expression. 
// The three statements happen in the same tick. In promise terms, 
// the function corresponds to:

// JS
// Copy to Clipboard
function foo(name) {
    return new Promise((resolve) => {
        console.log(name, "start");
        console.log(name, "middle");
        console.log(name, "end");
        resolve();
    });
}
// However, as soon as there's one await, 
// the function becomes asynchronous, and execution 
// of following statements is deferred to the next tick.

// JS
// Copy to Clipboard
async function foo(name) {
    console.log(name, "start");
    await console.log(name, "middle");
    console.log(name, "end");
}

foo("First");
foo("Second");

// First start
// First middle
// Second start
// Second middle
// First end
// Second end

// This corresponds to:
function foo(name) {
    return new Promise((resolve) => {
        console.log(name, "start");
        resolve(console.log(name, "middle"));
    }).then(() => {
        console.log(name, "end");
    });
}
// While the extra then() handler is not necessary, 
// and the handler can be merged with the executor passed to 
// the constructor, the then() handler's existence means 
// the code will take one extra tick to complete. 
// The same happens for await. Therefore, make sure 
// to use await only when necessary (to unwrap promises into their values).

// Other microtasks can execute before the async function resumes. 
// This example uses queueMicrotask() to demonstrate 
// how the microtask queue is processed when each await expression is encountered.

// JS
// Copy to Clipboard
let i = 0;

queueMicrotask(function test() {
    i++;
    console.log("microtask", i);
    if (i < 3) {
        queueMicrotask(test);
    }
});

(async () => {
    console.log("async function start");
    for (let i = 1; i < 3; i++) {
        await null;
        console.log("async function resume", i);
    }
    await null;
    console.log("async function end");
})();

queueMicrotask(() => {
    console.log("queueMicrotask() after calling async function");
});

console.log("script sync part end");

// Logs:
// async function start
// script sync part end
// microtask 1
// async function resume 1
// queueMicrotask() after calling async function
// microtask 2
// async function resume 2
// microtask 3
// async function end

// In this example, the test() function is always called before 
// the async function resumes, so the microtasks they each 
// schedule are always executed in an intertwined fashion. 
// On the other hand, because both await and queueMicrotask() schedule 
// microtasks, the order of execution is always based on the order 
// of scheduling. This is why the "queueMicrotask() after calling 
// async function" log happens after the async function resumes for the first time.

// Improving stack trace
// Sometimes, the await is omitted when a promise is directly 
// returned from an async function.

async function noAwait() {
    // Some actions...
    return /* await */ lastAsyncTask();
}
// However, consider the case where lastAsyncTask asynchronously throws an error.

async function lastAsyncTask() {
    await null;
    throw new Error("failed");
}
async function noAwait() {
    return lastAsyncTask();
}

noAwait();

// Error: failed
//    at lastAsyncTask

// Only lastAsyncTask appears in the stack trace, 
// because the promise is rejected after it has already 
// been returned from noAwait — in some sense, 
// the promise is unrelated to noAwait. To improve the stack trace, 
// you can use await to unwrap the promise, so that the exception 
// gets thrown into the current function. The exception will 
// then be immediately wrapped into a new rejected promise, 
// but during error creation, the caller will appear in the stack trace.

async function lastAsyncTask() {
    await null;
    throw new Error("failed");
}

async function withAwait() {
    return await lastAsyncTask();
}

withAwait();
// Error: failed
//    at lastAsyncTask
//    at async withAwait

// However, there's a little performance penalty coming 
// with return await because the promise has to 
// be unwrapped and wrapped again.



// The comma operator evaluates each of its operands from left to right 
// and returns the value of the last operand. It's often used in `for` loops 
// where you might want to perform more than one operation in 
// the loop's increment section.

// ```javascript
for (let i = 0, j = 10; i <= 10; i++, j--) {
    console.log(`i is ${i}, j is ${j}`);
}
// ```

// In this `for` loop, `i` is incremented and `j` is decremented 
// in each iteration. The comma operator allows us to do both 
// operations in the same loop.

// Another common use is when you want to perform multiple operations 
// in a single line and return the result of the last operation:

// ```javascript
let a, b;
a = (b = 3, b * 2); // a is now 6
// ```

// In this example, `b` is assigned the value `3`, then `b * 2` is 
// evaluated and its result `6` is assigned to `a`.

// Remember, the comma operator has the lowest precedence of all 
JavaScript operators, so if you want to use a comma expression 
within a larger expression, you should use parentheses.

const a = 1, b = 2;
In the line of code const a = 1, b = 2;, a and b are both constants.
a is assigned the value 1
b is assigned the value 2
This is a way to declare multiple constants in a single line in JavaScript.

const a = (1, b = 2);

// Examples
// Using the comma operator in a for loop
// If a is a 2-dimensional array with 10 elements on each side, the following code uses the comma operator to increment i and decrement j at once, thus printing the values of the diagonal elements in the array:

const a = Array.from({ length: 10 }, () =>
    Array.from({ length: 10 }, Math.random),
); // A 10×10 array of random numbers

for (let i = 0, j = 9; i <= 9; i++, j--) {
    console.log(`a[${i}][${j}] = ${a[i][j]}`);
}

// Copy to Clipboard
let a, b, c;

a = b = 3, c = 4; // Returns 4
console.log(a); // 3 (left-most)

let x, y, z;

x = (y = 5, z = 6); // Returns 6
console.log(x); // 6 (right-most)

// Processing and then returning
function myFunc() {
    let x = 0;
    return (x += 1, x); // the same as return ++x;
}

// This is especially useful for one-line arrow functions.
//  The following example uses a single map() to get both 
// the sum of an array and the squares of its elements, 
// which would otherwise require two iterations, 
// one with reduce() and one with map():
let sum = 0;
const squares = [1, 2, 3, 4, 5].map((x) => ((sum += x), x * x));
console.log(squares); // [1, 4, 9, 16, 25]
console.log(sum); // 15

// Decrement (--)
// The decrement (--) operator decrements (subtracts one from) 
// its operand and returns the value before or after the decrement, 
// depending on where the operator is placed.

// Syntax
x--
--x

let x = 3;
const y = x--;
console.log(`x:${x}, y:${y}`);
// Expected output: "x:2, y:3"
let a = 3;
const b = --a;
console.log(`a:${a}, b:${b}`);
// Expected output: "a:2, b:2"

// delete
//The delete operator removes a property 
// from an object.If the property's value 
// is an object and there are no more 
// references to the object.

const Employee = {
    firstname: 'Maria',
    lastname: 'Sanchez',
};
console.log(Employee.firstname);
// Expected output: "Maria"
delete Employee.firstname;
console.log(Employee.firstname);
// Expected output: undefined

delete object.property
delete object[property]
delete identifier;
delete object.#privateProperty;
// Because classes are automatically in strict mode, and private 
//properties can only be legally referenced in class bodies, 
//this means private properties can never be deleted.

// Creates the property empCount on the global scope.
// Since we are using var, this is marked as non-configurable.
var empCount = 43;

// Creates the property EmployeeDetails on the global scope.
// Since it was defined without "var", it is marked configurable.
EmployeeDetails = {
    name: "xyz",
    age: 5,
    designation: "Developer",
};

// delete can be used to remove properties from objects.
delete EmployeeDetails.name; // returns true

// Even when the property does not exist, delete returns "true".
delete EmployeeDetails.salary; // returns true

// EmployeeDetails is a property of the global scope.
delete EmployeeDetails; // returns true

// On the contrary, empCount is not configurable
// since var was used.
delete empCount; // returns false

// delete also does not affect built-in static properties
// that are non-configurable.
delete Math.PI; // returns false

function f() {
    var z = 44;
    // delete doesn't affect local variable names
    delete z; // returns false
}

// delete and the prototype chain
// In the following example, we delete an own property of an object while a property with the same name is available on the prototype chain:

function Foo() {
    this.bar = 10;
}

Foo.prototype.bar = 42;

const foo = new Foo();

// foo.bar is associated with the
// own property.
console.log(foo.bar); // 10
// Delete the own property within the
// foo object.
delete foo.bar; // returns true
// foo.bar is still available in the
// prototype chain.
console.log(foo.bar); // 42
// Delete the property on the prototype.
delete Foo.prototype.bar; // returns true
// The "bar" property can no longer be
// inherited from Foo since it has been
// deleted.
console.log(foo.bar); // undefined

// Deleting array elements
// When you delete an array element, the array length is not affected.
// This holds even if you delete the last element of the array.
// When the delete operator removes an array element, 
// that element is no longer in the array.
// In the following example, trees[3] is removed with delete.
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
delete trees[3];
console.log(3 in trees); // false
// This creates a sparse array with an empty slot.If you want an array element to exist but have an undefined value, use the undefined value instead of the delete operator.In the following example, trees[3] is assigned the value undefined, but the array element still exists:

const trees = ["redwood", "bay", "cedar", "oak", "maple"];
trees[3] = undefined;
console.log(3 in trees); // true
// If instead, you want to remove an array element by changing the contents of the array, use the splice() method.In the following example, trees[3] is removed from the array completely using splice():

const trees = ["redwood", "bay", "cedar", "oak", "maple"];
trees.splice(3, 1);
console.log(trees); // ["redwood", "bay", "cedar", "maple"]

// Deleting non - configurable properties
// When a property is marked as non - configurable, 
// delete won't have any effect, and will return false. 
const Employee = {};
Object.defineProperty(Employee, "name", { configurable: false });
console.log(delete Employee.name); // returns false
// var creates non-configurable properties that cannot be deleted with the delete operator:
// Since "nameOther" is added using with the
// var keyword, it is marked as non-configurable
var nameOther = "XYZ";

// We can access this global property using:
Object.getOwnPropertyDescriptor(globalThis, "nameOther");
// {
//   value: "XYZ",
//   writable: true,
//   enumerable: true,
//   configurable: false
// }
delete globalThis.nameOther; // return false
// In strict mode, this would raise an exception.

// Deleting global properties
// If a global property is configurable, it can be deleted, and subsequent references to them as global variables will produce a ReferenceError.
globalThis.globalVar = 1;
console.log(globalVar); // 1
// In non-strict mode, you can use `delete globalVar` as well
delete globalThis.globalVar;
console.log(globalVar); // ReferenceError: globalVar is not defined


// Destructuring assignment
// The destructuring assignment syntax is a JavaScript expression that
// makes it possible to unpack values from arrays, or properties
// from objects, into distinct variables.

let a, b, rest;
[a, b] = [10, 20];
console.log(a);
// Expected output: 10
console.log(b);
// Expected output: 20
[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(rest);
// Expected output: Array [30, 40, 50]

const x = [1, 2, 3, 4, 5];
const [y, z] = x;
console.log(y); // 1
console.log(z); // 2

// Similarly, you can destructure objects on the left - hand side of the assignment.
const obj = { a: 1, b: 2 };
const { a, b } = obj;
// is equivalent to:
// const a = obj.a;
// const b = obj.b;

// Binding and assignment
// For both object and array destructuring, 
// there are two kinds of destructuring patterns: 
// binding pattern and assignment pattern, with slightly different syntaxes.

// In binding patterns, the pattern starts with a declaration keyword
// (var, let, or const).Then, each individual property must either 
// be bound to a variable or further destructured.

const obj = { a: 1, b: { c: 2 } };
const {
    a,
    b: { c: d },
} = obj;
// Two variables are bound: `a` and `d`
// All variables share the same declaration, so if you want some variables to be re - assignable 
//but others to be read - only, you may have to destructure twice — once with let, once with const.
const obj = { a: 1, b: { c: 2 } };
const { a } = obj; // a is constant
let {
    b: { c: d },
} = obj; // d is re-assignable
// In many other syntaxes where the language binds a variable for you, you can use a binding destructuring pattern.These include:
// The looping variable of for...in for...of, and for await...of loops;
// Function parameters;
// The catch binding variable.
// In assignment patterns, the pattern does not start with a keyword.
// Each destructured property is assigned to a target of assignment — which may either 
//be declared beforehand with var or let, or is a property of another object — in general, 
//anything that can appear on the left - hand side of an assignment expression.

const numbers = [];
const obj = { a: 1, b: 2 };
({ a: numbers[0], b: numbers[1] } = obj);
// Note: The parentheses(... ) around the assignment statement are required when using object literal destructuring assignment without a declaration.

//     { a, b } = { a: 1, b: 2 } is not valid stand-alone syntax,
//  as the { a, b } on the left - hand side is considered a block
//  and not an object literal according to the rules of expression 
// statements.However, ({ a, b } = { a: 1, b: 2 }) is valid, as 
// is const { a, b } = { a: 1, b: 2 }.

const numbers = [];
const obj = { a: 1, b: 2 };
const { a: numbers[0], b: numbers[1] } = obj;
// This is equivalent to:
//   const numbers[0] = obj.a;
//   const numbers[1] = obj.b;
// Which definitely is not valid.
// You can only use assignment patterns as the left - hand side
//  of the assignment operator.You cannot use them with 
// compound assignment operators such as += or *=.

// Default value
// Each destructured property can have a default value.The default value is used when 
//the property is not present, or has value undefined.It is not used if the property has value null.
const [a = 1] = []; // a is 1
const { b = 2 } = { b: undefined }; // b is 2
const { c = 2 } = { c: null }; // c is null

const { a, ...others } = { a: 1, b: 2, c: 3 };
console.log(others); // { b: 2, c: 3 }
const [first, ...others2] = [1, 2, 3];
console.log(others2); // [2, 3]

const foo = ["one", "two", "three"];
const [red, yellow, green] = foo;
console.log(red); // "one"
console.log(yellow); // "two"
console.log(green); // "three"

const foo = ["one", "two"];
const [red, yellow, green, blue] = foo;
console.log(red); // "one"
console.log(yellow); // "two"
console.log(green); // undefined
console.log(blue); // undefined

// Swapping variables
// Two variables values can be swapped 
// in one destructuring expression.
let a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1

const arr = [1, 2, 3];
[arr[2], arr[1]] = [arr[1], arr[2]];
console.log(arr); // [1, 3, 2]

// Parsing an array returned from a function
//It's always been possible to return an array from a function. 
// Destructuring can make working with an array 
// return value more concise.

function f() {
    return [1, 2];
}

const [a, b] = f();
console.log(a); // 1
console.log(b); // 2

// Ignoring some returned values
// You can ignore return values that you're not interested in:

function f() {
    return [1, 2, 3];
}

const [a, , b] = f();
console.log(a); // 1
console.log(b); // 3

const [c] = f();
console.log(c); // 1

// Using a binding pattern as the rest property
// The rest property of array destructuring assignment can be 
// another array or object binding pattern.The inner destructuring 
// destructures from the array created after collecting the rest elements, 
// so you cannot access any properties present on 
// the original iterable in this way.

const [a, b, ...{ length }] = [1, 2, 3];
console.log(a, b, length); // 1 2 1

const [a, b, ...[c, d]] = [1, 2, 3, 4];
console.log(a, b, c, d); // 1 2 3 4
// These binding patterns can even be nested, as long as each rest property is the last in the list.

// Copy to Clipboard
const { a, ...{ b } } = { a: 1, b: 2 };
// SyntaxError: `...` must be followed by an identifier in declaration contexts
let a, b;
({ a, ...{ b } } = { a: 1, b: 2 });
// SyntaxError: `...` must be followed by an assignable reference in assignment contexts

// Using array destructuring on any iterable
// Array destructuring calls the iterable protocol of 
// the right - hand side.Therefore, any iterable, 
// not necessarily arrays, can be destructured.

const [a, b] = new Map([
    [1, 2],
    [3, 4],
]);
console.log(a, b); // [1, 2] [3, 4]

// Non - iterables cannot be destructured as arrays.
const obj = { 0: "a", 1: "b", length: 2 };
const [a, b] = obj;
// TypeError: obj is not iterable
// Iterables are only iterated until all bindings are assigned.

// Object destructuring
// Basic assignment
const user = {
    id: 42,
    isVerified: true,
};

const { id, isVerified } = user;

console.log(id); // 42
console.log(isVerified); // true
// Assigning to new variable names
// A property can be unpacked from an object and assigned to a variable with a different name than the object property.
const o = { p: 42, q: true };
const { p: foo, q: bar } = o;

console.log(foo); // 42
console.log(bar); // true

//Assigning to new variable names and providing default values
// A property can be both
// Unpacked from an object and assigned to a variable with a different name.
// Assigned a default value in case the unpacked value is undefined.
const { a: aa = 10, b: bb = 5 } = { a: 3 };

console.log(aa); // 3
console.log(bb); // 5

// function expression
// The function keyword can be used to define a function inside an expression.

// Syntax
function (param0, param1, /* …, */ paramN) {
    statements
}
function name(param0, param1, /* …, */ paramN) {
    statements
}

// A function expression is very similar to, and has almost the same syntax as, a function declaration. 
//The main difference between a function expression and a function declaration is the function name,

// Unlike declarations, the name of the function expressions is read - only.
function foo() {
    foo = 1;
}
foo();
console.log(foo); // 1
(function foo() {
    foo = 1; // TypeError: Assignment to constant variable.
})();

// The following example defines an unnamed function and assigns it to x.
// The function returns the square of its argument:
const x = function (y) {
    return y * y;
};
// Using an Immediately Invoked Function Expression(IIFE)
// An anonymous function is created and called:
(function () {
    console.log("Code runs!");
})();
// or
!function () {
    console.log("Code runs!");
}();

// function* expression
// The function* keyword can be used to define a generator function inside an expression.
const foo = function* () {
    yield 'a';
    yield 'b';
    yield 'c';
};
let str = '';
for (const val of foo()) {
    str = str + val;
}
console.log(str);
// Expected output: "abc"

//The main difference between a function* expression and a function* 
//declaration is the function name, which can be omitted in function* 
//expressions to create anonymous functions.

// The following example defines an unnamed generator function and assigns it to x.
// The function yields the square of its argument:
const x = function* (y) {
    yield y * y;
};

// Grouping operator ( )
// The grouping ( ) operator controls the precedence of evaluation in expressions. It also acts as a container for arbitrary expressions in certain syntactic constructs, where ambiguity or syntax errors would otherwise occur.

console.log(1 + 2 * 3); // 1 + 6
// Expected output: 7

console.log(1 + 2 * 3); // 1 + 6
// Expected output: 7

console.log((1 + 2) * 3); // 3 * 3
// Expected output: 9

console.log(1 * 3 + 2 * 3); // 3 + 6
// Expected output: 9

// The grouping operator consists of a pair of parentheses around an expression that groups the contents. The operator overrides the normal operator precedence, so that operators with lower precedence (as low as the comma operator) can be evaluated before an operator with higher precedence.

// Using the grouping operator
// Evaluating addition and subtraction before multiplication and division.
const a = 1;
const b = 2;
const c = 3;
// default precedence
a + b * c; // 7
// evaluated by default like this
a + (b * c); // 7
// now overriding precedence
// addition before multiplication
(a + b) * c; // 9
// which is equivalent to
a * c + b * c; // 9

// Using the grouping operator to eliminate parsing ambiguity
// An expression statement cannot start with the keyword function, because the parser would see it as the start of a function declaration. This means the following IIFE syntax is invalid:
function () {
  // code
}();
// The grouping operator can be used to eliminate this ambiguity, since when the parser sees the left parenthesis, it knows that what follows must be an expression instead of a declaration.
(function () {
  // code
})();

// In an arrow function expression body (one that directly returns an expression without the keyword return), the grouping operator can be used to return an object literal expression, because otherwise the left curly brace would be interpreted as the start of the function body.
const f = () => ({ a: 1 });
// If a property is accessed on a number literal, the property accessor dot . may be ambiguous with a decimal point, unless the number already has a decimal point. You can wrap integer literals in parentheses to eliminate this ambiguity.
(1).toString(); // "1"

// Grouping operator and automatic semicolon insertion
// The grouping operator can mitigate automatic semicolon insertion (ASI) pitfalls. For example, the return keyword and the returned expression cannot have a line break in between:
function sum(a, b) {
  return
    a + b;
}
// This code will return undefined, because a semicolon is inserted directly after the return keyword, which causes the function to return immediately without evaluating a + b. In case the returned expression is long and you want to keep it well-formatted, you may use the grouping operator to signify that the return keyword is followed by an expression and prevent semicolon insertion:
function sum(a, b) {
  return (
    a + b
  );
}

// in
// The in operator returns true if the specified property is in 
//the specified object or its prototype chain.

const car = { make: 'Honda', model: 'Accord', year: 1998 };
console.log('make' in car);
// Expected output: true
delete car.make;
if ('make' in car === false) {
    car.make = 'Suzuki';
}
console.log(car.make);
// Expected output: "Suzuki"

// Syntax
prop in object
#prop in object
// prop
// A string or symbol representing a property name
// (non - symbols will be coerced to strings).
// Can also be a private property identifier.

//     Description
// The in operator tests if a string or symbol property is present in an object 
//or its prototype chain.If you want to check for only non - inherited properties, 
//use Object.hasOwn() instead.

// An object in JavaScript can have a property with a value of undefined.
//  So, checking if a property exists in an object using x in obj is not 
// the same as checking if the value of that property is not undefined 
// using obj.x !== undefined. The in operator checks for the existence 
// of the property, not its value. If you want to remove a property 
// from an object entirely, you should use the delete operator.

// The in operator can also be used to check if a private field or method 
// is defined in an object. This is called a “branded check”. It will return 
// true only if the object was created with the class constructor that
//  defines the private field or method. After this check, 
// you can safely access other private properties.

// When using the in operator, the left-hand side should be the identifier 
// of the property you’re checking for, not an expression. And it should be 
// unquoted, because if it’s quoted, it’s treated as a string property, 
// not a private property.

// The following examples show some uses of the in operator.
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)
Symbol.iterator in trees; // returns true


const trees = ["redwood", "bay", "cedar", "oak", "maple"];
trees[3] = undefined;
3 in trees; // returns true
// The in operator will return false for empty array slots, 
// even if accessing it directly returns undefined.

const empties = new Array(3);
empties[2]; // returns undefined
2 in empties; // returns false
// To avoid this, make sure a new array is always filled with non - empty 
// values or not write to indexes past the end of array.

const empties = new Array(3).fill(undefined);
2 in empties; // returns true

// Inherited properties
// The in operator returns true for properties in the prototype chain.This may be undesirable if you are using objects to store arbitrary key-value pairs.
const ages = { alice: 18, bob: 27 };
function hasPerson(name) {
    return name in ages;
}
hasPerson("hasOwnProperty"); // true
// You can use Object.hasOwn() to check if the object has the key.

const ages = { alice: 18, bob: 27 };
function hasPerson(name) {
    return Object.hasOwn(ages, name);
}
hasPerson("hasOwnProperty"); // false

// Using the in operator to implement branded checks
// The code fragment below demonstrates a static function that tells if 
// an object was created with the Person constructor and therefore 
// can perform other methods safely.
class Person {
    #age;
    constructor(age) {
        this.#age = age;
    }
    static isPerson(o) {
        return #age in o;
    }
    ageDifference(other) {
        return this.#age - other.#age;
    }
}

const p1 = new Person(20);
const p2 = new Person(30);
console.log(p1.ageDifference(p2)); // -10
console.log(Person.isPerson(p1)); // true

if (Person.isPerson(p1) && Person.isPerson(p2)) {
    console.log(p1.ageDifference(p2)); // -10
}

// Inequality (!=)
// The inequality (!=) operator checks whether its two operands 
// are not equal, returning a Boolean result. Unlike the strict 
// inequality operator, it attempts to convert and compare operands 
// that are of different types.

console.log(1 != 1);
// Expected output: false
console.log('hello' != 'hello');
// Expected output: false
console.log('1' != 1);
// Expected output: false
console.log(0 != false);
// Expected output: false

// syntax
x != y
!(x == y);

3 != "3"; // false
3 !== "3"; // true
"hello" != "hola"; // true
1 != 1; // false
"hello" != "hello"; // false

const number1 = new Number(3);
const number2 = new Number(3);
number1 != 3; // false
number1 != number2; // true

const object1 = {
    key: "value",
};
const object2 = {
    key: "value",
};
console.log(object1 != object2); // true
console.log(object1 != object1); // false

// instanceof
//The instanceof operator tests to see if the prototype property of 
// a constructor appears anywhere in the prototype chain of an object.
// The return value is a boolean value.Its behavior can 
// be customized with Symbol.hasInstance.

function Car(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
}
const auto = new Car('Honda', 'Accord', 1998);
console.log(auto instanceof Car);
// Expected output: true
console.log(auto instanceof Object);
// Expected output: true

// Syntax
object instanceof constructor

function C() { }
function D() { }
const o = new C();
// true, because: Object.getPrototypeOf(o) === C.prototype
o instanceof C;
// false, because D.prototype is nowhere in o's prototype chain
o instanceof D;
o instanceof Object; // true, because:
C.prototype instanceof Object; // true
// Re-assign `constructor.prototype`: you should
// rarely do this in practice.
C.prototype = {};
const o2 = new C();
o2 instanceof C; // true
// false, because C.prototype is nowhere in
// o's prototype chain anymore
o instanceof C;
D.prototype = new C(); // add C to [[Prototype]] linkage of D
const o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true since C.prototype is now in o3's prototype chain

// because classes also have the prototype property.

class A { }
class B extends A { }
const o1 = new A();
// true, because Object.getPrototypeOf(o1) === A.prototype
o1 instanceof A;
// false, because B.prototype is nowhere in o1's prototype chain
o1 instanceof B;
const o2 = new B();
// true, because Object.getPrototypeOf(Object.getPrototypeOf(o2)) === A.prototype
o2 instanceof A;
// true, because Object.getPrototypeOf(o2) === B.prototype
o2 instanceof B;
// For bound functions, instanceof looks up for the prototype property on the target function, since bound functions don't have prototype.

class Base { }
const BoundBase = Base.bind(null, 1, 2);
console.log(new Base() instanceof BoundBase); // true

// instanceof and @@hasInstance
// If constructor has a Symbol.hasInstance method, the method will 
// be called in priority, with object as its only argument 
// and constructor as this.

// This class allows plain objects to be disguised as this class's instance,
// as long as the object has a particular flag as its property.
class Forgeable {
    static isInstanceFlag = Symbol("isInstanceFlag");
    static [Symbol.hasInstance](obj) {
        return Forgeable.isInstanceFlag in obj;
    }
}
const obj = { [Forgeable.isInstanceFlag]: true };
console.log(obj instanceof Forgeable); // true
// Because all functions inherit from Function.prototype by default, most of the time,
// the Function.prototype[@@hasInstance] method specifies the behavior of instanceof when 
//the right - hand side is a function. See the Symbol.hasInstance page for the exact algorithm of instanceof.

// Using instanceof with String
const literalString = "This is a literal string";
const stringObject = new String("String created with constructor");

literalString instanceof String; // false, string primitive is not a String
stringObject instanceof String; // true

literalString instanceof Object; // false, string primitive is not an Object
stringObject instanceof Object; // true

stringObject instanceof Date; // false
// Using instanceof with Date
const myDate = new Date();

myDate instanceof Date; // true
myDate instanceof Object; // true

// Objects created using Object.create()
// The following example shows the behavior of instanceof 
// with objects created using Object.create().
function Shape() { }

function Rectangle() {
    Shape.call(this); // call super constructor.
}

Rectangle.prototype = Object.create(Shape.prototype);

Rectangle.prototype.constructor = Rectangle;

const rect = new Rectangle();

rect instanceof Object; // true
rect instanceof Shape; // true
rect instanceof Rectangle; // true
rect instanceof String; // false

const literalObject = {};
const nullObject = Object.create(null);
nullObject.name = "My object";

literalObject instanceof Object; // true, every object literal has Object.prototype 
// as prototype
({}) instanceof Object; // true, same case as above
nullObject instanceof Object; // false, prototype is end of prototype chain (null)

//To test if an object is not an instanceof a specific constructor, you can do:
if (!(mycar instanceof Car)) {
    // Do something, like:
    // mycar = new Car(mycar)
}
// This is really different from:
if (!mycar instanceof Car) {
    // unreachable code
}
// This will always be false. (!mycar will be evaluated before instanceof, so you always try to know if a boolean is an instance of Car).


// Overriding the behavior of instanceof
//A common pitfall of using instanceof is believing that, if x instanceof C, 
// then x was created using C as constructor.This is not true, because x could 
// be directly assigned with C.prototype as its prototype.In this case, 
// if your code reads private fields of C from x, it would still fail:
class C {
    #value = "foo";
    static getValue(x) {
        return x.#value;
    }
}

const x = { __proto__: C.prototype };
if (x instanceof C) {
    console.log(C.getValue(x)); // TypeError: Cannot read private member #value from an object whose class did not declare it
}
// To avoid this, you can override the behavior of instanceof by adding 
// a Symbol.hasInstance method to C, so that it does a branded check with in:

class C {
    #value = "foo";

    static [Symbol.hasInstance](x) {
        return #value in x;
    }

    static getValue(x) {
        return x.#value;
    }
}

const x = { __proto__: C.prototype };

if (x instanceof C) {
    // Doesn't run, because x is not a C
    console.log(C.getValue(x));
}
// Note that you may want to limit this behavior to the current class; otherwise, it could lead to false positives for subclasses:

class D extends C { }
console.log(new C() instanceof D); // true; because D inherits @@hasInstance from C
// You could do this by checking that this is the current constructor:
class C {
    #value = "foo";

    static [Symbol.hasInstance](x) {
        return this === C && #value in x;
    }
}

class D extends C { }
console.log(new C() instanceof D); // false
console.log(new C() instanceof C); // true
console.log({ __proto__: C.prototype } instanceof C); // false

// Logical AND(&&)
// The logical AND(&&)(logical conjunction) operator for 
// a set of boolean operands will be true if and only 
// if all the operands are true.Otherwise it will be false.

// Syntax
x && y

// Logical AND(&&) evaluates operands from left to right, returning immediately 
// with the value of the first falsy operand it encounters; if all values 
// are truthy, the value of the last operand is returned.
// If a value can be converted to true, the value is so - called truthy
// .If a value can be converted to false, the value is so - called falsy.

// expressions that can be converted to false are:
false;
null;
NaN;
0;
empty string("" or '' or``);
undefined.

result = "" && "foo"; // result is assigned "" (empty string)
result = 2 && 0; // result is assigned 0
result = "foo" && 4; // result is assigned 4

// The logical AND expression is a short - circuit operator.As each operand 
// is converted to a boolean, if the result of one conversion is found to be 
// false, the AND operator stops and returns the original value of that falsy operand;

// Operator precedence
// The AND operator has a higher precedence than the OR operator, meaning the && operator 
//is executed before the || operator(see operator precedence).

true || false && false; // true
true && (false || false); // false
(2 === 3) || (4 < 0) && (1 === 1); // false

a1 = true && true; // t && t returns true
a2 = true && false; // t && f returns false
a3 = false && true; // f && t returns false
a4 = false && 3 === 4; // f && f returns false
a5 = "Cat" && "Dog"; // t && t returns "Dog"
a6 = false && "Cat"; // f && t returns false
a7 = "Cat" && false; // t && f returns false
a8 = "" && false; // f && f returns ""
a9 = false && ""; // f && f returns false

bCondition1 && bCondition2
// is always equal to:
!(!bCondition1 || !bCondition2)

bCondition1 || bCondition2
// is always equal to:
!(!bCondition1 && !bCondition2)

// Removing nested parentheses
// As logical expressions are evaluated left to right, 
// it is always possible to remove parentheses from a complex 
// expression provided that certain rules are followed.

// The following composite operation involving booleans:
bCondition1 || (bCondition2 && bCondition3)
// is always equal to:
bCondition1 || bCondition2 && bCondition3

// Logical AND assignment(&&=)
// The logical AND assignment(&&=) operator only 
// evaluates the right operand and assigns to the left 
// if the left operand is truthy.

let a = 1;
let b = 0;
a &&= 2;
console.log(a);
// Expected output: 2
b &&= 2;
console.log(b);
// Expected output: 0

// Logical AND assignment short - circuits, meaning that x &&= y is 
// equivalent to x && (x = y), except that the expression x is only evaluated once.
// No assignment is performed if the left - hand side is not truthy,
//  due to short - circuiting of the logical AND operator.

// Logical NOT(!)
// The logical NOT(!)(logical complement, negation) 
// operator takes truth to falsity and vice versa.It 
// is typically used with boolean(logical) values.
// When used with non - Boolean values, it returns 
// false if its single operand can be converted to 
// true; otherwise, returns true.

const a = 3;
const b = -2;
console.log(!(a > 0 || b > 0));
// Expected output: false

!x

// Returns false if its single operand can be converted 
// to true; otherwise, returns true.
// If a value can be converted to true, the value is 
// so - called truthy.If a value can be converted to false, 
// the value is so - called falsy.

//  expressions that can be converted to false are:
null;
NaN;
0;
empty string("" or '' or``);
undefined.

// Using NOT
!true; // !t returns false
!false; // !f returns true
!""; // !f returns true
!"Cat"; // !t returns false

!!true; // !!truthy returns true
!!{}; // !!truthy returns true: any object is truthy...
!!new Boolean(false); // ...even Boolean objects with a false .valueOf()!
!!false; // !!falsy returns false
!!""; // !!falsy returns false
!!Boolean(false); // !!falsy returns false

// Logical OR(||)
// The logical OR(||)(logical disjunction) operator for 
// a set of operands is true if and only if one or more 
// of its operands is true.It is typically used with 
// boolean(logical) values.When it is, it returns a Boolean value.
// However, the || operator actually returns the value of
//  one of the specified operands, so if this operator is used 
// with non - Boolean values, it will return a non - Boolean value.

const a = 3;
const b = -2;
console.log(a > 0 || b > 0);
// Expected output: true

// Syntax
x || y

// If x can be converted to true, returns x; else, returns y.
// If a value can be converted to true, the value is so - called 
// truthy.If a value can be converted to false, the value 
// is so - called falsy.

//     Short - circuit evaluation
// The logical OR expression is evaluated left to right, 
// it is tested for possible "short-circuit" evaluation using the following rule:
//     (some truthy expression) || expr is short - circuit evaluated 
// to the truthy expression.

// Short circuit means that the expr part above is not evaluated, 
// hence any side effects of doing so do not take effect(e.g., 
// if expr is a function call, the calling never takes place). 
// This happens because the value of the operator is already 
// determined after the evaluation of the first operand.

// Operator precedence
// The following expressions might seem equivalent, but they are not, 
// because the && operator is executed before 
// the || operator(see operator precedence).

true || false && false; // returns true, because && is executed first
(true || false) && false; // returns false, because grouping has the highest precedence

//  expressions that can be converted to false are:
null;
NaN;
0;
empty string("" or '' or``);
undefined.

true || true; // t || t returns true
false || true; // f || t returns true
true || false; // t || f returns true
false || 3 === 4; // f || f returns false
"Cat" || "Dog"; // t || t returns "Cat"
false || "Cat"; // f || t returns "Cat"
"Cat" || false; // t || f returns "Cat"
"" || false; // f || f returns false
false || ""; // f || f returns ""
false || varObject; // f || object returns varObject
// Note: If you use this operator to provide a default value 
// to some variable, be aware that any falsy value will not be 
// used.If you only need to filter out null or undefined, 
// consider using the nullish coalescing operator.

!(!bCondition1 || !bCondition2)
bCondition1 || bCondition2

// Removing nested parentheses
// As logical expressions are evaluated left to right, it is always 
// possible to remove parentheses from a complex expression 
// following some rules.

// The following composite operation involving booleans:
bCondition1 && (bCondition2 || bCondition3)
// is always equal to:
!(!bCondition1 || !bCondition2 && !bCondition3)

// Logical OR assignment(||=)
// The logical OR assignment(||=) operator only evaluates 
// the right operand and assigns to the left if 
// the left operand is falsy.

// new
//The new operator lets developers create 
// an instance of a user - defined object 
// type or of one of the built -in object 
// types that has a constructor function.

function Car(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
}
const car1 = new Car('Eagle', 'Talon TSi', 1993);
console.log(car1.make);
// Expected output: "Eagle"

// Syntax
new constructor
new constructor()
new constructor(arg1)
new constructor(arg1, arg2)
new constructor(arg1, arg2, /* …, */ argN)

// When a function is called with the new keyword, 
// the function will be used as a constructor.new 
// will do the following things:

// Creates a blank, plain JavaScript object.
// Points newInstance's [[Prototype]] to the constructor function's prototype
//  property, if the prototype is an Object.Otherwise, newInstance stays as 
// a plain object with Object.prototype as its[[Prototype]].
//Note: Properties / objects added to the constructor function's prototype 
// property are therefore accessible to all instances created from 
// the constructor function.

// Executes the constructor function with the given arguments, 
// binding newInstance as the this context(i.e.all references 
// to this in the constructor function now refer to newInstance).

// If the constructor function returns a non - primitive, this return 
// value becomes the result of the whole new expression.Otherwise, if 
// the constructor function doesn't return anything or returns a primitive, 
// newInstance is returned instead. (Normally constructors don't return 
// a value, but they can choose to do so to override the normal 
// object creation process.)

// Classes can only be instantiated with the new operator — attempting 
// to call a class without new will throw a TypeError.

// Creating an object with a user - defined constructor function requires two steps:

// Define the object type by writing a function that 
// specifies its name and properties.

// Define the object type by writing a function that 
// specifies its name and properties.
function Foo(bar1, bar2) {
    this.bar1 = bar1;
    this.bar2 = bar2;
}
// Create an instance of the object with new.
const myFoo = new Foo("Bar 1", 2021);

function Car() { }
const car1 = new Car();
const car2 = new Car();

console.log(car1.color); // undefined

Car.prototype.color = "original color";
console.log(car1.color); // 'original color'

car1.color = "black";
console.log(car1.color); // 'black'

console.log(Object.getPrototypeOf(car1).color); // 'original color'
console.log(Object.getPrototypeOf(car2).color); // 'original color'
console.log(car1.color); // 'black'
console.log(car2.color); // 'original color'
// Note: While the constructor function can be invoked like 
// any regular function (i.e.without the new operator), 
// in this case a new object is not created and the value of this is also different.

// A function can know whether it is invoked with new by checking 
// new.target.new.target is only undefined when the function 
// is invoked without new.For example, you can have 
// a function that behaves differently when it's called versus 
// when it's constructed:

function Car(color) {
    if (!new.target) {
        // Called as function.
        return `${color} car`;
    }
    // Called with new.
    this.color = color;
}
const a = Car("red"); // a is "red car"
const b = new Car("red"); // b is `Car { color: "red" }`

// Prior to ES6, which introduced classes, most JavaScript built - ins are both callable and constructible, although many of them exhibit different behaviors.To name a few:

// Array(), Error(), and Function() behave the same when called as a function or a constructor.
// Boolean(), Number(), and String() coerce their argument to the respective primitive type when called, and return wrapper objects when constructed.
//Date() returns a string representing the current date when called, equivalent to new Date().toString().
// After ES6, the language is stricter about which are 
// constructors and which are functions.For example:

// Symbol() and BigInt() can only be called without new.
// Attempting to construct them will throw a TypeError.
// Proxy and Map can only be constructed with new.Attempting to call them will throw a TypeError.
//     Examples
// Object type and object instance
// Suppose you want to create an object type for cars.
// You want this type of object to be called Car, and 
// you want it to have properties for make, model, 
// and year.To do this, you would write the following function:

const kensCar = new Car("Nissan", "300ZX", 1992);
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}
const rand = new Person("Rand McNally", 33, "M");
const ken = new Person("Ken Jones", 39, "M");

function Car(make, model, year, owner) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.owner = owner;
}
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
car2.owner.name;
// Using new with classes
// JS
// Copy to Clipboard
class Person {
    constructor(name) {
        this.name = name;
    }
    greet() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

const p = new Person("Caroline");
p.greet(); // Hello, my name is Caroline

// new.target
// The new.target meta - property lets you detect whether 
// a function or constructor was called using the new operator.
// In constructors and functions invoked using the new operator, 
// new.target returns a reference to the constructor or function 
// that new was called upon.In normal function calls, 
// new.target is undefined.

function Foo() {
    if (!new.target) {
        throw new TypeError('calling Foo constructor without new is invalid');
    }
}
try {
    Foo();
} catch (e) {
    console.log(e);
    // Expected output: TypeError: calling Foo constructor without new is invalid
}
new.target
// Value
// new.target is guaranteed to be a constructable function value or undefined.

// In class constructors, it refers to the class that new was called upon, 
// which may be a subclass of the current constructor, because subclasses 
// transitively call the superclass's constructor through super().

// In ordinary functions, if the function is constructed directly with new, 
// new.target refers to the function itself. If the function is called without new, 
// new.target is undefined.Functions can be used as the base class for extends, 
// in which case new.target may refer to the subclass.

// If a constructor(class or function) is called via Reflect.construct(), then 
// new.target refers to the value passed as newTarget (which defaults to target).
// In arrow functions, new.target is inherited from the surrounding scope.If 
// the arrow function is not defined within another class or function which 
// has a new.target binding, then a syntax error is thrown.
// In static initialization blocks, new.target is undefined.

// The new.target syntax consists of the keyword new, a dot, and 
// the identifier target.Because new is a reserved word, not an identifier, 
// this is not a property accessor, but a special expression syntax.

// The new.target meta - property is available in all function/class bodies; 
// using new.target outside of functions or classes is a syntax error.

// new.target in function calls
// In normal function calls(as opposed to constructor function calls), 
// new.target is undefined.This lets you detect whether a function
//  was called with new as a constructor.
function Foo() {
    if (!new.target) {
        throw new Error("Foo() must be called with new");
    }
    console.log("Foo instantiated with new");
}

new Foo(); // Logs "Foo instantiated with new"
Foo(); // Throws "Foo() must be called with new"

// new.target in constructors
// In class constructors, new.target refers to the constructor 
// that was directly invoked by new.This is also the case if 
// the constructor is in a parent class and was delegated from 
// a child constructor.new.target points to the class that 
// new was called upon.For example, when b was initialized 
// using new B(), the name of B was printed; and similarly, 
// in case of a, the name of class A was printed.

class A {
    constructor() {
        console.log(new.target.name);
    }
}
class B extends A {
    constructor() {
        super();
    }
}
const a = new A(); // Logs "A"
const b = new B(); // Logs "B"

// new.target using Reflect.construct()
// Before Reflect.construct() or classes, it was common 
// to implement inheritance by passing the value of this, 
// and letting the base constructor mutate it.

function Base() {
    this.name = "Base";
}
function Extended() {
    // Only way to make the Base() constructor work on the existing
    // `this` value instead of a new object that `new` creates.
    Base.call(this);
    this.otherProperty = "Extended";
}
Object.setPrototypeOf(Extended.prototype, Base.prototype);
Object.setPrototypeOf(Extended, Base);
console.log(new Extended()); // Extended { name: 'Base', otherProperty: 'Extended' }
// However, call() and apply() actually call the function instead 
// of constructing it, so new.target has value undefined.
// This means that if Base() checks whether it's constructed with new, 
// an error will be thrown, or it may behave in other unexpected ways. 
// For example, you can't extend Map this way, because 
// the Map() constructor cannot be called without new.



//All built -in constructors directly construct 
// the entire prototype chain of the new instance 
// by reading new.target.prototype.So to make sure that(1) 
// Base is constructed with new, and(2) new.target points 
// to the subclass instead of Base itself, we need to use Reflect.construct().

function BetterMap(entries) {
    // Call the base class constructor, but setting `new.target` to the subclass,
    // so that the instance created has the correct prototype chain.
    return Reflect.construct(Map, [entries], BetterMap);
}

BetterMap.prototype.upsert = function (key, actions) {
    if (this.has(key)) {
        this.set(key, actions.update(this.get(key)));
    } else {
        this.set(key, actions.insert());
    }
};

Object.setPrototypeOf(BetterMap.prototype, Map.prototype);
Object.setPrototypeOf(BetterMap, Map);

const map = new BetterMap([["a", 1]]);
map.upsert("a", {
    update: (value) => value + 1,
    insert: () => 1,
});
console.log(map.get("a")); // 2
// Note: In fact, due to the lack of Reflect.construct(), it 
// is not possible to properly subclass built - ins(like Error subclassing) 
// when transpiling to pre - ES6 code.

//However, if you are writing ES6 code, prefer using classes 
// and extends instead, as it's more readable and less error-prone.

class BetterMap extends Map {
    // The constructor is omitted because it's just the default one
    upsert(key, actions) {
        if (this.has(key)) {
            this.set(key, actions.update(this.get(key)));
        } else {
            this.set(key, actions.insert());
        }
    }
}

const map = new BetterMap([["a", 1]]);
map.upsert("a", {
    update: (value) => value + 1,
    insert: () => 1,
});
console.log(map.get("a")); // 2

// null
// The null value represents the intentional absence 
// of any object value.It is one of JavaScript's primitive
//  values and is treated as falsy for boolean operations.

function getVowels(str) {
    const m = str.match(/[aeiou]/gi);
    if (m === null) {
        return 0;
    }
    return m.length;
}
console.log(getVowels('sky'));
// Expected output: 0

// Description
// The value null is written with a literal: null.null is not 
// an identifier for a property of the global object, like undefined 
// can be.Instead, null expresses a lack of identification, indicating 
// that a variable points to no object.In APIs, null is often retrieved 
// in a place where an object can be expected but no object is relevant.

// Difference between null and undefined
// When checking for null or undefined, beware of 
// the differences between equality(==) and identity(===) operators, 
// as the former performs type - conversion.

typeof null; // "object" (not "null" for legacy reasons)
typeof undefined; // "undefined"
null === undefined; // false
null == undefined; // true
null === null; // true
null == null; // true
!null; // true
Number.isNaN(1 + null); // false
Number.isNaN(1 + undefined); // true

// Nullish coalescing assignment(??=)
// The nullish coalescing assignment(??=) operator, 
// also known as the logical nullish assignment operator,
//  only evaluates the right operand and assigns to 
// the left if the left operand is nullish(null or undefined).

const a = { duration: 50 };
a.duration ??= 10;
console.log(a.duration);
// Expected output: 50
a.speed ??= 25;
console.log(a.speed);
// Expected output: 25

// Syntax
x ??= y
// Description
// Nullish coalescing assignment short - circuits, 
// meaning that x ??= y is equivalent to x ?? (x = y), 
// except that the expression x is only evaluated once.

// No assignment is performed if the left - hand side 
// is not nullish, due to short - circuiting of 
// the nullish coalescing operator.For example, 
// the following does not throw an error, 
// despite x being const:

const x = 1;
x ??= 2;

// Neither would the following trigger the setter:
const x = {
    get value() {
        return 1;
    },
    set value(v) {
        console.log("Setter called");
    },
};
x.value ??= 2;
// In fact, if x is not nullish, y is not evaluated at all.
const x = 1;
x ??= console.log("y evaluated");
// // Logs nothing

// Using nullish coalescing assignment
// You can use the nullish coalescing assignment operator 
// to apply default values to object properties.
// Compared to using destructuring and default values,
//  ??= also applies the default value if the property has value null.

function config(options) {
    options.duration ??= 100;
    options.speed ??= 25;
    return options;
}
config({ duration: 125 }); // { duration: 125, speed: 25 }
config({}); // { duration: 100, speed: 25 }

// Nullish coalescing operator(??)
// The nullish coalescing(??) operator is 
// a logical operator that returns its 
// right - hand side operand when its 
// left - hand side operand is null or undefined, 
// and otherwise returns its left - hand side operand.

const foo = null ?? 'default string';
console.log(foo);
// Expected output: "default string"

const baz = 0 ?? 42;
console.log(baz);
// Expected output: 0

// Syntax
leftExpr ?? rightExpr
// Description
// The nullish coalescing operator can be seen 
// as a special case of the logical OR(||) operator.
// The latter returns the right - hand side operand 
// if the left operand is any falsy value, not only 
// null or undefined.In other words, if you use || to 
// provide some default value to another variable foo, 
// you may encounter unexpected behaviors if you consider 
// some falsy values as usable (e.g., '' or 0).

// It is not possible to combine both the AND(&&) and 
// OR operators(||) directly with ??.A syntax error will 
// be thrown in such cases.
null || undefined ?? "foo"; // raises a SyntaxError
true && undefined ?? "foo"; // raises a SyntaxError
// Instead, provide parenthesis to explicitly indicate precedence:
(null || undefined) ?? "foo"; // returns "foo"

// Using the nullish coalescing operator
// In this example, we will provide default values but keep 
// values other than null or undefined.
const nullValue = null;
const emptyText = ""; // falsy
const someNumber = 42;

const valA = nullValue ?? "default for A";
const valB = emptyText ?? "default for B";
const valC = someNumber ?? 0;

console.log(valA); // "default for A"
console.log(valB); // "" (as the empty string is not null or undefined)
console.log(valC); // 42

// Short - circuiting
// Like the OR and AND logical operators, the right - hand side 
// expression is not evaluated if the left - hand side proves to 
// be neither null nor undefined.
function a() {
    console.log("a was called");
    return undefined;
}
function b() {
    console.log("b was called");
    return false;
}
function c() {
    console.log("c was called");
    return "foo";
}
console.log(a() ?? c());
// Logs "a was called" then "c was called" and then "foo"
// // as a() returned undefined so both expressions are evaluated
console.log(b() ?? c());
// Logs "b was called" then "false"
// as b() returned false (and not null or undefined), the right
// hand side expression was not evaluated

// Relationship with the optional chaining operator(?.)
// The nullish coalescing operator treats undefined and null 
// as specific values.So does the optional chaining operator(?.), 
// which is useful to access a property of an object which may 
// be null or undefined.Combining them, you can safely access 
// a property of an object which may be nullish and provide 
// a default value if it is.

const foo = { someFooProp: "hi" };

console.log(foo.someFooProp?.toUpperCase() ?? "not available"); // "HI"
console.log(foo.someBarProp?.toUpperCase() ?? "not available"); // "not available"

// Optional chaining(?.)
// The optional chaining(?.) operator accesses an object's property 
// or calls a function. If the object accessed or function called 
// using this operator is undefined or null, the expression short 
// circuits and evaluates to undefined instead of throwing an error.

const adventurer = {
    name: 'Alice',
    cat: {
        name: 'Dinah',
    },
};
const dogName = adventurer.dog?.name;
console.log(dogName);
// Expected output: undefined
console.log(adventurer.someNonExistentMethod?.());
// Expected output: undefined

// Syntax
obj.val?.prop
obj.val?.[expr]
obj.func?.(args)

// The ?. operator is like the.chaining operator, except 
// that instead of causing an error if a reference is nullish(null or undefined), 
// the expression short - circuits with a return value of undefined.When used 
// with function calls, it returns undefined if the given function does not exist.

// This results in shorter and simpler expressions when accessing chained 
// properties when the possibility exists that a reference may be missing.
// It can also be helpful while exploring the content of an object when
//  there's no known guarantee as to which properties are required.

// For example, consider an object obj which has a nested structure.Without 
// optional chaining, looking up a deeply - nested subproperty requires 
// validating the references in between, such as:
const nestedProp = obj.first && obj.first.second;
// The value of obj.first is confirmed to be non - null(and non - undefined) 
// before accessing the value of obj.first.second.This prevents the error that 
// would occur if you accessed obj.first.second directly without testing obj.first.


// This is an idiomatic pattern in JavaScript, but it gets verbose when 
// the chain is long, and it's not safe. For example, if obj.first is 
// a Falsy value that's not null or undefined, such as 0, it would 
// still short - circuit and make nestedProp become 0, which may not be desirable.

// With the optional chaining operator(?.), however, you don't have to explicitly 
// test and short-circuit based on the state of obj.first before trying to access 
// obj.first.second:
const nestedProp = obj.first?.second;
// By using the ?.operator instead of just., JavaScript knows to implicitly 
// check to be sure obj.first is not null or undefined before attempting to 
// access obj.first.second.If obj.first is null or undefined, the expression 
// automatically short - circuits, returning undefined.


// This is equivalent to the following, except that the temporary variable is 
// in fact not created:
const temp = obj.first;
const nestedProp =
    temp === null || temp === undefined ? undefined : temp.second;
// Optional chaining cannot be used on a non - declared root object, but 
// can be used with a root object with value undefined.

undeclaredVar?.prop; // ReferenceError: undeclaredVar is not defined


// Optional chaining with function calls
// You can use optional chaining when attempting to call a method which may 
// not exist.This can be helpful, for example, when using an API in which a method 
// might be unavailable, either due to the age of the implementation or because 
// of a feature which isn't available on the user's device.

// Using optional chaining with function calls causes the expression to automatically 
// return undefined instead of throwing an exception if the method isn't found:
const result = someInterface.customMethod?.();

// However, if there is a property with such a name which is not a function,
//  using?.will still raise a TypeError exception "someInterface.customMethod 
// is not a function".

//Note: If someInterface itself is null or undefined, a TypeError exception will 
// still be raised("someInterface is null").If you expect that someInterface itself 
// may be null or undefined, you have to use?.at this position 
// as well: someInterface?.customMethod?.().

// Optional chaining with expressions
// You can also use the optional chaining operator with bracket notation,
//  which allows passing an expression as the property name:
const nestedProp = obj?.["prop" + "Name"];
// This is particularly useful for arrays, since array indices must be 
// accessed with square brackets.

function printMagicIndex(arr) {
    console.log(arr?.[42]);
}

printMagicIndex([0, 1, 2, 3, 4, 5]); // undefined
printMagicIndex(); // undefined; if not using ?., this would throw an error: "Cannot read properties of undefined (reading '42')"

// Optional chaining not valid on the left - hand side of an assignment
// It is invalid to try to assign to the result of an optional chaining expression:
const object = {};
object?.property = 1; // SyntaxError: Invalid left-hand side in assignment


// Short - circuiting
// When using optional chaining with expressions, if the left operand is null 
// or undefined, the expression will not be evaluated.For instance:

const potentiallyNullObj = null;
let x = 0;
const prop = potentiallyNullObj?.[x++];

console.log(x); // 0 as x was not incremented
// Subsequent property accesses will not be evaluated either.

const potentiallyNullObj = null;
const prop = potentiallyNullObj?.a.b;
// This does not throw, because evaluation has already stopped at
// the first optional chain
// This is equivalent to:

const potentiallyNullObj = null;
const prop =
    potentiallyNullObj === null || potentiallyNullObj === undefined
        ? undefined
        : potentiallyNullObj.a.b;
// However, this short - circuiting behavior only happens 
// along one continuous "chain" of property accesses.
// If you group one part of the chain, then subsequent property 
// accesses will still be evaluated.

const potentiallyNullObj = null;
const prop = (potentiallyNullObj?.a).b;
const potentiallyNullObj = null;
const prop = (potentiallyNullObj?.a).b;
// TypeError: Cannot read properties of undefined (reading 'b')
// This is equivalent to:

const potentiallyNullObj = null;
const temp = potentiallyNullObj?.a;
const prop = temp.b;
// Except the temp variable isn't created.

// This example looks for the value of the name property for 
// the member bar in a map when there is no such member.
// The result is therefore undefined.
const myMap = new Map();
myMap.set("foo", { name: "baz", desc: "inga" });
const nameBar = myMap.get("bar")?.name;

// Dealing with optional callbacks or event handlers
// If you use callbacks or fetch methods from an object with 
// a destructuring assignment, you may have non - existent values 
// that you cannot call as functions unless you have tested 
// their existence.Using?., you can avoid this extra test:

// Code written without optional chaining
function doSomething(onContent, onError) {
    try {
        // Do something with the data
    } catch (err) {
        // Testing if onError really exists
        if (onError) {
            onError(err.message);
        }
    }
}
// Using optional chaining with function calls
function doSomething(onContent, onError) {
    try {
        // Do something with the data
    } catch (err) {
        onError?.(err.message); // No exception if onError is undefined
    }
}
// Stacking the optional chaining operator
// With nested structures, it is possible to use optional chaining multiple times:
const customer = {
    name: "Carl",
    details: {
        age: 82,
        location: "Paradise Falls", // Detailed address is unknown
    },
};
const customerCity = customer.details?.address?.city;
// This also works with optional chaining function call
const customerName = customer.name?.getName?.(); // Method does not exist, customerName is undefined

// Combining with the nullish coalescing operator
// The nullish coalescing operator may be used after optional chaining in 
// order to build a default value when none was found:
function printCustomerCity(customer) {
    const customerCity = customer?.city ?? "Unknown city";
    console.log(customerCity);
}
printCustomerCity({
    name: "Nathan",
    city: "Paris",
}); // "Paris"
printCustomerCity({
    name: "Carl",
    details: { age: 82 },
}); // "Unknown city"

// Property accessors
// Property accessors provide access to an object's 
// properties by using the dot notation or the bracket notation.

const person1 = {};
person1['firstname'] = 'Mario';
person1['lastname'] = 'Rossi';
console.log(person1.firstname);
// Expected output: "Mario"
const person2 = {
    firstname: 'John',
    lastname: 'Doe',
};
console.log(person2['lastname']);
// Expected output: "Doe"

object.propertyName
object[expression]

// Description
// One can think of an object as an associative array(a.k.a.map, 
// dictionary, hash, lookup table).The keys in this array are 
// the names of the object's properties.
// There are two ways to access properties: dot notation and bracket notation.

const variable = object.propertyName;
object.propertyName = value;

const object = {};
object.$1 = "foo";
console.log(object.$1); // 'foo'

const object = {};
object.1 = 'bar'; // SyntaxError
console.log(object.1); // SyntaxError

// Bracket notation
// In the object[expression] syntax, the expression should evaluate 
// to a string or Symbol that represents the property's name.
//  So, it can be any string literal, for example, 
// including '1foo', '!bar!', or even ' ' (a space).


const variable = object[propertyName];
object[propertyName] = value;
// This does the exact same thing as the previous example.

document["createElement"]("pre");
// A space before bracket notation is allowed.

document["createElement"]("pre");
// Passing expressions that evaluate to property name will 
// do the same thing as directly passing the property name.

const key = "name";
const getKey = () => "name";
const Obj = { name: "Michel" };

Obj["name"]; // returns "Michel"
Obj[key]; // evaluates to Obj["name"], and returns "Michel"
Obj[getKey()]; // evaluates to Obj["name"], and returns "Michel"
// However, beware of using square brackets to access 
// properties whose names are given by external input.
// This may make your code susceptible to object injection attacks.

//     Property names
// Each property name is a string or a Symbol.Any other value, 
// including a number, is coerced to a string.This outputs 'value', 
// since 1 is coerced into '1'

const object = {};
object["1"] = "value";
console.log(object[1]);
// This also outputs 'value', since both foo and bar 
// are converted to the same string("[object Object]").

const foo = { uniqueProp: 1 };
const bar = { uniqueProp: 2 };
const object = {};
object[foo] = "value";
console.log(object[bar]);

// Spread syntax(...)
// The spread(...) syntax allows an iterable, 
// such as an array or string, to be expanded in places 
// where zero or more arguments(for function calls) or 
// elements(for array literals) are expected.
// In an object literal, the spread syntax enumerates 
// the properties of an object and adds the key - value 
// pairs to the object being created.
// Spread syntax looks exactly like rest syntax.In a way, 
// spread syntax is the opposite of rest syntax.Spread 
// syntax "expands" an array into its elements, while rest 
// syntax collects multiple elements and "condenses" them 
// into a single element.See rest parameters and rest property.

// Spread syntax can be used when all elements from an object or 
// array need to be included in a new array or object, or should 
// be applied one-by-one in a function call's arguments list. 
// There are three distinct places that accept the spread syntax:

// Function arguments list (myFunction(a, ...iterableObj, b))
// Array literals ([1, ...iterableObj, '4', 'five', 6])
// Object literals ({ ...obj, key: 'value' })


// Although the syntax looks the same, they come with slightly different semantics.

// Only iterable values, like Array and String, can be spread in array 
// literals and argument lists. Many objects are not iterable, including 
// all plain objects that lack a Symbol.iterator method:

const obj = { key1: "value1" };
const array = [...obj]; // TypeError: obj is not iterable
// On the other hand, spreading in object literals enumerates 
// the own properties of the value. For typical arrays, all 
// indices are enumerable own properties, so arrays can be spread into objects.

// JS
// Copy to Clipboard
const array = [1, 2, 3];
const obj = { ...array }; // { 0: 1, 1: 2, 2: 3 }
// All primitives can be spread in objects. Only strings have 
// enumerable own properties, and spreading anything else doesn't 
// create properties on the new object.

const obj = { ...true, ..."test", ...10 };
// { '0': 't', '1': 'e', '2': 's', '3': 't' }
// When using spread syntax for function calls, be aware of 
// the possibility of exceeding the JavaScript engine's argument 
// length limit. See Function.prototype.apply() for more details.

// Spread in function calls

function myFunction(x, y, z) { }
const args = [0, 1, 2];
myFunction.apply(null, args);
// With spread syntax the above can be written as:

function myFunction(x, y, z) { }
const args = [0, 1, 2];
myFunction(...args);
// Any argument in the argument list can use spread syntax, and 
// the spread syntax can be used multiple times.

function myFunction(v, w, x, y, z) { }
const args = [0, 1];
myFunction(-1, ...args, 2, ...[3]);


// Apply for new operator
// When calling a constructor with new, it's not possible to 
// directly use an array and apply(), because apply() calls 
// the target function instead of constructing it, which means,
//  among other things, that new.target will be undefined. 
// However, an array can be easily used with new thanks to spread syntax:

const dateFields = [1970, 0, 1]; // 1 Jan 1970
const d = new Date(...dateFields);
// Spread in array literals
// A more powerful array literal
// Without spread syntax, the array literal syntax is no longer
//  sufficient to create a new array using an existing array as 
// one part of it. Instead, imperative code must be used using 
// a combination of methods, including push(), splice(), concat(), etc. 
// With spread syntax, this becomes much more succinct:

const parts = ["shoulders", "knees"];
const lyrics = ["head", ...parts, "and", "toes"];
//  ["head", "shoulders", "knees", "and", "toes"]
// Just like spread for argument lists, ... can be used anywhere 
// in the array literal, and may be used more than once.


// super
// The super keyword is used to access properties 
// on an object literal or class's [[Prototype]], 
// or invoke a superclass's constructor.
// The super.prop and super[expr] expressions are valid 
// in any method definition in both classes and object literals.
// The super(...args) expression is valid in class constructors.

class Foo {
    constructor(name) {
        this.name = name;
    }
    getNameSeparator() {
        return '-';
    }
}

class FooBar extends Foo {
    constructor(name, index) {
        super(name);
        this.index = index;
    }

    getFullName() {
        return this.name + super.getNameSeparator() + this.index;
    }
}

const firstFooBar = new FooBar('foo', 1);

console.log(firstFooBar.name);
// Expected output: "foo"

console.log(firstFooBar.getFullName());
// Expected output: "foo-1"


// Syntax
super([arguments]) // calls the parent constructor.
super.propertyOnParent
super[expression]

// The super keyword can be used in two ways: as 
// a "function call"(super(...args)), or as 
// a "property lookup"(super.prop and super[expr]).

//Note: super is a keyword and these are special 
// syntactic constructs.super is not a variable 
// that points to the prototype object.Attempting 
// to read super itself is a SyntaxError.

const child = {
    myParent() {
        console.log(super); // SyntaxError: 'super' keyword unexpected here
    },
};
// In the constructor body of a derived class (with extends), 
// the super keyword may appear as a "function call"(super(...args)), 
// which must be called before the this keyword is used, and before 
// the constructor returns.It calls the parent class's constructor
//  and binds the parent class's public fields, after which the 
// derived class's constructor can further access and modify this.

// The "property lookup" form can be used to access methods and 
// properties of an object literal's or class's[[Prototype]].Within 
// a class's body, the reference of super can be either the superclass's 
// constructor itself, or the constructor's prototype, depending on 
// whether the execution context is instance creation or class initialization. 
// See the Examples section for more details.

// Note that the reference of super is determined by the class or object 
// literal super was declared in, not the object the method is called on.
// Therefore, unbinding or re - binding a method doesn't change the reference 
// of super in it (although they do change the reference of this). You can 
// see super as a variable in the class or object literal scope, which 
// the methods create a closure over. (But also beware that it's not 
// actually a variable, as explained above.)

// When setting properties through super, the property is set on this instead.

//     Examples
// Using super in classes
// This code snippet is taken from the classes sample(live demo).
// Here super() is called to avoid duplicating the constructor parts' 
// that are common between Rectangle and Square.

class Rectangle {
    constructor(height, width) {
        this.name = "Rectangle";
        this.height = height;
        this.width = width;
    }
    sayName() {
        console.log(`Hi, I am a ${this.name}.`);
    }
    get area() {
        return this.height * this.width;
    }
    set area(value) {
        this._area = value;
    }
}

class Square extends Rectangle {
    constructor(length) {
        // Here, it calls the parent class's constructor with lengths
        // provided for the Rectangle's width and height
        super(length, length);
        // Note: In derived classes, super() must be called before you
        // can use 'this'. Moving this to the top causes a ReferenceError.
        this.name = "Square";
    }
}
// Super - calling static methods
// You are also able to call super on static methods.

class Rectangle {
    static logNbSides() {
        return "I have 4 sides";
    }
}

class Square extends Rectangle {
    static logDescription() {
        return `${super.logNbSides()} which are all equal`;
    }
}
Square.logDescription(); // 'I have 4 sides which are all equal'
// Accessing super in class field declaration
// super can also be accessed during class field initialization.
// The reference of super depends on whether the current field 
// is an instance field or a static field.

class Base {
    static baseStaticField = 90;
    baseMethod() {
        return 10;
    }
}

class Extended extends Base {
    extendedField = super.baseMethod(); // 10
    static extendedStaticField = super.baseStaticField; // 90
}
// Note that instance fields are set on the instance instead of 
// the constructor's prototype, so you can't use super to access 
// the instance field of a superclass.

class Base {
    baseField = 10;
}

class Extended extends Base {
    extendedField = super.baseField; // undefined
}
// Here, extendedField is undefined instead of 10, because baseField 
// is defined as an own property of the Base instance, instead of 
// Base.prototype.super, in this context, only looks up properties 
// on Base.prototype, because that's the [[Prototype]] of Extended.prototype.

// Deleting super properties will throw an error
// You cannot use the delete operator and super.prop or super[expr] 
// to delete a parent class' property — it will throw a ReferenceError.

class Base {
    foo() { }
}
class Derived extends Base {
    delete() {
        delete super.foo; // this is bad
    }
}

new Derived().delete(); // ReferenceError: invalid delete involving 'super'.

// Using super.prop in object literals
// Super can also be used in the object initializer notation.In this
//  example, two objects define a method.In the second object, super 
// calls the first object's method. This works with the help of 
// Object.setPrototypeOf() with which we are able to set the prototype 
// of obj2 to obj1, so that super is able to find method1 on obj1.

// JS
// Copy to Clipboard
const obj1 = {
    method1() {
        console.log("method 1");
    },
};

const obj2 = {
    method2() {
        super.method1();
    },
};

Object.setPrototypeOf(obj2, obj1);
obj2.method2(); // Logs "method 1"
// Methods that read super.prop do not behave differently when bound 
// to other objects
// Accessing super.x behaves 
// like Reflect.get(Object.getPrototypeOf(objectLiteral), "x", this), 
// which means the property is always seeked on 
// the object literal / class declaration's prototype, and unbinding 
// and re-binding a method won't change the reference of super.

class Base {
    baseGetX() {
        return 1;
    }
}
class Extended extends Base {
    getX() {
        return super.baseGetX();
    }
}

const e = new Extended();
console.log(e.getX()); // 1
const { getX } = e;
console.log(getX()); // 1
// The same happens in object literals.

const parent1 = { prop: 1 };
const parent2 = { prop: 2 };

const child = {
    myParent() {
        console.log(super.prop);
    },
};

Object.setPrototypeOf(child, parent1);
child.myParent(); // Logs "1"

const myParent = child.myParent;
myParent(); // Still logs "1"

const anotherChild = { __proto__: parent2, myParent };
anotherChild.myParent(); // Still logs "1"
// Only resetting the entire inheritance chain will change 
// the reference of super.

class Base {
    baseGetX() {
        return 1;
    }
    static staticBaseGetX() {
        return 3;
    }
}
class AnotherBase {
    baseGetX() {
        return 2;
    }
    static staticBaseGetX() {
        return 4;
    }
}
class Extended extends Base {
    getX() {
        return super.baseGetX();
    }
    static staticGetX() {
        return super.staticBaseGetX();
    }
}

const e = new Extended();
// Reset instance inheritance
Object.setPrototypeOf(Extended.prototype, AnotherBase.prototype);
console.log(e.getX()); // Logs "2" instead of "1", because the prototype chain has changed
console.log(Extended.staticGetX()); // Still logs "3", because we haven't modified the static part yet
// Reset static inheritance
Object.setPrototypeOf(Extended, AnotherBase);
console.log(Extended.staticGetX()); // Now logs "4"
// Calling methods from super
// When calling super.prop as a function, the this value 
// inside the prop function is the current this, not 
// the object that super points to.For example,
//  the super.getName() call logs "Extended", despite 
// the code looking like it's equivalent to Base.getName().

class Base {
    static getName() {
        console.log(this.name);
    }
}

class Extended extends Base {
    static getName() {
        super.getName();
    }
}

Extended.getName(); // Logs "Extended"
// This is especially important when interacting with static private properties.

// Setting super.prop sets the property on this instead
// Setting properties of super, such as super.x = 1, behaves 
// like Reflect.set(Object.getPrototypeOf(objectLiteral), "x", 1, this).
// This is one of the cases where understanding super as simply 
// "reference of the prototype object" falls short, because it 
// actually sets the property on this instead.

class A { }
class B extends A {
    setX() {
        super.x = 1;
    }
}

const b = new B();
b.setX();
console.log(b); // B { x: 1 }
console.log(Object.hasOwn(b, "x")); // true
// super.x = 1 will look for the property descriptor of x 
// on A.prototype(and invoke the setters defined there), 
// but the this value will be set to this, which is b in 
// this context.You can read Reflect.set for more details 
// on the case when target and receiver differ.

// This means that while methods that get super.prop are usually 
// not susceptible to changes in the this context, those that 
// set super.prop are.

/* Reusing same declarations as above */
const b2 = new B();
b2.setX.call(null); // TypeError: Cannot assign to read only property 'x' of object 'null'
// However, super.x = 1 still consults the property descriptor 
// of the prototype object, which means you cannot rewrite 
// non - writable properties, and setters will be invoked.

class X {
    constructor() {
        // Create a non-writable property
        Object.defineProperty(this, "prop", {
            configurable: true,
            writable: false,
            value: 1,
        });
    }
}

class Y extends X {
    constructor() {
        super();
    }
    foo() {
        super.prop = 2; // Cannot overwrite the value.
    }
}

const y = new Y();
y.foo(); // TypeError: "prop" is read-only
console.log(y.prop); // 1

// this
// A function's this keyword behaves a little differently
//  in JavaScript compared to other languages. It also has 
// some differences between strict mode and non-strict mode.

// In most cases, the value of this is determined by how 
// a function is called(runtime binding).It can't be set 
// by assignment during execution, and it may be different 
// each time the function is called. The Function.prototype.bind() 
// method can set the value of a function's this regardless of how 
// it's called, and arrow functions don't provide their own 
// this binding(it retains the this value of the enclosing lexical context).

const test = {
    prop: 42,
    func: function () {
        return this.prop;
    },
};

console.log(test.func());
// Expected output: 42

// Syntax
this
// Value
// In non–strict mode, this is always a reference to 
// an object.In strict mode, it can be any value.For 
// more information on how the value is determined, 
// see the description below.

//     Description
// The value of this depends on in which context it appears: 
// function, class, or global.

// Function context
// Inside a function, the value of this depends on how 
// the function is called.Think about this as a hidden 
// parameter of a function — just like the parameters 
// declared in the function definition, this is a binding 
// that the language creates for you when the function body is evaluated.

// For a typical function, the value of this is the object 
// that the function is accessed on.In other words, if 
// the function call is in the form obj.f(), then this 
// refers to obj.For example:

function getThis() {
    return this;
}

const obj1 = { name: "obj1" };
const obj2 = { name: "obj2" };

obj1.getThis = getThis;
obj2.getThis = getThis;

console.log(obj1.getThis()); // { name: 'obj1', getThis: [Function: getThis] }
console.log(obj2.getThis()); // { name: 'obj2', getThis: [Function: getThis] }
// Note how the function is the same, but based on how 
// it's invoked, the value of this is different. This 
// is analogous to how function parameters work.

// The value of this is not the object that has the function
//  as an own property, but the object that is used to call
//  the function. You can prove this by calling a method of 
// an object up in the prototype chain.

const obj3 = {
    __proto__: obj1,
    name: "obj3",
};

console.log(obj3.getThis()); // { name: 'obj3' }
// The value of this always changes based on how a function 
// is called, even when the function was defined on an object at creation:
const obj4 = {
    name: "obj4",
    getThis() {
        return this;
    },
};

const obj5 = { name: "obj5" };
obj5.getThis = obj4.getThis;
console.log(obj5.getThis()); // { name: 'obj5', getThis: [Function: getThis] }
// If the value that the method is accessed on is 
// a primitive, this will be a primitive value as 
// well — but only if the function is in strict mode.

function getThisStrict() {
    "use strict"; // Enter strict mode
    return this;
}
// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThisStrict = getThisStrict;
console.log(typeof (1).getThisStrict()); // "number"
// If the function is called without being accessed 
// on anything, this will be undefined — but only 
// if the function is in strict mode.
console.log(typeof getThisStrict()); // "undefined"
// In non - strict mode, a special process called 
// this substitution ensures that the value of this
//  is always an object.This means:

// If a function is called with this set to undefined or null, 
// this gets substituted with globalThis.
// If the function is called with this set to a primitive value, this 
// gets substituted with the primitive value's wrapper object.

function getThis() {
    return this;
}
// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThis = getThis;
console.log(typeof (1).getThis()); // "object"
console.log(getThis() === globalThis); // true
// In typical function calls, this is implicitly passed like 
// a parameter through the function's prefix (the part before the dot). 
// You can also explicitly set the value of this using 
// the Function.prototype.call(), Function.prototype.apply(), 
// or Reflect.apply() methods. Using Function.prototype.bind(), 
// you can create a new function with a specific value of this 
// that doesn't change regardless of how the function is called.
// When using these methods, the this substitution rules above 
// still apply if the function is non - strict.

//     Callbacks
// When a function is passed as a callback, the value of this
//  depends on how the callback is called, which is determined 
// by the implementor of the API.Callbacks are typically called 
// with a this value of undefined(calling it directly without 
// attaching it to any object), which means if the function is 
// non–strict, the value of this is the global object(globalThis).
// This is the case for iterative array methods, the Promise() constructor, etc.

function logThis() {
    "use strict";
    console.log(this);
}

[1, 2, 3].forEach(logThis); // undefined, undefined, undefined
// Some APIs allow you to set a this value for invocations of 
// the callback.For example, all iterative array methods and 
// related ones like Set.prototype.forEach() accept an optional thisArg parameter.

[1, 2, 3].forEach(logThis, { name: "obj" });
{ name: 'obj' }, { name: 'obj' }, { name: 'obj' }
// Occasionally, a callback is called with a this value other 
// than undefined.For example, the reviver parameter of JSON.parse() 
// and the replacer parameter of JSON.stringify() are both called with 
// this set to the object that the property being parsed / serialized belongs to.

// Arrow functions
// In arrow functions, this retains the value of the enclosing lexical context's 
// this. In other words, when evaluating an arrow function's body, the language 
// does not create a new this binding.

// For example, in global code, this is always globalThis regardless of strictness, 
// because of the global context binding:

const globalObject = this;
const foo = () => this;
console.log(foo() === globalObject); // true
// Arrow functions create a closure over the this value of its surrounding scope, 
// which means arrow functions behave as if they are "auto-bound" — no matter 
// how it's invoked, this is bound to what it was when the function was created 
// (in the example above, the global object). The same applies to arrow functions 
// created inside other functions: their this remains that of the enclosing lexical 
// context. See example below.

// Furthermore, when invoking arrow functions using call(), bind(), or apply(), 
// the thisArg parameter is ignored.You can still pass other arguments using 
// these methods, though.

const obj = { name: "obj" };
// Attempt to set this using call
console.log(foo.call(obj) === globalObject); // true
// Attempt to set this using bind
const boundFoo = foo.bind(obj);
console.log(boundFoo() === globalObject); // true
// Constructors
// When a function is used as a constructor(with the new keyword), its this is 
// bound to the new object being constructed, no matter which object the constructor 
// function is accessed on.The value of this becomes the value of the new expression 
// unless the constructor returns another non–primitive value.
function C() {
    this.a = 37;
}
let o = new C();
console.log(o.a); // 37
function C2() {
    this.a = 37;
    return { a: 38 };
}
o = new C2();
console.log(o.a); // 38
// In the second example(C2), because an object was returned during construction, 
// the new object that this was bound to gets discarded. (This essentially makes 
// the statement this.a = 37; dead code.It's not exactly dead because it gets 
// executed, but it can be eliminated with no outside effects.)

// super
// When a function is invoked in the super.method() form, the this inside 
// the method function is the same value as the this value around 
// the super.method() call, and is generally not equal to the object that 
// super refers to.This is because super.method is not an object member 
// access like the ones above — it's a special syntax with different binding 
// rules. For examples, see the super reference.

// Class context
// A class can be split into two contexts: static and instance.Constructors, 
// methods, and instance field initializers(public or private) belong to 
// the instance context.Static methods, static field initializers, and static 
// initialization blocks belong to the static context.The this value is different 
// in each context.

// Class constructors are always called with new, so their behavior is the same 
// as function constructors: the this value is the new instance being created.
// Class methods behave like methods in object literals — the this value is 
// the object that the method was accessed on.If the method is not transferred 
// to another object, this is generally an instance of the class.

// Static methods are not properties of this.They are properties of the class itself.
// Therefore, they are generally accessed on the class, and this is the value of 
// the class (or a subclass). Static initialization blocks are also evaluated with 
// this set to the current class.

// Field initializers are also evaluated in the context of the class. Instance fields 
// are evaluated with this set to the instance being constructed.Static fields are 
// evaluated with this set to the current class. This is why arrow functions in field 
// initializers are bound to the instance for instance fields and to the class for 
// static fields.

class C {
    instanceField = this;
    static staticField = this;
}

const c = new C();
console.log(c.instanceField === c); // true
console.log(C.staticField === C); // true
// Derived class constructors
// Unlike base class constructors, derived constructors have no initial 
// this binding.Calling super() creates a this binding within the constructor 
// and essentially has the effect of evaluating the following line of code, 
// where Base is the base class:

this = new Base();
// Warning: Referring to this before calling super() will throw an error.

// Derived classes must not return before calling super(), unless the constructor 
// returns an object(so the this value is overridden) or the class has no constructor 
// at all.

class Base { }
class Good extends Base { }
class AlsoGood extends Base {
    constructor() {
        return { a: 5 };
    }
}
class Bad extends Base {
    constructor() { }
}

new Good();
new AlsoGood();
new Bad(); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
// Global context
// In the global execution context(outside of any functions or classes; 
// may be inside blocks or arrow functions defined in the global scope), 
// the this value depends on what execution context the script runs in.Like 
// callbacks, the this value is determined by the runtime environment(the caller).

// At the top level of a script, this refers to globalThis whether in strict mode 
// or not.This is generally the same as the global object — for example, if 
// the source is put inside an HTML < script > element and executed as a script, 
// this === window.

//Note: globalThis is generally the same concept as the global object(i.e.adding 
// properties to globalThis makes them global variables) — this is the case for 
// browsers and Node — but hosts are allowed to provide a different value for 
// globalThis that's unrelated to the global object.

// In web browsers, the window object is also the global object:
console.log(this === window); // true

this.b = "MDN";
console.log(window.b); // "MDN"
console.log(b); // "MDN"
// If the source is loaded as a module(for HTML, this means adding type = "module" 
// to the < script > tag), this is always undefined at the top level.

// If the source is executed with eval(), this is the same as the enclosing context 
// for direct eval, or globalThis(as if it's run in a separate global script) for 
// indirect eval.

function test() {
    // Direct eval
    console.log(eval("this") === this);
    // Indirect eval, non-strict
    console.log(eval?.("this") === globalThis);
    // Indirect eval, strict
    console.log(eval?.("'use strict'; this") === globalThis);
}

test.call({ name: "obj" }); // Logs 3 "true"
// Note that some source code, while looking like the global scope, is actually 
// wrapped in a function when executed.For example, Node.js CommonJS modules are 
// wrapped in a function and executed with the this value set to module.exports.
// Event handler attributes are executed with this set to the element they are 
// attached to.

// Object literals don't create a this scope — only functions (methods) defined 
// within the object do. Using this in an object literal inherits the value from 
// the surrounding scope.
const obj = {
    a: this,
};

console.log(obj.a === window); // true
// Examples
// this in function contexts
// The value of the this parameter depends on how the function is called, 
// not on how it's defined.

// An object can be passed as the first argument to 'call'
// or 'apply' and 'this' will be bound to it.
const obj = { a: "Custom" };

// Variables declared with var become properties of 'globalThis'.
var a = "Global";
function whatsThis() {
    return this.a; // 'this' depends on how the function is called
}
whatsThis(); // 'Global'; the 'this' parameter defaults to 'globalThis' in non–strict mode
obj.whatsThis = whatsThis;
obj.whatsThis(); // 'Custom'; the 'this' parameter is bound to obj
// Using call() and apply(), you can pass the value of this as if it's 
// an explicit parameter.

function add(c, d) {
    return this.a + this.b + c + d;
}

const o = { a: 1, b: 3 };

// The first argument is bound to the implicit 'this' parameter; the remaining
// arguments are bound to the named parameters.
add.call(o, 5, 7); // 16

// The first argument is bound to the implicit 'this' parameter; the second
// argument is an array whose members are bound to the named parameters.
add.apply(o, [10, 20]); // 34
// this and object conversion
// In non–strict mode, if a function is called with a this value that's not 
// an object, the this value is substituted with an object. null and undefined 
// become globalThis. Primitives like 7 or 'foo' are converted to an object using 
// the related constructor, so the primitive number 7 is converted to a Number 
// wrapper class and the string 'foo' to a String wrapper class.

function bar() {
    console.log(Object.prototype.toString.call(this));
}

bar.call(7); // [object Number]
bar.call("foo"); // [object String]
bar.call(undefined); // [object Window]
// The bind() method
// Calling f.bind(someObject) creates a new function with the same body and 
// scope as f, but the value of this is permanently bound to the first argument 
// of bind, regardless of how the function is being called.

function f() {
    return this.a;
}

const g = f.bind({ a: "azerty" });
console.log(g()); // azerty

const h = g.bind({ a: "yoo" }); // bind only works once!
console.log(h()); // azerty

const o = { a: 37, f, g, h };
console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty
// this in arrow functions
// Arrow functions create closures over the this value of the enclosing execution 
// context.In the following example, we create obj with a method getThisGetter 
// that returns a function that returns the value of this.The returned function 
// is created as an arrow function, so its this is permanently bound to the this 
// of its enclosing function. The value of this inside getThisGetter can be set 
// in the call, which in turn sets the return value of the returned function. 
// We will assume that getThisGetter is a non - strict function, which means 
// it's contained in a non-strict script and not further nested in a class or 
// strict function.

const obj = {
    getThisGetter() {
        const getter = () => this;
        return getter;
    },
};
// We can call getThisGetter as a method of obj, which binds this to obj inside 
// its body.The returned function is assigned to a variable fn.Now, when calling fn, 
// the value of this returned is still the one set by the call to getThisGetter, 
// which is obj.If the returned function was not an arrow function, such calls 
// would cause the this value to be globalThis, because getThisGetter is non - strict.

const fn = obj.getThisGetter();
console.log(fn() === obj); // true
// But be careful if you unbind the method of obj without calling it, because 
// getThisGetter is still a method that has a varying this value.Calling fn2()() 
// in the following example returns globalThis, because it follows the this from fn2(), 
// which is globalThis since it's called without being attached to any object.

const fn2 = obj.getThisGetter;
console.log(fn2()() === globalThis); // true in non-strict mode
// This behavior is very useful when defining callbacks.Usually, each function 
// expression creates its own this binding, which shadows the this value of 
// the upper scope.Now, you can define functions as arrow functions if you don't 
// care about the this value, and only create this bindings where you do (e.g. 
// in class methods). See example with setTimeout().

// this with a getter or setter
// this in getters and setters is based on which object the property is accessed on, 
// not which object the property is defined on.A function used as getter or setter 
// has its this bound to the object from which the property is being set or gotten.

function sum() {
    return this.a + this.b + this.c;
}

const o = {
    a: 1,
    b: 2,
    c: 3,
    get average() {
        return (this.a + this.b + this.c) / 3;
    },
};

Object.defineProperty(o, "sum", {
    get: sum,
    enumerable: true,
    configurable: true,
});

console.log(o.average, o.sum); // 2 6
// this in DOM event handlers
// When a function is used as an event handler, its this parameter is bound 
// to the DOM element on which the listener is placed(some browsers do not 
// follow this convention for listeners added dynamically with methods other 
// than addEventListener()).

// When called as a listener, turns the related element blue
function bluify(e) {
    // Always true
    console.log(this === e.currentTarget);
    // true when currentTarget and target are the same object
    console.log(this === e.target);
    this.style.backgroundColor = "#A5D9F3";
}

// Get a list of every element in the document
const elements = document.getElementsByTagName("*");

// Add bluify as a click listener so when the
// element is clicked on, it turns blue
for (const element of elements) {
    element.addEventListener("click", bluify, false);
}
// this in inline event handlers
// When the code is called from an inline event handler attribute, its this 
// is bound to the DOM element on which the listener is placed:

// HTML
// Copy to Clipboard
    < button onclick = "alert(this.tagName.toLowerCase());" > Show this</ >
//The above alert shows button.Note, however, that only the outer scope 
// has its this bound this way:

// HTML
// Copy to Clipboard
//     < button onclick = "alert((function () { return this; })());" >
//         Show inner this
// </ >
//In this case, the this parameter of the inner function is bound to 
// globalThis(i.e.the default object in non–strict mode where this isn't 
// passed in the call).

// Bound methods in classes
// Just like with regular functions, the value of this within methods depends 
// on how they are called.Sometimes it is useful to override this behavior 
// so that this within classes always refers to the class instance. To achieve this, 
// bind the class methods in the constructor:

class Car {
    constructor() {
        // Bind sayBye but not sayHi to show the difference
        this.sayBye = this.sayBye.bind(this);
    }

    sayHi() {
        console.log(`Hello from ${this.name}`);
    }

    sayBye() {
        console.log(`Bye from ${this.name}`);
    }

    get name() {
        return "Ferrari";
    }
}

class Bird {
    get name() {
        return "Tweety";
    }
}

const car = new Car();
const bird = new Bird();

// The value of 'this' in methods depends on their caller
car.sayHi(); // Hello from Ferrari
bird.sayHi = car.sayHi;
bird.sayHi(); // Hello from Tweety

// For bound methods, 'this' doesn't depend on the caller
bird.sayBye = car.sayBye;
bird.sayBye(); // Bye from Ferrari
// Note: Classes are always in strict mode.Calling methods with an undefined 
// this will throw an error if the method tries to access properties on this.

const carSayHi = car.sayHi;
carSayHi(); // TypeError because the 'sayHi' method tries to access 'this.name', but 'this' is undefined in strict mode.
// Note, however, that auto - bound methods suffer from the same problem as 
// using arrow functions for class properties: each instance of the class 
// will have its own copy of the method, which increases memory usage.Only 
// use it where absolutely necessary.You can also mimic the implementation 
// of Intl.NumberFormat.prototype.format(): define the property as a getter 
// that returns a bound function when accessed and saves it, so that 
// the function is only created once and only created when necessary.

// this in with statements
// Although with statements are deprecated and not available in strict mode, 
// they still serve as an exception to the normal this binding rules.If 
// a function is called within a with statement and that function is a property 
// of the scope object, the this value is bound to the scope object, as if 
// the obj1.prefix exists.

const obj1 = {
    foo() {
        return this;
    },
};

with (obj1) {
    console.log(foo() === obj1); // true
}

// typeof
//     The typeof operator returns a string indicating the type of the operand's value.

// Try it
console.log(typeof 42);
// Expected output: "number"

console.log(typeof 'blubber');
// Expected output: "string"

console.log(typeof true);
// Expected output: "boolean"

console.log(typeof undeclaredVariable);
// Expected output: "undefined"


// Syntax
typeof operand
// Parameters
// operand
// An expression representing the object or primitive whose type is to be returned.

//     Description
// The following table summarizes the possible return values of typeof.
// For more information about types and primitives, see also the JavaScript 
// data structure page.

// Type	            Result
// Undefined	    "undefined"
// Null	            "object"(reason)
// Boolean	        "boolean"
// Number	        "number"
// BigInt	        "bigint"
// String	        "string"
// Symbol	        "symbol"

// Function(implements[[Call]] in ECMA - 262 terms; classes are functions as well) "function"
// Any other object	"object"
// This list of values is exhaustive.No spec - compliant engines are 
// reported to produce(or had historically produced) values other than those listed.

//     Examples
// Basic usage
// Numbers
typeof 37 === "number";
typeof 3.14 === "number";
typeof 42 === "number";
typeof Math.LN2 === "number";
typeof Infinity === "number";
typeof NaN === "number"; // Despite being "Not-A-Number"
typeof Number("1") === "number"; // Number tries to parse things into numbers
typeof Number("shoe") === "number"; // including values that cannot be type coerced to a number

typeof 42n === "bigint";

// Strings
typeof "" === "string";
typeof "bla" === "string";
typeof `template literal` === "string";
typeof "1" === "string"; // note that a number within a string is still typeof string
typeof typeof 1 === "string"; // typeof always returns a string
typeof String(1) === "string"; // String converts anything into a string, safer than toString

// Booleans
typeof true === "boolean";
typeof false === "boolean";
typeof Boolean(1) === "boolean"; // Boolean() will convert values based on if they're truthy or falsy
typeof !!1 === "boolean"; // two calls of the ! (logical NOT) operator are equivalent to Boolean()

// Symbols
typeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";

// Undefined
typeof undefined === "undefined";
typeof declaredButUndefinedVariable === "undefined";
typeof undeclaredVariable === "undefined";

// Objects
typeof { a: 1 } === "object";

// use Array.isArray or Object.prototype.toString.call
// to differentiate regular objects from arrays
typeof [1, 2, 4] === "object";

typeof new Date() === "object";
typeof /regex/ === "object";

// The following are confusing, dangerous, and wasteful. Avoid them.
typeof new Boolean(true) === "object";
typeof new Number(1) === "object";
typeof new String("abc") === "object";

// Functions
typeof function () { } === "function";
typeof class C { } === "function";
typeof Math.sin === "function";
typeof null

// This stands since the beginning of JavaScript
typeof null === "object";
// In the first implementation of JavaScript, JavaScript values were 
// represented as a type tag and a value.The type tag for objects was 0.
//  null was represented as the NULL pointer(0x00 in most platforms).
// Consequently, null had 0 as type tag, hence the typeof return value "object". 
// (reference)

// A fix was proposed for ECMAScript(via an opt -in), but was rejected.It 
// would have resulted in typeof null === "null".

// Using new operator
// All constructor functions called with new will return non - primitives
// ("object" or "function").Most return objects, with the notable exception 
// being Function, which returns a function.

const str = new String("String");
const num = new Number(100);

typeof str; // "object"
typeof num; // "object"

const func = new Function();

typeof func; // "function"
// Need for parentheses in syntax
// The typeof operator has higher precedence than binary operators like addition(+).
// Therefore, parentheses are needed to evaluate the type of an addition result.

// Parentheses can be used for determining the data type of expressions.
const someData = 99;
typeof someData + " Wisen"; // "number Wisen"
typeof (someData + " Wisen"); // "string"
// Interaction with undeclared and uninitialized variables
// typeof is generally always guaranteed to return a string for any operand it 
// is supplied with.Even with undeclared identifiers, typeof will return "undefined" 
// instead of throwing an error.

typeof undeclaredVariable; // "undefined"
// However, using typeof on lexical declarations(let const, and class) in 
// the same block before the place of declaration will throw a ReferenceError.
// Block scoped variables are in a temporal dead zone from the start of the block 
// until the initialization is processed, during which it will throw an error 
// if accessed.

//     JS
// Copy to Clipboard
typeof newLetVariable; // ReferenceError
typeof newConstVariable; // ReferenceError
typeof newClass; // ReferenceError

let newLetVariable;
const newConstVariable = "hello";
class newClass { }
// Exceptional behavior of document.all
// All current browsers expose a non - standard host object document.all with 
// type undefined.

//     JS
// Copy to Clipboard
typeof document.all === "undefined";
// Although document.all is also falsy and loosely equal to undefined, it 
// is not undefined.The case of document.all having type "undefined" is 
// classified in the web standards as a "willful violation" of the original 
// ECMAScript standard for web compatibility.

// Custom method that gets a more specific type
// typeof is very useful, but it's not as versatile as might be required. For 
// example, typeof [] is "object", as well as typeof new Date(), typeof /abc/, etc.

// For greater specificity in checking types, here we present a custom type(value) 
// function, which mostly mimics the behavior of typeof, but for non - primitives
// (i.e.objects and functions), it returns a more granular type name where possible.

function type(value) {
    if (value === null) {
        return "null";
    }
    const baseType = typeof value;
    // Primitive types
    if (!["object", "function"].includes(baseType)) {
        return baseType;
    }

    // Symbol.toStringTag often specifies the "display name" of the
    // object's class. It's used in Object.prototype.toString().
    const tag = value[Symbol.toStringTag];
    if (typeof tag === "string") {
        return tag;
    }

    // If it's a function whose source code starts with the "class" keyword
    if (
        baseType === "function" &&
        Function.prototype.toString.call(value).startsWith("class")
    ) {
        return "class";
    }

    // The name of the constructor; for example `Array`, `GeneratorFunction`,
    // `Number`, `String`, `Boolean` or `MyCustomClass`
    const className = value.constructor.name;
    if (typeof className === "string" && className !== "") {
        return className;
    }

    // At this point there's no robust way to get the type of value,
    // so we use the base implementation.
    return baseType;
}
// For checking potentially non - existent variables that would otherwise throw 
// a ReferenceError, use typeof nonExistentVar === "undefined" because this behavior 
// cannot be mimicked with custom code.

// yield
// The yield operator is used to pause and resume a generator function.

function* foo(index) {
    while (index < 2) {
        yield index;
        index++;
    }
}

const iterator = foo(0);

console.log(iterator.next().value);
// Expected output: 0

console.log(iterator.next().value);
// Expected output: 1

// The yield keyword pauses generator function execution and the value of 
// the expression following the yield keyword is returned to the generator's caller. 
// It can be thought of as a generator-based version of the return keyword.

// yield can only be used directly within the generator function that contains it.
// It cannot be used within nested functions.

// Calling a generator function constructs a Generator object.Each time 
// the generator's next() method is called, the generator resumes execution, 
// and runs until it reaches one of the following:

// A yield expression.In this case, the generator pauses, and the next() method 
// return an iterator result object with two properties: value and done.The value 
// property is the value of the expression after the yield operator, and done is 
// false, indicating that the generator function has not fully completed.

// The end of the generator function. In this case, execution of the generator ends, 
// and the next() method returns an iterator result object where the value is 
// undefined and done is true.

// A return statement.In this case, execution of the generator ends, and the next() 
// method returns an iterator result object where the value is the specified return 
// value and done is true.

// A throw statement.In this case, execution of the generator halts entirely, and 
// the next() method throws the specified exception.

// Once paused on a yield expression, the generator's code execution remains paused 
// until the generator's next() method is called again.If an optional value is passed 
// to the generator's next() method, that value becomes the value returned by the 
// generator's current yield operation.The first next() call does not have a 
// corresponding suspended yield operation, so there's no way to get the argument 
// passed to the first next() call.

//     Examples
// Using yield
// The following code is the declaration of an example generator function.
function* countAppleSales() {
    const saleList = [3, 7, 5];
    for (let i = 0; i < saleList.length; i++) {
        yield saleList[i];
    }
}
// Once a generator function is defined, it can be used by constructing an iterator 
// as shown.

const appleStore = countAppleSales(); // Generator { }
console.log(appleStore.next()); // { value: 3, done: false }
console.log(appleStore.next()); // { value: 7, done: false }
console.log(appleStore.next()); // { value: 5, done: false }
console.log(appleStore.next()); // { value: undefined, done: true }
// You can also send a value with next(value) into the generator.step evaluates 
// as a return value of the yield expression — although the value passed to 
// the generator's next() method the first time next() is called is ignored.

function* counter(value) {
    while (true) {
        const step = yield value++;

        if (step) {
            value += step;
        }
    }
}

const generatorFunc = counter(0);
console.log(generatorFunc.next().value); // 0
console.log(generatorFunc.next().value); // 1
console.log(generatorFunc.next().value); // 2
console.log(generatorFunc.next().value); // 3
console.log(generatorFunc.next(10).value); // 14
console.log(generatorFunc.next().value); // 15
console.log(generatorFunc.next(10).value); // 26





























