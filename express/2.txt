// Anatomy of an HTTP Transaction

// The purpose of this guide is to 
// impart a solid understanding of 
// the process of Node.js HTTP handling. 
// We'll assume that you know, in 
// a general sense, how HTTP requests
//  work, regardless of language or 
// programming environment. We'll 
// also assume a bit of familiarity 
// with Node.js EventEmitters and 
// Streams. If you're not quite familiar
//  with them, it's worth taking a 
// quick read through the API docs 
// for each of those.

// Create the Server
// Any node web server application 
// will at some point have to create 
// a web server object. This is done 
// by using createServer.

const http = require('node:http');
const server = http.createServer((request, response) => {
  // magic happens here!
});
// JavaScript
// The function that's passed in 
// to createServer is called once 
// for every HTTP request that's 
// made against that server, so 
// it's called the request handler. 
// In fact, the Server object 
// returned by createServer is 
// an EventEmitter, and what we 
// have here is just shorthand 
// for creating a server object 
// and then adding the listener later.

const server = http.createServer();
server.on('request', (request, response) => {
  // the same kind of magic happens here!
});

// JavaScript
// When an HTTP request hits the 
// server, node calls the request 
// handler function with a few 
// handy objects for dealing 
// with the transaction, request 
// and response. We'll get to 
// those shortly.

// In order to actually serve 
// requests, the listen method 
// needs to be called on the 
// server object. In most cases, 
// all you'll need to pass to 
// listen is the port number you 
// want the server to listen on.

// There are some other options too, 
// so consult the API reference.

// Method, URL and Headers -> 
// When handling a request, the 
// first thing you'll probably want 
// to do is look at the method and 
// URL, so that appropriate actions 
// can be taken. Node.js makes this 
// relatively painless by putting 
// handy properties onto the 
// request object.

const { method, url } = request;
// JavaScript
// The request object is an 
// instance of IncomingMessage.

// The method here will always 
// be a normal HTTP method/verb. 
// The url is the full URL without 
// the server, protocol or port. 
// For a typical URL, this means 
// everything after and including 
// the third forward slash.

// Headers are also not far away. 
// They're in their own object on 
// request called headers.

const { headers } = request;
const userAgent = headers['user-agent'];

// It's important to note here 
// that all headers are represented 
// in lower-case only, regardless of 
// how the client actually sent them. 


// If some headers are repeated, 
// then their values are overwritten 
// or joined together as comma-separated 
// strings, depending on the header. 

// Request Body
// When receiving a POST or PUT request, 
// the request body might be important 
// to your application. Getting at the 
// body data is a little more involved 
// than accessing request headers. The 
// request object that's passed in to 
// a handler implements the 
// ReadableStream interface. This 
// stream can be listened to or piped 
// elsewhere just like any other stream. 
// We can grab the data right out of the 
// stream by listening to the stream's 
// 'data' and 'end' events.

// The chunk emitted in each 'data' 
// event is a Buffer. If you know it's 
// going to be string data, the best 
// thing to do is collect the data 
// in an array, then at the 'end',
//  concatenate and stringify it.

let body = [];
request
  .on('data', chunk => {
    body.push(chunk);
  })
  .on('end', () => {
    body = Buffer.concat(body).toString();
    // at this point, `body` has the entire request body stored in it as a string
  });


// JavaScript
// This may seem a tad tedious, 
// and in many cases, it is. Luckily, 
// there are modules like concat-stream 
// and body on npm which can help hide 
// away some of this logic. It's 
// important to have a good understanding 
// of what's going on before going down 
// that road, and that's why you're here!

// A Quick Thing About Errors
// Since the request object is a 
// ReadableStream, it's also an 
// EventEmitter and behaves like 
// one when an error happens.

// An error in the request stream 
// presents itself by emitting an 
// 'error' event on the stream. 
// If you don't have a listener 
// for that event, the error will 
// be thrown, which could crash 
// your Node.js program. You should 
// therefore add an 'error' listener 
// on your request streams, even if 
// you just log it and continue on 
// your way. (Though it's probably 
// best to send some kind of HTTP 
// error response. More on that later.)

request.on('error', err => {
  // This prints the error message and stack trace to `stderr`.
  console.error(err.stack);
});
// JavaScript
// There are other ways of 
// handling these errors such 
// as other abstractions and tools, 
// but always be aware that errors 
// can and do happen, and you're 
// going to have to deal with them.

// What We've Got so Far
// At this point, we've covered 
// creating a server, and grabbing 
// the method, URL, headers and body 
// out of requests. When we put that 
// all together, it might look 
// something like this:

const http = require('node:http');
http
  .createServer((request, response) => {
    const { headers, method, url } = request;
    let body = [];
    request
      .on('error', err => {
        console.error(err);
      })
      .on('data', chunk => {
        body.push(chunk);
      })
      .on('end', () => {
        body = Buffer.concat(body).toString();
        // At this point, we have the headers, method, url and body, and can now
        // do whatever we need to in order to respond to this request.
      });
  })
  .listen(8080); // Activates this server, listening on port 8080.


// JavaScript
// If we run this example, 
// we'll be able to receive requests, 
// but not respond to them. In fact, 
// if you hit this example in a web 
// browser, your request would time out, 
// as nothing is being sent back to the client.

// So far we haven't touched on 
// the response object at all, which 
// is an instance of ServerResponse, 
// which is a WritableStream. It 
// contains many useful methods for 
// sending data back to the client. 
// We'll cover that next.

// HTTP Status Code
// If you don't bother setting it, 
// the HTTP status code on a response 
// will always be 200. Of course, not 
// every HTTP response warrants this, 
// and at some point you'll definitely 
// want to send a different status code. 
// To do that, you can set 
// the statusCode property.

response.statusCode = 404; // Tell the client that the resource wasn't found.
// JavaScript

// There are some other 
// shortcuts to this, 
// as we'll see soon.

// Setting Response Headers
// Headers are set through 
// a convenient method called 
// setHeader.

response.setHeader('Content-Type', 'application/json');
response.setHeader('X-Powered-By', 'bacon');
// JavaScript

// When setting the headers on 
// a response, the case is insensitive
//  on their names. If you set a 
// header repeatedly, the last value 
// you set is the value that gets sent.

// Explicitly Sending Header Data
// The methods of setting the headers 
// and status code that we've already 
// discussed assume that you're using 
// "implicit headers". This means 
// you're counting on node to send 
// the headers for you at the correct 
// time before you start sending body data.

// If you want, you can explicitly 
// write the headers to the response 
// stream. To do this, there's a method 
// called writeHead, which writes the 
// status code and the headers to 
// the stream.

response.writeHead(200, {
  'Content-Type': 'application/json',
  'X-Powered-By': 'bacon',
});
// JavaScript


// Once you've set the headers 
// (either implicitly or explicitly), 
// you're ready to start sending 
// response data.

// Sending Response Body
// Since the response object is 
// a WritableStream, writing a 
// response body out to the client 
// is just a matter of using 
// the usual stream methods.

response.write('<html>');
response.write('<body>');
response.write('<h1>Hello, World!</h1>');
response.write('</body>');
response.write('</html>');
response.end();
// JavaScript

// The end function on streams 
// can also take in some optional 
// data to send as the last bit 
// of data on the stream, so we 
// can simplify the example 
// above as follows.

response.end('<html><body><h1>Hello, World!</h1></body></html>');
// JavaScript

// It's important to set the 
// status and headers before 
// you start writing chunks 
// of data to the body. This 
// makes sense, since headers 
// come before the body in 
// HTTP responses.

// Another Quick Thing About Errors
// The response stream can also 
// emit 'error' events, and at 
// some point you're going to 
// have to deal with that as 
// well. All of the advice for 
// request stream errors still 
// applies here.

// Put It All Together
// Now that we've learned about 
// making HTTP responses, let's 
// put it all together. Building 
// on the earlier example, we're 
// going to make a server that 
// sends back all of the data that 
// was sent to us by the user. 
// We'll format that data as 
// JSON using JSON.stringify.

const http = require('node:http');
http
  .createServer((request, response) => {
    const { headers, method, url } = request;
    let body = [];
    request
      .on('error', err => {
        console.error(err);
      })
      .on('data', chunk => {
        body.push(chunk);
      })
      .on('end', () => {
        body = Buffer.concat(body).toString();
        // BEGINNING OF NEW STUFF
        response.on('error', err => {
          console.error(err);
        });
        response.statusCode = 200;
        response.setHeader('Content-Type', 'application/json');
        // Note: the 2 lines above could be replaced with this next one:
        // response.writeHead(200, {'Content-Type': 'application/json'})
        const responseBody = { headers, method, url, body };
        response.write(JSON.stringify(responseBody));
        response.end();
        // Note: the 2 lines above could be replaced with this next one:
        // response.end(JSON.stringify(responseBody))
        // END OF NEW STUFF
      });
  })
  .listen(8080);


// JavaScript
// Echo Server Example
// Let's simplify the previous 
// example to make a simple echo 
// server, which just sends whatever 
// data is received in the request 
// right back in the response. 
// All we need to do is grab the 
// data from the request stream 
// and write that data to the 
// response stream, similar to 
// what we did previously.

const http = require('node:http');
http
  .createServer((request, response) => {
    let body = [];
    request
      .on('data', chunk => {
        body.push(chunk);
      })
      .on('end', () => {
        body = Buffer.concat(body).toString();
        response.end(body);
      });
  })
  .listen(8080);
// JavaScript

// Now let's tweak this. 
// We want to only send an 
// echo under the following 
// conditions:

// The request method is POST.
// The URL is /echo.
// In any other case, we 
// want to simply respond with a 404.

const http = require('node:http');
http
  .createServer((request, response) => {
    if (request.method === 'POST' && request.url === '/echo') {
      let body = [];
      request
        .on('data', chunk => {
          body.push(chunk);
        })
        .on('end', () => {
          body = Buffer.concat(body).toString();
          response.end(body);
        });
    } else {
      response.statusCode = 404;
      response.end();
    }
  })
  .listen(8080);


// JavaScript
// By checking the URL in 
// this way, we're doing a 
// form of "routing". Other 
// forms of routing can be as 
// simple as switch statements 
// or as complex as whole frameworks 
// like express. If you're looking 
// for something that does routing 
// and nothing else, try router.

// Great! Now let's take a stab 
// at simplifying this. Remember, 
// the request object is a 
// ReadableStream and the response 
// object is a WritableStream. That 
// means we can use pipe to direct 
// data from one to the other. 
// That's exactly what we want 
// for an echo server!

const http = require('node:http');
http
  .createServer((request, response) => {
    if (request.method === 'POST' && request.url === '/echo') {
      request.pipe(response);
    } else {
      response.statusCode = 404;
      response.end();
    }
  })
  .listen(8080);
// JavaScript
// Yay streams!

// We're not quite done yet though. 
// As mentioned multiple times in 
// this guide, errors can and do 
// happen, and we need to deal with them.

// To handle errors on the request 
// stream, we'll log the error to 
// stderr and send a 400 status code 
// to indicate a Bad Request. In a 
// real-world application, though, 
// we'd want to inspect the error 
// to figure out what the correct 
// status code and message would be. 
// As usual with errors, you should 
// consult the Error documentation.

// On the response, we'll just 
// log the error to stderr.

const http = require('node:http');
http
  .createServer((request, response) => {
    request.on('error', err => {
      console.error(err);
      response.statusCode = 400;
      response.end();
    });
    response.on('error', err => {
      console.error(err);
    });
    if (request.method === 'POST' && request.url === '/echo') {
      request.pipe(response);
    } else {
      response.statusCode = 404;
      response.end();
    }
  })
  .listen(8080);
  
// JavaScript
// We've now covered most of
// the basics of handling HTTP
// requests. At this point,
// you should be able to:

// Instantiate an HTTP server
// with a request handler
// function, and have it
// listen on a port.

// Get headers, URL, method
// and body data from request objects.

// Make routing decisions
// based on URL and/or other
// data in request objects.

// Send headers, HTTP status
// codes and body data via
// response objects.

// Pipe data from request
// objects and to response objects.

// Handle stream errors in
// both the request and
// response streams.

// From these basics, Node.js HTTP
// servers for many typical use
// cases can be constructed. There
// are plenty of other things these
// APIs provide, so be sure to read
// through the API docs for
// EventEmitters, Streams, and HTTP.


// Express.js  is a powerful framework for node.js. 
// One of the main advantages of this framework 
// is defining different routes or middleware to 
// handle the clientâ€™s different incoming requests. 
// In this article, we will discuss, how to use 
// the router in the express.js server.

flg
// Syntax:
express.Router( [options] )

npm install express


// Step 1: Inside route folder create Home.js file 
// which will handle â€˜/homeâ€™ URL.

// home.js 
// Importing express module 
const express = require("express")
const router = express.Router()

// Handling request using router 
router.get("/home", (req, res, next) => {
  res.send("This is the homepage request")
})

// Importing the router 
module.exports = router

// Step 2: Now we will create our second route 
// which will be for login and will handle â€˜/loginâ€™ URL.

// login.js 
// Importing the module 
const express = require("express")

// Creating express Router 
const router = express.Router()

// Handling login request 
router.get("/login", (req, res, next) => {
  res.send("This is the login request")
})
module.exports = router
// Step 3: Now inside the index.js file we will import 
// all the created routes and use them.

// index.js 
const express = require("express")
// Importing all the routes 
const homeroute = require("./routes/Home.js")
const loginroute = require("./routes/login")

// Creating express server 
const app = express()

// Handling routes request 
app.use("/", homeroute)
app.use("/", loginroute)
app.listen((3000), () => {
  console.log("Server is Running")
})

// node index.js
// run in terminal 

so now if you type , localhost:3000/home we will land on the home page 
and if localhost:3000/login  we will land on the login page 

// what is middleware in express.js. 
// Express is a routing and Middleware 
// framework for handling the different 
// routing of the webpage and it works 
// between the request and response cycle. 
// Middleware gets executed after the server 
// receives the request and before 
// the controller actions send the response. 
// Middleware has and access to the request 
// object, responses object, and next, it can 
// process the request before the server sends 
// a response. An Express-based application 
// is a series of middleware function calls.

// Advantages of using middleware:

// Middleware can process request objects multiple 
// times before the server works for that request.
// Middleware can be used to add logging 
// and authentication functionality.
// Middleware improves client-side rendering performance.
// Middleware is used for setting some specific HTTP headers.
// Middleware helps for Optimization and better performance.



// Middleware Chaining:
// Middleware can be chained from one to another, 
// Hence creating a chain of functions that are 
// executed in order. The last function sends 
// the response back to the browser. So, before 
// sending the response back to the browser 
// the different middleware process the request.

// The next() function in the express is 
// responsible for calling the next middleware 
// function if there is one.

// Modified requests will be available to 
// each middleware via the next function:

app.get(path, (req, res, next) => { }, (req, res) => { })
// Middleware functions take 3 arguments: 
// the request object, the response object, 
// and the next function in the applicationâ€™s 
// request-response cycle, i.e., two objects
//  and one function.

// Steps to use Middleware in Express:

npm init - y

// Step 2: Install two dependencies using the following command.
npm install express nodemon

// Step 3: In the scripts section of the package.json file, 
// add the following code line.

// "start": "nodemon index.js"

// Step 4: Create an index.js file in the directory. 
// Make sure that it is not inside any subdirectories 
// of the directory you are working in.

// The updated dependencies in package.json file will look like:
// "dependencies": {
//     "express": "^4.18.2",
// }

const express = require("express");
const app = express();

const port = process.env.port || 3000;
app.get("/", (req, res) => {
    res.send(`<div>
    <h2>Welcome to GeeksforGeeks</h2>
    <h5>Tutorial on Middleware</h5>
  </div>`);
});
app.listen(port, () => {
    console.log(`Listening to port ${port}`);
});

// npm start
//  Creating a Middleware in the app.get() function, 
// modify accordingly to the following code.

app.get(
    "/",
    (req, res, next) => {
        console.log("hello");
        next();
    },
    (req, res) => {
        res.send(
            `<div>
                <h2>Welcome to GeeksforGeeks</h2>
                <h5>Tutorial on Middleware</h5>
            </div>`
        );
    }
);

Routing in ExpressJS is used 
// to subdivide and organize the web application 
// into multiple mini-applications each having 
// its own functionality. It provides more 
// functionality by subdividing the web application
//  rather than including all of the functionality 
// on a single page. These mini-applications combine
//  together to form a web application. Each route 
// in Express responds to a client request to 
// a particular route/endpoint and 
// an HTTP request method (GET, POST, PUT, DELETE, UPDATE and so on). 
// Each route basically refers to the different URLs in the website. 
// So when a URL (Eg: www.geeksforgeeks.org/login) matches
//  a route then the function associated with 
// that specific route is executed (In this case, 
// the function redirects the user to the login page of GeeksforGeeks). 
// How it is done in Express ? 
// Express Router is used to define mini-applications 
// in Express so that each endpoint/route can be dealt 
// in more detail. So, first, we will need to include 
// express into our application.

// Method 1: 
// Without using Router: Instead of using express.router,
//  we make use of app.method (route, function) Example:


const express = require("express"); 
const app = express(); 
  
app.get("/", function(req, res) { 
  res.send("This is a get request!!\n"); 
}); 
app.post("/", function(req, res) { 
  res.send("This is a post request!!\n"); 
}); 
  
app.put("/", function(req, res) { 
  res.send("This is a put request!!\n"); 
}); 
  
app.get("/hey", function(req, res) { 
  res.send("This is a get request to '/hey'!!\n"); 
}); 
  
app.listen(3000); 


// Output:Method 2: Using the Router: We can make 
// use of express.router to simplify our code. 
// Instead of specifying the path every time for 
// a specific request, we just have to specify 
// the path once and then we can chain 
// the request methods to that path using 
// the express router. The .all will be applied 
// to all types of request methods. While 
// the rest of them will be applied based 
// on the request method. Example:

const express = require('express');
const Router = express.Router();

Router.route('/')
  .all((req, res, next) => {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    next();
  })
  .get((req, res, next) => {
    res.end('When a GET request is made, then this '
      + 'is the response sent to the client!');
  })
  .post((req, res, next) => {
    res.end('When a POST request is made, then this '
      + 'is the response sent to the client!');
  })
  .put((req, res, next) => {
    res.end('When a PUT request is made, then this '
      + 'is the response sent to the client!');
  })
  .delete((req, res, next) => {
    res.end('When a DELETE request is made, then this '
      + 'is the response sent to the client!');
  });

module.exports = Router;
// Letâ€™s save this file as test.js Now we make 
// use of the express router in index.js file as follows:

const express = require('Express');
const app = express();

const test = require('./test.js');

app.use('/test', test);

app.listen(3000);
// Note: index.js and test.js should be in the same directory.



// How are req and res Objects Useful?
// Both the objects â€˜reqâ€˜ and â€˜resâ€˜ are responsible 
// for handling the HTTP requests and responses in 
// the web applications.

// Steps to use req and res objects in Express

mkdir http-objects
cd http-objects

npm init -y

npm i express

// The updated dependencies in package.json file will look like:

// "dependencies": {
//     "express": "^4.18.2"
// }

// app.js 

const express = require("express");
const app = express();
const port = 3000;
// defining a simple middleware to log requests
app.use((req, res, next) => {
  console.log(`Incoming Request: ${req.method} ${req.url}`);
  next(); // calling the next middleware or route handler
});
app.get("/favicon.ico", (req, res) => {
  res.status(204).end(); // No content for favicon.ico
});
// route handling using req and res objects
app.get("/greet/:name", (req, res) => {
  // accessing URL parameters using req.params
  const geekName = req.params.name;
  // sending a customized HTML response
  const htmlResponse = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, 
        initial-scale=1.0">
      <title>Greeting Page</title>
    </head>
    <body>
      <h1>Hello, ${geekName}!</h1>
    </body>
    </html>
  `;
  // logging the response in the terminal
  console.log(`Outgoing Response: ${res.statusCode} ${res.statusMessage}`);
  // sending the HTML response
  res.send(htmlResponse);
});
// start the server
app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});


// Start the server -  node app.js

var data = makeAsyncRequest();

// Data is undefined 
console.log("Data is " + data);

// We can say that, when we execute something 
// synchronously, we wait for it to finish before 
// moving on another task. When we execute something
//  asynchronously, we can move on to another task
//  before it finishes. The above problem is solved
//  using callbacks, middleware modules or by using
//  the modern promise and await.

// Template Engine : A template engine basically 
// helps us to use the static template files with
//  minimal code. At runtime, the template engine
//  replaces all the variables with actual 
// values at the client-side.

// Templating Engine Examples:
// EJS (Embedded JavaScript Templating)
// Pug
// Mustache

// we are going to use EJS engine.

npm init -y
npm install ejs express --save

// Basic ExpressJS Server:
const express = require('express');
const app = express();


app.get('/', (req, res) => {
    res.send("GeeksforGeeks");
})

app.listen(4000, () => {
    console.log("server is running on port 4000");
})

// Adding/setting of EJS Engine: Here we need to 
// set ejs as our view engine.
const express = require('express');
const app = express();

app.set('view engine', 'ejs');

app.get('/', (req, res) => {
    res.send("GeeksforGeeks");
})

app.listen(4000, () => {
    console.log("server is running on port 4000");
})

Output:
GeeksforGeeks


Adding of EJS Engine: Here we need to set ejs as our view engine.
js 
const express = require('express'); 
const app = express(); 

app.set('view engine', 'ejs'); 

app.get('/' , (req , res)=>{ 
	res.send("GeeksforGeeks"); 
}) 

app.listen(4000 , ()=>{ 
	console.log("server is running on port 4000"); 
})


Filename: index.ejs
<!--Ejs File-->
<!DOCTYPE html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8"> 
	<meta http-equiv="X-UA-Compatible" content="IE=edge"> 
	<meta name="viewport"
		content="width=device-width, initial-scale=1.0"> 
</head> 
<body> 
	<h1>GeeksforGeeks</h1> 
</body> 
</html> 


Rendering of EJS file:
const express = require('express'); 
const app = express(); 

app.set('view engine', 'ejs'); 

app.get('/:name' , (req , res)=>{ 
	res.render("index" , { 
		data : req.params.name 
	}); 
}) 

app.listen(4000 , ()=>{ 
	console.log("server is running on port 4000"); 
})


Storing of data :  Here we have to store the data var name = "<%= data %>".
var name = "<%= data %>"
        setTimeout(()=>{ 
        document.getElementById('hello').innerHTML = name; 
        },1000); 

output
at localhost:4000/Geek
Hello geek


// How to serve static files in Express JS ?
we are going to learn how we 
// can serve static files using Express. Static files
//  are those files whose data are the same and whose
//  content is constant and does not change
//  express.static middleware which helps to 
// developer to send static file to client side.
// we are going to use 
// the built-in middleware of Express called
//  express.static, which is used to server static files. 
// Express.static is a built-in feature of Express JS 
// Path module is used in it to join the path 
// from public directory to the required file.


// Syntax:
app.use(express.static(path.join(__dirname, 'public')));

// This middleware will convert your root folder into 
// an argument and return a function that you can 
// use in your server-side application. 

// Steps to create application:
// Step 1 : Make a root directory for server side code.
mkdir root

// Step 2 : Initialize Node App using the given command.
npm init -y

// Step 3 : Create entry point file and 
// other required directories like public.

// Step 4 : Install the required modules via given command.
npm i express

// The updated dependencies in package.json file will look like:
// "dependencies": {
//     "express": "^4.18.2"
//   }

// Example : This example uses express.static to serve 
// a static CSS file to the Express server
const express = require('express');
const path = require('path');

const app = express();
const PORT = 3000;
app.use(express.static(path.join(__dirname, 'public')));

app.get('/', (req, res) => {
    res.send('Hello Geek');
});

app.listen(PORT, () => {
    console.log(`Server Established at PORT->${PORT}`);
});
// Output:
// at localhost:3000/demo.css


// How to enable debugging in Express App ?
// In express, there is a module present 
// called DEBUG that gives log information. 
// It tells about middleware functions,
//  application mode, their status, and
//  also about the requests and responses
//  made to the server.

// In the package.json file set your start command 
// as shown and run npm start.

"scripts": {
   "start": "set DEBUG=express:* & node index.js"    
}

// You can also use more than one option at 
// a time to debug them together by separating 
// them by commas. Example:

$ DEBUG=mail,express:* node index.js

// Debug environment variables

// Suppose you want the logs to be visible in 
// a different manner. Suppose you donâ€™t want 
// the colors to appear or you want to see some
//  hidden information, you can do that by 
// setting environment variables. 
// Some of these variables are:

// DEBUG: Select the namespaces for which you want to see the logs.
// DEBUG_COLORS: By setting this to either 1 or 0 you can decide whether 
//the logs that will be visible will be in different colors or the same 
//white color. If you set DEBUG_COLORS to 0 the logs will appear in 
// white plain text. By default, it is set to 0.
// DEBUG_HIDE_DATE: This can hide the date from debug output.
// DEBUG_SHOW_HIDDEN: This shows hidden properties on inspected objects.


// Express JS express.json() Function
// The express.json() function is a built-in 
// middleware function in Express. It parses 
// incoming requests with JSON payloads and
//  is based on body-parser. 
        // The express.json() middleware is used 
        // to parse incoming requests with JSON payloads.
        // It means  specifically focuses on requests where 
        // the Content-Type header matches the 
        // specified type (which is JSON).
        // When a client sends an HTTP request 
        // with a JSON payload (usually in
        //  the request body), the express.json() 
        // middleware kicks in.
        // It extracts the JSON data from 
        // the request body and parses 
        // it into a JavaScript object.
        // The parsed data is then available 
        // in the req.body object for further 
        // processing by your application.
        // The express.json() middleware is 
        // built upon the body-parser package.
// To enable JSON parsing for incoming requests, 
// add the following line to your Express app:
const express = require('express');
const app = express();
flg
// Enable JSON parsing middleware
app.use(express.json());


        // Itâ€™s like a helper function 
        // for your Express app.
        // When someone sends data (like a message in form of the req obj) 
        // to your app, it might be in a special 
        // format called JSON (kind of like a structured text).
        // The express.json() function helps your
        //  app understand that special format.
        // It takes the incoming data (the JSON) 
        // and turns it into something your app 
        // can easily work with (like a regular JavaScript object).
        // Imagine youâ€™re receiving a package. 
        // The package is wrapped in a fancy paper (JSON).
        // The express.json() function unwraps 
        // the paper, so you can see whatâ€™s 
        // inside (the actual data).
        // Now you can read the message or use 
        // the contents of the package in your app!


// Syntax:
express.json([options])

// Parameters: The options parameter 
// has various properties like 
// inflate, limit, type, etc. 

// Example 1: Below is the code example of the express.json().

const express = require('express');
const app = express();
const PORT = 3000;

app.use(express.json());

app.post('/', function (req, res) {
    console.log(req.body.name)
    res.end();
})

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});

 //Run the index.js file using - node index.js
// Output: Now make a POST request to http://localhost:3000/ 
// with header set to â€˜content-type: application/jsonâ€™ 
// and body {â€œnameâ€:â€GeeksforGeeksâ€}, then you will 
// see the following output on your console:

// Server listening on PORT 3000
// GeeksforGeeks

// Example 2: Below is the code example of the express.json().


const express = require('express');
const app = express();
const PORT = 3000;

// Without this middleware 
// app.use(express.json()); 
app.post('/', function (req, res) {
    console.log(req.body.name)
    res.end();
})

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});

// node index.js
// Output: Now make a POST request to http://localhost:3000/ 
// with header set to â€˜content-type: application/jsonâ€™ and
//  body {â€œnameâ€:â€GeeksforGeeksâ€}, then you will see 
// the following output on your console:

// Server listening on PORT 3000
// TypeError: Cannot read property 'name' of undefined


// and the last thing is ,  - why the post method 
// is used to demonstrate the working of express.json , 
// why the .get does not work ?

// POST: Used to send data to the server. 
// It includes data in the request body
//  (not visible in the URL).


// Express Middleware:
        // In Express, middleware functions are 
        // used to process requests and responses.
        // Middleware functions can be added using
        //  app.use() or specific route handlers
        //  like app.get(), app.post(), etc.
        // Middleware functions execute in the
        //  order they are added.

// express.json() Middleware
        // The express.json() middleware is used to 
        // parse incoming JSON requests and populate
        //  req.body with the parsed data.
        // Itâ€™s commonly used for handling data sent 
        // via POST requests (e.g., form submissions, API calls).
        // When a client sends JSON data in 
        // the request body, express.json() parses 
        // it and makes it accessible in req.body.

// Why POST for express.json()?:
        // POST requests are often used for sending 
        // data that needs to be processed or 
        // stored on the server.
        // When demonstrating express.json(), we want 
        // to show how to handle incoming JSON data. 
        // The POST method is more suitable for this purpose.

// Hereâ€™s why:
        // GET requests typically donâ€™t have a request body. 
        // They carry data in the URL (query parameters). 
        // Therefore, express.json() is not relevant for GET requests.
        // 
        // POST requests, on the other hand, allow us 
        // to send data in the request body. By using
        //  app.post(), we can demonstrate how to handle
        //  JSON data using express.json().

// Example:
        // In your provided code snippet, youâ€™re using 
        // app.post('/') to handle incoming requests.
        // When you make a POST request to your server
        //  (e.g., using Axios or any other client),
        //  the data in the request body will be 
        // parsed by express.json().
        // If you were to use app.get('/') instead, 
        // the request would not have a request body, 
        // and express.json() would not be relevant.

// Express.js express.raw() Function
// The express.raw() function is a built-in 
// middleware function in Express. 
// It parses incoming request payloads 
// into a Buffer and is based on body-parser. 
// a payload refers to the data that is sent 
// from a client (usually a browser or 
// another application) to a server.
// When a client makes an HTTP request 
// (such as a POST request), it can include
//  data in the request body. This data is the payload.
// The payload can be in various formats, 
// including JSON, XML, form data, or 
// even binary data.
// buffer alllocates memory .

// Syntax:
express.raw( [options] )

// Parameter: The options parameter contains 
// various properties like inflate, limit, type, etc. 


const express = require('express');
const app = express();
const PORT = 3000;

app.use(express.raw());
 
app.post('/', function (req, res) {
    console.log(req.body);
    res.end();
})
 
app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});

// Steps to run the program: - 
// node index.js


// Now make a POST request to http://localhost:3000/ 
// with header set to â€˜content-typeâ€™ â€“ â€˜application/octet-streamâ€™
//  and body { â€œnameâ€:â€GeeksforGeeksâ€ }, then you will see 
// the following output on your screen:
// a buffer object . 

// the body containing binary data (e.g., an image),
//  express.raw() will parse it into a Buffer.
// You can then process this raw data as needed.

// Yes, the data sent by the user in the request 
// body will be parsed and stored in memory as a Buffer.
// Keep in mind that large payloads can consume 
// significant memory. Itâ€™s essential to handle 
// memory efficiently, especially when dealing
//  with large files.

// Remember:
// express.raw() is particularly useful when 
// you expect binary data (e.g., images, files) 
// in your requests.
// It simplifies handling raw data by converting 
// it into a Buffer for further processing.

// The term â€œbufferâ€ refers to a region of 
// memory used to temporarily hold data.
// When a client sends data (such as an image, 
// audio file, or custom binary data) in 
// a binary format, express.raw() parses 
// it into a Buffer.
// The Buffer class in Node.js 
// represents raw binary data.


// Example 2: Filename: index.js 
const express = require('express');
const app = express();
const PORT = 3000;
 
// Without this middleware
// app.use(express.raw());
app.post('/', function (req, res) {
    console.log(req.body);
    res.end();
})
 
app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});


// Run the index.js file using the below command:

// node index.js
// Now make a POST request to http://localhost:3000/ 
// with header set to â€˜content-typeâ€™ â€“ â€˜application/octet-streamâ€™
//  and body { â€œnameâ€:â€GeeksforGeeksâ€ }, then you will see 
// the following output on your screen:


// Output:
// Server listening on PORT 3000
// undefined


// Express express.Router() Function

// The express.Router() function is used 
// to create a new router object.in 
// your program to handle requests. 

express.Router( [options] )
// case-sensitive: This enables case sensitivity.
// mergeParams: It preserves the req.params values from the parent router.
// strict: This enables strict routing.

const express = require('express');
const app = express();
const PORT = 3000;

// Single routing
const router = express.Router();

router.get('/', function (req, res, next) {
    console.log("Router Working");
    res.end();
})

app.use(router);

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});

Output:

Console Output:

Server listening on PORT 3000

Browser Output:

Now open your browser and go to http://localhost:3000/, you will see the following output on your screen:

Server listening on PORT 3000
Router Working

const express = require('express');
const app = express();
const PORT = 3000;

// Multiple routing
const router1 = express.Router();
const router2 = express.Router();
const router3 = express.Router();

router1.get('/user', function (req, res, next) {
	console.log("User Router Working");
	res.end();
});

router2.get('/admin', function (req, res, next) {
	console.log("Admin Router Working");
	res.end();
});

router3.get('/student', function (req, res, next) {
	console.log("Student Router Working");
	res.end();
});

app.use(router1);
app.use(router2);
app.use(router3);

app.listen(PORT, function (err) {
	if (err) console.log(err);
	console.log("Server listening on PORT", PORT);
});


Steps to run the  program: Run the index.js file using the below command:

node index.js
Now make a GET request to http://localhost:3000/user, http://localhost:3000/admin, and http://localhost:3000/student, then you will see the following output on your console:

Output:

Server listening on PORT 3000
User Router Working
Admin Router Working
Student Router Working


// Express express.static() Function
// The express.static() function is a built-in 
// middleware function in Express. It serves 
// static files and is based on serve-static. 

// What Are Static Files?:
// Static files are files that donâ€™t change 
// dynamically based on user interactions or server-side logic.
// Examples of static files include:
// Images: JPEG, PNG, GIF files.
// Stylesheets: CSS files.
// JavaScript files: Used for client-side scripting.
// HTML files: Web pages that remain constant.

// 2. **Purpose of `express.static()`**:
//    - The `express.static()` middleware 
//      is used to **serve static files** 
//      (such as images, stylesheets, and 
//    JavaScript files) in an Express application.
//    - It allows you to make these files accessible 
//      to clients (like browsers) directly from the server.

// 3. **How It Works**:
//    - When a client (e.g., a browser) requests 
//      a static file (e.g., an image), `express.static()` 
//      looks for that file in a specified directory.
//    - If the file exists, it sends it back to the client as a response.
//    - If the file doesn't exist, it returns 
//      an appropriate HTTP status (e.g., 404 Not Found).

// 4. **Usage Example**:
//    - Let's say you have a directory named **"public"** 
//      containing your static files (images, CSS, etc.).
//    - You can use `express.static('public')` to serve these files.

//    - Here's how you'd set it up:
//      ```javascript
const express = require('express');
const app = express();
const PORT = 3000;

// Serve static files from the 'public' directory
app.use(express.static('public'));

// Example: Access an image at http://localhost:3000/images/kitten.jpg
// The 'public' directory name is not part of the URL
// Express looks up the files relative to the 'public' directory
//  if you make a GET request to
//  http://localhost:3000/images/kitten.jpg, 
// the Express server will serve the file 
// located at public/images/kitten.jpg. 
// The directory name â€œpublicâ€ is not part of the URL; 
// Express automatically looks up the files relative 
// to the specified directory. So, youâ€™ll receive 
// the image file as the response!

app.listen(PORT, () => {
  console.log(`Server listening on PORT ${PORT}`);
});
//      ```

// 5. **Multiple Static Directories**:
//    - You can serve static files from multiple directories 
//      by calling `express.static()` multiple times.
//    - For example:

//      ```javascript
app.use(express.static('public')); // First directory
app.use(express.static('files')); // Second directory
//      ```

// 6. **Virtual Path Prefix**:
//  - You can create a virtual path prefix (where the
//  path doesn't actually exist in the file system)
//  using `express.static()`.
//  - This allows you to serve files from a specific URL path.
//  - Example:

//  ```javascript
app.use('/static', express.static('public'));
// Now, files in 'public' can be accessed from
//  '/static/images/kitten.jpg'
//      ```

// 7. **Absolute Paths**:
//    - When running your Express app from a different directory,
//     use the absolute path to ensure safety and accuracy:

//      ```javascript
const path = require('path');
app.use('/static', express.static(path.join(__dirname, 'public')));
//      ```

// Remember, `express.static()` simplifies serving static 
// files, making your web application more efficient! ðŸš€


// Syntax:

express.static(root, [options])
// Parameters: The root parameter describes the 
// root directory from which to serve static assets. 

// Return Value: It returns an Object. 

// Steps to create the application:
// Step 1: Initialize the express app:

npm init -y
// Step 2: Installing the required packages 
// by using below command.

npm install express ejs
// Project Structure:

// NodeProj
// The updated dependencies in package.json 
// file will look like:

"dependencies": {
    "ejs": "^3.1.9",
    "express": "^4.18.2",
}

//  Example 1: Below is the code example 
// of the express.static() Function


const express = require('express');
const app = express();
const path = require('path');
const PORT = 3000;

// Static Middleware
app.use(express.static(path.join(__dirname, 'public')))

app.get('/', function (req, res, next) {
  res.render('home.ejs');
})

app.listen(PORT, function (err) {
  if (err) console.log(err);
  console.log("Server listening on PORT", PORT);
});

// html 
      // <!DOCTYPE html>
      // <html>
      // <head>
      // 	<title>express.static() Demo</title>
      // </head>
      // <body>
      // 	<h2>Greetings from GeeksforGeeks</h2>
      // 	<img src="Demo.jpg" width="150" height="100" />
      // </body>
      // </html>

// Note: Demo.jpg is placed in the public folder, 
// as the public folder is now being served as 
// static to the server.

// Steps to run the program:
// node index.js

// Console Output:
// Server listening on PORT 3000

// Browser Output: Now open your browser 
// and go to http://localhost:3000/
// Greetings from GeeksforGeeks
// Demo.jpg picture 

//  Example 2: Below is the code example of 
// the express.static() Function
const express = require('express');
const app = express();
const path = require('path');

// Static Middleware
console.log(app.use(express.static(
  path.join(__dirname, 'public'))))
// Steps to run the program:

// node index.js
// Output:

// [Function: app] EventEmitter {
//   _events: [Object: null prototype] { mount: [Function: onmount] },
//   _eventsCount: 1,
//   _maxListeners: undefined,
//   setMaxListeners: [Function: setMaxListeners],
//   getMaxListeners: [Function: getMaxListeners],
//   emit: [Function: emit],
//   .
//   .
//   .
//   .
//   locals: [Object: null prototype] {
//     settings: {
//       'x-powered-by': true,
//       etag: 'weak',
//       'etag fn': [Function: generateETag],
//       env: 'development',
//       'query parser': 'extended',
//       'query parser fn': [Function: parseExtendedQueryString],
//       'subdomain offset': 2,
//       'trust proxy': false,
//       'trust proxy fn': [Function: trustNone],
//       view: [Function: View],
//       views: 'C:\\Users\\Lenovo\\Downloads\\GFG
//         Reviewer Internship\\Program\\views',
//       'jsonp callback name': 'callback'
//     }
//   },
//   mountpath: '/',
//   _router: [Function: router] {
//     params: {},
//     _params: [],
//     caseSensitive: false,
//     mergeParams: undefined,
//     strict: false,
//     stack: [ [Layer], [Layer], [Layer] ]
//   }
// }

// We have a Cheat Sheet on Express Static Functions 
// where we covered all the express static methods 
// to check those please go through Express express() 
// function Complete Reference article.


// Certainly! Let's break down the usage of 
// // `app.use(express.static(path.join(__dirname, 'public')))`, 
// specifically focusing on the `path.join(__dirname, 'public')` part.

// 1. **`__dirname`**:
//    - In Node.js, `__dirname` is a special 
//      variable that represents the **directory name** 
//      of the current module (i.e., the file where it's used).
//    - It provides the **absolute path** to the 
//      directory containing the current script.
//    - For example, if your script is located at
//       `/home/user/myapp/index.js`, then `__dirname` 
//        will be `/home/user/myapp`.

// 2. **`path.join()`**:
//    - The `path.join()` method is part of 
//       the built-in `path` module in Node.js.
//    - It is used to create a **normalized path** 
//      by joining path segments together.
//    - When you pass multiple path segments to 
//      `path.join()`, it combines them into 
//      a single path string using the appropriate 
//      path separator (e.g., `/` or `\`).

// 3. **Putting It Together**:
//    - In your code snippet:
//      ```javascript
     app.use(express.static(path.join(__dirname, 'public')));
  //    ```
  //- The purpose is to serve static files
  //     (such as images, CSS, and JavaScript files) 
  //      from the **"public"** directory.
  //- Here's how it works:
//      - `path.join(__dirname, 'public')` combines 
//        the absolute path represented by `__dirname` 
//        with the relative path `'public'`.
//      - The result is the absolute path to 
//        the **"public"** directory in your project.
//      - Express then serves static files from this directory.

// 4. **Root Directory**:
//    - No, it does not give you the **root directory** 
//      of your entire file system.
//    - Instead, it gives you the absolute path to 
//      the **"public"** directory within your project.
//    - The root directory of your entire file system 
//      is represented by `/` (on Unix-like systems) or `C:\` (on Windows).

// 5. **Example**:
//    - If your project structure looks like this:
//      ```
//      /myapp
//      â”œâ”€â”€ index.js
//      â””â”€â”€ public
//          â”œâ”€â”€ images
//          â”‚   â””â”€â”€ kitten.jpg
//          â””â”€â”€ css
//              â””â”€â”€ style.css
//      ```
//    - The `path.join(__dirname, 'public')` will evaluate 
//      to the absolute path to the **"public"** directory.
//    - When you access
//       [http://localhost:3000/images/kitten.jpg](http://localhost:3000/images/kitten.jpg), Express will serve the `kitten.jpg` file from the **"public"** directory.

// Remember, `path.join(__dirname, 'public')` constructs 
// the path to the specified directory within your project! ðŸš€


// Express.js express.text() Function
// The express.text() function is a built-in 
// middleware function in Express. It parses 
// the incoming request payloads into a string 
// and is based on body-parser.



// Syntax: 
express.text([options])



// Parameter: The options parameters contains 
// various properties like defaultCharset,
//  inflate, limit, verify, etc.

// Return Value: It returns an Object.
// string is a type of an object in js 


// Example 1: Filename: index.js 
const express = require('express');
const app = express();
const PORT = 3000;

app.use(express.text());

app.post('/', function (req, res) {
    console.log(req.body);
    res.end();
})

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});


// node index.js
// Output:

// Console Output: 
// Server listening on PORT 3000

// Browser Output:
// Now make a POST request to http://localhost:3000/ 
// with header set to â€˜content-type: text/plainâ€™ 
// and body {â€œtitleâ€:â€GeeksforGeeksâ€}, then you 
// will see the following output on your console: 

// Server listening on PORT 3000
// {"title":"GeeksforGeeks"} 

// Example 2: Filename: index.js 
const express = require('express');
const app = express();
const PORT = 3000;

// Without this middleware
// app.use(express.text());
app.post('/', function (req, res) {
    console.log(req.body);
    res.end();
})

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});

// node index.js
// Now make a POST request to http://localhost:3000/
// with header set to â€˜content-type: text/plainâ€™ and
//  body {â€œtitleâ€:â€GeeksforGeeksâ€}, then you will
//  see the following output on your console:

// Output:
// Server listening on PORT 3000
// undefined



// Express express.urlencoded() Function
// The express.urlencoded() function is 
// a built-in middleware function in Express. 
// It parses incoming requests with URL-encoded
//  payloads and is based on a body parser.

// Syntax: 
express.urlencoded([options])

// Parameter: The options parameter contains 
// various properties like extended, 
// inflate, limit, verify, etc.


// Example 1: Below is the code example
//  for express.urlencoded() Function
const express = require('express');
const app = express();
const PORT = 3000;

app.use(express.urlencoded({ extended: false }));

app.post('/', function (req, res) {
    console.log(req.body);
    res.end();
});

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});
// Run the index.js file using the below command: 
// node index.js

// Console Output:  

// Server listening on PORT 3000
// Browser Output:  Now make a POST request 
// to http://localhost:3000/ with header set 
// to â€˜content-type: application/x-www-form-urlencodedâ€™ 
// and body {â€œnameâ€:â€GeeksforGeeksâ€}, then you will
//  see the following output on your console: 

//      - When you submit a form to 
//        [http://localhost:3000/](http://localhost:3000/) 
//        with `method="POST"` and URL-encoded data (e.g., `name=Geeks&age=25`),
//         `express.urlencoded()` will parse it.
//      - You can access the form data using `req.body`.

// 5. **Use Cases**:
//    - `express.urlencoded()` is commonly used for 
//      handling form submissions, login forms, and 
//      other scenarios where data is sent from 
//      the client to the server.


// Example 2: Below is the code example 
// for express.urlencoded() Function
const express = require('express');
const app = express();
const PORT = 3000;

// Without this middleware
// app.use(express.urlencoded({extended:false}));

app.post('/', function (req, res) {
    console.log(req.body);
    res.end();
});

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});
// Steps to run the program:

// node index.js
// Now make a POST request to http://localhost:3000/ 
// with header set to â€˜content-type: application/x-www-form-urlencodedâ€™ 
// and body {â€œtitleâ€:â€GeeksforGeeksâ€}, then you will see 
// the following output on your console: 

// Output:
// Server listening on PORT 3000
// undefined


// 2. **How It Works**:
//    - When a client (e.g., a browser) submits an 
//  HTML form with `method="POST"`, the form data 
// is sent in the request body.
//    - The data is **URL-encoded**, meaning it's 
//      formatted as key-value pairs in the URL 
//      (e.g., `name=John&age=30`).
//    - `express.urlencoded()` parses this data and
//       makes it accessible in the `req.body` object.

// 3. **Options**:
//    - The `express.urlencoded()` function accepts 
//      an optional `options` parameter.
//    - Common options include:
//      - `extended`: Determines whether to use the
//       **querystring library** (with `extended: false`) 
//        or the **qs library** (with `extended: true`) for parsing.
//      - Other options include `inflate`, `limit`,
//         `parameterLimit`, and `verify`.

// applicatiion(app) methods 

// Express app.delete() Function
// The `app.delete()` function is utilized 
// to handle HTTP DELETE requests for 
// a specified path.


// Syntax: 
app.delete(path, callback)
// Parameters: 

// path: It is the path for which the middleware function is being called.
// callback: It is a middleware function or a series/array of middleware functions

const express = require('express');
const app = express();
const PORT = 3000;

app.delete('/',
    (req, res) => {
        res.send("DELETE Request Called")
    })

app.listen(PORT,
    function (err) {
        if (err) console.log(err);
        console.log("Server listening on PORT", PORT);
    });


// node index.js

// Console Output:
// Server listening on PORT 3000
// Browser Output: Now make a DELETE request
// to http://localhost:3000/ and you will get
// the following output:

// DELETE Request Called

// 1. **HTTP DELETE Requests**:
//    - In the context of **HTTP methods**, 
//      the **DELETE method** is used to request 
//      that a resource (such as a file or database record) 
//      be removed or deleted from the server.
//    - When a client (e.g., a browser or an API client) 
//      sends an HTTP DELETE request, it indicates 
//      the intention to delete a specific resource.

// 2. **Express Middleware: `app.delete()`**:
//    - The `app.delete()` function is a built-in 
//      middleware function provided by the **Express** framework.
//    - It is used to handle **HTTP DELETE requests** 
//      for a specified path (i.e., URL route).
//    - When a client sends an HTTP DELETE request 
//      to the specified path, the associated 
//      callback function is executed.

const express = require('express');
const app = express();
const PORT = 3000;

// Handle DELETE requests for '/api/users/:id'
app.delete('/api/users/:id', (req, res) => {
    const userId = req.params.id;
    // Logic to delete the user with the specified ID
    // (e.g., remove from a database)
    res.status(204).end(); // Respond with a success status
});

app.listen(PORT, () => {
    console.log(`Server listening on PORT ${PORT}`);
});


//    - In this example:
//      - When a client sends an HTTP DELETE 
//          request to a path like `/api/users/123`, 
//          the associated callback function is executed.
//      - The `req.params.id` contains the value `123`.
//      - You can implement the logic to delete the user 
//          with the specified ID (e.g., remove from a database).
//      - The server responds with a **204 No Content** 
//          status to indicate successful deletion.

// 4. **Common Use Cases**:
//    - `app.delete()` is commonly used for:
//      - Deleting records from a database.
//      - Removing files from a server.
//      - Handling resource deletions in RESTful APIs.

// 5. **Remember**:
//    - The `app.delete()` function is part of 
//      the **Express** routing system, allowing 
//      you to define specific routes for handling DELETE requests.

// Feel free to use `app.delete()` to handle 
//  resource deletions in your Express applications! ðŸš€

// Express.js | app.disable() Function


// The `app.disable()` function in **Express.js** 
// is a convenient way to set a boolean setting 
// to **false**. It serves as a shorthand for
//  `app.set(name, false)`. Essentially, it 
// allows you to disable specific system-level 
// settings within your Express application.

// Here's how it works:

// 1. **System Settings in Express**:
//    - Express has various system-level settings 
//      that control its behavior.
//    - These settings are often boolean flags (either **true** or **false**).

// 2. **Using `app.disable()`**:
//    - When you call `app.disable(name)`, 
//      it sets the specified setting to **false**.
//    - The `name` parameter corresponds to 
//      the specific setting you want to disable.

// 3. **Example**:
//    - Let's say you want to disable 
//      the **"x-powered-by"** header,
//      which indicates the Express version in the response.
//    - You can achieve this using `app.disable('x-powered-by')`.

// 4. **Common Use Cases**:
//    - Some common use cases for `app.disable()` include:
//      - Disabling specific headers (e.g., **"x-powered-by"**, **"etag"**).
//      - Turning off certain features (e.g., **"trust proxy"**, **"strict routing"**).

// 5. **Remember**:
//    - Use `app.disable()` when you want 
//      to explicitly set a system setting to **false**.
//    - It's a cleaner and more readable way to modify Express behavior.


// Filename: index.js 

const express = require('express');
const app = express();

app.disable('trust proxy');

console.log(app.get('trust proxy')); // false

// node index.js
// Output:
// false

// Express.js | app.disabled() Function


// The `app.disabled()` function in 
// **Express.js** serves to return 
// the boolean value of a specified setting.
//  Specifically:

// - If the setting name is **disabled**, it returns **true**.
// - If the setting name is **not disabled**, it returns **false**.

// This function is useful for checking 
// the status of certain system-level 
// settings within your Express application.
//  For example, you can use it to determine 
// whether a specific feature or behavior 
// is currently disabled or not. ðŸš€

// Filename: index.js 
const express = require('express');
const app = express();

console.log(app.disabled('trust proxy')) // true

app.enable('trust proxy')

console.log(app.disabled('trust proxy')) // false

// node index.js
// Output:
// true
// false

// Express.js | app.enable() Function


// The app.enable() function is used to 
// set the boolean value i.e. name to true.
//  It is basically the shorthand for 
// the app.set(name, true) or app.set(name, false). 
// So instead we can use app.enable(name) function 
// to set boolean values to some system Express.js settings.

Filename: index.js 

const express = require('express');
const app = express();
 
app.enable('trust proxy')
 
console.log(app.get('trust proxy')) // true

// Express.js | app.enabled() Function

// The app.enabled() function is used 
// to return the bool values of the setting name. 
// It returns true if the setting name is enabled 
// and returns false if the setting name is not enabled. 

// Syntax:
app.enabled(name)

// Filename: index.js 
const express = require('express');
const app = express();

console.log(app.enabled('trust proxy')) // false

app.enable('trust proxy')

console.log(app.enabled('trust proxy')) // true

// node index.js
// Output:
// false
// true

// Express.js app.mountpath Property

// The app.mountpath property contains one 
// or more path patterns on which a sub-app 
// was mounted. 

// Syntax:
app.mountpath


// The `app.mountpath` property in 
// ** Express.js ** provides information 
// about the path patterns on which a 
// ** sub - app ** was mounted.Let's break it down:

// 1. ** Sub - Apps **:
//    - In Express, you can create 
//      ** sub - applications ** (sub - apps) 
//      using instances of the Express application.
//    - A sub - app is essentially a smaller 
//      Express app that can handle specific 
//      routes or functionality.

// 2. ** Mounting Sub - Apps **:
//    - You can ** mount ** a sub - app onto 
//      a specific route or path within your 
//      main Express app.
//    - For example, you might have a sub - app 
//      that handles authentication routes, and 
//      you want it to be accessible under`/auth`.
//    - By mounting the sub - app, you define 
//      where it should handle requests.

// 3. ** `app.mountpath` **:
//    - The`app.mountpath` property contains one 
//      or more ** path patterns ** on which 
//      a specific sub - app was mounted.
//    - It represents the route pattern where 
//      the sub - app is accessible.
//    - For example, if you mount a sub - app 
//      at`/auth`, `app.mountpath` for that 
//      sub - app will be`/auth`.

const express = require('express');
const app = express();

// Create the authentication sub-app
const authApp = express();
// ... Define authentication routes within authApp ...

// Mount the authApp at /auth
app.use('/auth', authApp);

// Now, authApp is accessible at /auth/login, /auth/register, etc.

// 5. ** Use Cases **:
//    - Sub - apps are useful for modularizing 
//      your Express application.
//    - They allow you to organize routes and 
//      middleware into separate components.

// 6. ** Remember **:
// - The`app.mountpath` property helps you 
//   understand where a specific sub - app 
//   is mounted within your overall Express app.

// Feel free to use sub - apps and explore 
// their mount paths in your Express applications! ðŸš€

// Example 1: Filename: index.js 

// javascript
const express = require('express');
const app = express();  // the main app
const user = express(); // the sub app
const PORT = 3000;

user.get('/', function (req, res) {
    console.log(user.mountpath); // /user
    res.send('User Homepage');
});

app.use('/user', user); // Mounting the sub app

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});

// node index.js
// Output:

// Console Output:

// Server listening on PORT 3000
// Now open your browser and go to http://localhost:3000/user, 
// now you can see the following output on your console:

// Server listening on PORT 3000
// /user


// Example 2: Filename: index.js 
// javascript
const express = require('express');
const app = express();
const PORT = 3000;

app.get('/', function (req, res) {
    console.log(app.mountpath)
    res.send("OK")
});

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});


// node index.js
// Output: Now open your browser and make
// a GET request to http://localhost:3000, now you
// can see the following output on your console:

// Server listening on PORT 3000

// Express.js Mount Event

// The mount event is fired on a sub-app 
// when it is mounted on a parent app and 
// the parent app is basically passed 
// to the callback function. 

// Syntax:
app.on('mount', callback(parent))
// Parameter: It is an event named â€˜mountâ€™, 
// and the callback function is called 
// when this event is called. 

// Return Value: Since itâ€™s an event so 
// it doesnâ€™t have any return value. 

// Example 1: Filename: index.js 
const express = require('express');
const app = express(); // The main app 
const admin = express();
const PORT = 3000;

admin.on('mount', function (parent) {
    console.log('Admin Mounted');
});

admin.get('/', function (req, res) {
    res.send('Admin Homepage');
});

app.use('/admin', admin);

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});


// node index.js
// Output:

// Console Output:
// Admin Mounted
// Server listening on PORT 3000

// Browser Output:
// Now open your browser and go to http://localhost:3000/admin, 
// now you can see the following output on your screen:

// Admin Homepage


// Example 2: Filename: index.js 
const express = require('express');
const app = express(); // The main app 
const student = express();
const teacher = express();
const PORT = 3000;

// Multiple mounting 
teacher.on('mount', function (parent) {
    console.log('Teacher Mounted');
});

student.on('mount', function (parent) {
    console.log('Student Mounted');
});

app.use('/student', student);
app.use('/teacher', teacher);

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT", PORT);
});


// node index.js
// Output: Now open your browser and make a GET request
// to http://localhost:3000, now you can see
// the following output on your console:

// Student Mounted
// Teacher Mounted

// Server listening on PORT 3000

// The `mount` event in ** Express.js ** is triggered 
// when a ** sub - app ** is mounted onto a parent 
// app.Let's break down its purpose and behavior:

// 1. ** Sub - Apps **:
// - In Express, you can create ** sub - applications ** (sub - apps) using instances of the Express application.
//    - A sub - app is essentially a smaller Express app that can handle specific routes or functionality.

// 2. ** Mounting Sub - Apps **:
// - You can ** mount ** a sub - app onto a specific route or path within your main Express app.
//    - For example, you might have a sub - app that handles authentication routes, and you want it to be accessible under`/auth`.
//    - By mounting the sub - app, you define where it should handle requests.

// 3. ** `app.mountpath` Property **:
// - When a sub - app is mounted, the`mount` event is fired.
//    - The`app.mountpath` property contains one or more ** path patterns ** on which the sub - app was mounted.
//    - It represents the route pattern where the sub - app is accessible.

// 4. ** Example **:
// - Suppose you have an authentication sub - app:

// ```javascript
const express = require('express');
const app = express();

// Create the authentication sub-app
const authApp = express();
// ... Define authentication routes within authApp ...

// Mount the authApp at /auth
app.use('/auth', authApp);

// Now, authApp is accessible at /auth/login, /auth/register, etc.
//      ```

// 5. ** Use Cases **:
//    - Sub - apps are useful for modularizing 
//      your Express application.
//    - They allow you to organize routes 
//      and middleware into separate components.

// 6. ** Remember **:
// - The`mount` event helps you understand 
//   when a specific sub - app is mounted 
//   within your overall Express app.

// Feel free to use sub - apps and explore 
// their mount paths in your Express applications! ðŸš€

// The app.mountpath property contains one or 
// more path patterns on which the sub - app was mounted.
// It represents the route pattern where 
// the sub - app is accessible.
//  - i dont understand this, plpease explain this with a example

// Certainly! Let's break down the concept 
// of `app.mountpath` with an example to make it clearer.

// 1. ** Sub - Apps and Mounting **:
//     - In Express, you can create smaller 
//          applications called ** sub - applications ** (sub - apps) 
//          using instances of the Express application.
//     - A sub - app can handle specific routes
//           or functionality independently.

//  2. ** Mounting a Sub - App **:
//      - When you ** mount ** a sub - app, 
//        you attach it to a specific route 
        // or path within your main Express app.
//     - This means that requests to that 
//       specific route will be handled by the sub - app.

//  3. ** `app.mountpath` Property **:
//     - The`app.mountpath` property provides 
//       information about the path patterns 
//       on which a sub - app was mounted.
//     - It represents the ** route pattern ** 
//       where the sub - app is accessible.

//  4. ** Example **:
// - Suppose you have an authentication sub - app:

// ```javascript
const express = require('express');
const app = express();

// Create the authentication sub-app
const authApp = express();
// ... Define authentication routes within authApp ...

// Mount the authApp at /auth
app.use('/auth', authApp);

// Now, authApp is accessible at /auth/login, /auth/register, etc.
//       ```

//     - In this example:
//       - The sub - app(`authApp`) handles authentication - related routes.
//       - It is mounted at the `/auth` route.
//       - So, when a client accesses`/auth/login`, the`authApp` handles the request.

//  5. ** Use Cases **:
//     - Sub - apps are useful for modularizing 
//        your Express application.
//     - They allow you to organize routes and
//       middleware into separate components.

//  6. ** Summary **:
// - Think of`app.mountpath` as the ** route pattern ** 
//   where a specific sub - app is accessible within 
//   your overall Express app.

// it seems like app.mount and app.mountpath are same ??

// Indeed, **`app.mount`** and **`app.mountpath`** 
// serve related purposes, but they are not the same. 
// Let's explore the distinction between them:

// 1. **`app.mount`**:
//    - The `app.mount` function is used to **mount a sub-app** 
//      onto a specific route within the parent Express app.
//    - It allows you to attach a smaller Express app (the sub-app) 
//      to a particular path.

//    - For example:
//      ```javascript
app.mount('/auth', authApp);
//      ```
//      - Here, the `authApp` is mounted at the `/auth` route.

// 2. **`app.mountpath`**:
//    - The `app.mountpath` property provides information 
//      about the **path patterns** on which a sub-app was mounted.
//    - It represents the **route pattern** where the sub-app is accessible.

//    - For instance:
//      ```javascript
console.log(authApp.mountpath); // Outputs '/auth'
//      ```
//      - This indicates that the `authApp` is 
//        accessible at the `/auth` route.

// 3. **Summary**:
//    - In summary, `app.mount` is used to mount 
//      a sub-app, while `app.mountpath` tells you 
//      where that sub-app is accessible.

// Feel free to use these features to modularize 
// your Express applications! ðŸš€


// Express.js | app.all() Function

// The app.all() function is used to 
// route all types of HTTP requests.
//  Like if we have POST, GET, PUT, DELETE, etc, 
// requests made to any specific route, letâ€™s 
// say /user, so instead of defining
//  different APIs like app.post(â€˜/userâ€™), 
// app.get(â€˜/userâ€™), etc, we can define 
// single API app.all(â€˜/userâ€™) which will
//  accept all type of HTTP request. 

// Certainly! When you define an API using 
// app.all('/user'), it means that the specified 
// route (/user) will handle all types of HTTP requests. 
// Whether itâ€™s a POST, GET, PUT, DELETE, or any 
// other HTTP method, the same route will be triggered 
// to process the request. Essentially, it acts as 
// a catch-all for any request made to that specific path. ðŸš€

// Syntax:
app.all(path, callback)
// Parameters:

// Path: It is the path for which the middleware function is called.
// Callback: It can be a middleware function or a series/array of functions.



// Filename: index.js 
const express = require('express');
const app = express();
const PORT = 3000;

app.all('/user', function (req, res, next) {
    console.log('USER API CALLED');
    next();
});

app.listen(PORT, function (err) {
    if (err) console.log(err);
    console.log("Server listening on PORT ", PORT);
});


// node index.js
// Output:

// Console Output:

// Server listening on PORT 3000
// Browser Output:

// Now open your browser and make GET,
//  POST, PUT, DELETE, or any other HTTP request
// method to http://localhost:3000/user and
// you will see the following output on the console:

// Server listening on PORT 3000
// USER API CALLED





















