// Differences between Node.js and the Browser

// Both the browser and Node.js use JavaScript 
// as their programming language. Building 
// apps that run in the browser is a completely 
// different thing than building a Node.js 
// application. 

// From the perspective of a frontend 
// developer who extensively uses JavaScript,
//  Node.js apps bring with them a huge 
// advantage: the comfort of programming 
// everything - the frontend and the 
// backend - in a single language.
// both on the client and on the server, 

// Another big difference is that in 
// Node.js you control the environment. (// Unless you are building an open source  application that anyone can deploy  anywhere,)
// you know which version of 
// Node.js you will run the application on. 
// Compared to the browser environment, 
// where you don't get the luxury to 
// choose what browser your visitors 
// will use, this is very convenient.


// This means that you can write all 
// the modern ES2015+ JavaScript that 
// your Node.js version supports. Since 
// JavaScript moves so fast, but browsers 
// can be a bit slow to upgrade, sometimes 
// on the web you are stuck with using 
// older JavaScript / ECMAScript releases. 
// You can use Babel to transform your 
// code to be ES5-compatible before 
// shipping it to the browser, but 
// in Node.js, you won't need that.

// Another difference is that Node.js 
// supports both the CommonJS and 
// ES module systems (since Node.js v12), 
// while in the browser we are starting 
// to see the ES Modules standard being implemented.

// In practice, this means that you 
// can use both require() and import 
// in Node.js, while you are limited 
// to import in the browser.

/////////////////////////////////////////////////////////////////////////


// npm is the standard package manager for Node.js.it the 
// biggest single language code 
// repository you can 
// be sure there is a package for 
// (almost!) everything.
// Yarn and pnpm are alternatives to npm cli. 

// Installing all dependencies
// If a project has a package.json file, by running
// npm install
// Bash

// it will install everything 
// the project needs, in the 
// node_modules folder, creating 
// it if it's not existing already.

// Installing a single package
// You can also install a specific package by running
// npm install <package-name>

// Often you'll see more flags added to this command:
            // --save-dev           installs and adds the entry to the package.json file devDependencies
            // --no-save            installs but does not add the entry to the package.json file dependencies
            // --save-optional      installs and adds the entry to the package.json file optionalDependencies
            // --no-optional        will prevent optional dependencies from being installed
// Shorthands of the flags can also be used:
            // -S: --save
            // -D: --save-dev
            // -O: --save-optional


// The difference between devDependencies 
// and dependencies is that the former 
// contains development tools, like a 
// testing library, while the latter is 
// bundled with the app in production.


// As for the optionalDependencies the 
// difference is that build failure of 
// the dependency will not cause 
// installation to fail. But it is 
// your program's responsibility to 
// handle the lack of the dependency. 
// Read more about optional dependencies.



// Updating packages
// Updating is also made easy, by running

// npm update
// Bash

// npm will check all packages for 
// a newer version that satisfies 
// your versioning constraints.

// You can specify a single package to update as well:
// npm update <package-name>

// Versioning
// In addition to plain downloads, 
// npm also manages versioning, so 
// you can specify any specific 
// version of a package, or require 
// a version higher or lower than 
// what you need.

// Many times you'll find that a 
// library is only compatible with 
// a major release of another library.

// Or a bug in the latest release 
// of a lib, still unfixed, is 
// causing an issue.

// Specifying an explicit version of 
// a library also helps to keep 
// everyone on the same exact version 
// of a package, so that the whole 
// team runs the same version until
//  the package.json file is updated.

// In all those cases, versioning helps 
// a lot, and npm follows the semantic 
// versioning (semver) standard.

// You can install a specific version of a package, by running
// npm install <package-name>@<version>

// Bash
// Running Tasks
// The package.json file supports 
// a format for specifying command 
// line tasks that can be run by using
// npm run <task-name>
// Bash
// For example:
            // {
            //   "scripts": {
            //     "start-dev": "node lib/server-development",
            //     "start": "node lib/server-production"
            //   }
            // }
// JSON
// It's very common to use this feature to run Webpack:
            // {
            //   "scripts": {
            //     "watch": "webpack --watch --progress --colors --config webpack.conf.js",
            //     "dev": "webpack --progress --colors --config webpack.conf.js",
            //     "prod": "NODE_ENV=production webpack -p --config webpack.conf.js"
            //   }
            // }
// JSON
// So instead of typing those long 
// commands, which are easy to 
// forget or mistype, you can run

// $ npm run watch
// $ npm run dev
// $ npm run prod


// Node.js is built against modern versions 
// of V8. By keeping up-to-date with the 
// latest releases of this engine, we ensure
//  new features from the JavaScript ECMA-262 
// specification are brought to Node.js 
// developers in a timely manner, as well 
// as continued performance and 
// stability improvements.


// Node.js, the difference between 
// development and production

// Node.js with TypeScript

// What is TypeScript
// TypeScript is a trendy 
// open-source language maintained 
// and developed by Microsoft. It's 
// loved and used by a lot of 
// software developers around the world.

// Basically, it's a superset 
// of JavaScript that adds new 
// capabilities to the language. 
// The most notable addition is 
// static type definitions, 
// something that is not present 
// in plain JavaScript. Thanks to 
// types, it's possible, for 
// example, to declare what kind of 
// arguments we are expecting and 
// what is returned exactly in our 
// functions or what's the exact 
// shape of the object that we are 
// creating. TypeScript is a really 
// powerful tool and opens a new 
// world of possibilities in 
// JavaScript projects. It makes 
// our code more secure and robust 
// by preventing many bugs before 
// the code is even shipped - it 
// catches problems during code 
// development and integrates 
// wonderfully with code editors 
// like Visual Studio Code.


