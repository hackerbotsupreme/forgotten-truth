
// 4. **Why `dns.getServers()` Shines Here**:
//    - The `dns.getServers()` method allows you to dynamically fetch the DNS servers configured for the current region.
//    - You can then use these servers to optimize DNS resolution based on user location.

Remember that this example is simplified for illustration. 
// In a real-world application, you'd handle error handling, 
// fallback servers, and more complex deployment scenarios. 
// But the essence remains: `dns.getServers()` is essential 
// for custom DNS configuration in web development. 🌐🔍

// Node.js dns.lookup() Method
// the dns module which is used to resolve
//  IP addresses of the specified hostname 
// for given parameters into the first 
// found A (IPv4) or AAAA (IPv6) record. 

dns.lookup( hostname, options, callback )

// hostname: This parameter specifies a string 
// which denotes the hostname to be checked.

// options: It is in the form of an integer or 
// an object. It specifies the options to be 
// used during lookup.

// family: It is an integer value that specifies 
// the family of the record. The value must be 
// in 4, 6 or 0 where 0 indicates to return both
//  IPv4 and IPv6 value, 4 indicates to return
//  IPv4 and 6 indicates to return IPv6. 
// Its default value is 0.

// callback: It specifies a function to 
// be called after DNS resolution of 
// the hostnames is done.

// address: It is a string representation 
// of IPv4 and IPv6 addresses.

// dns.lookup() method  
// Accessing dns module 
const dns = require('dns');

// Setting options for dns.lookup() method 
const options = {
   // Setting family as 6 i.e. IPv6 
   family: 6,
   hints: dns.ADDRCONFIG | dns.V4MAPPED,
};
// Calling dns.lookup() for hostname geeksforgeeks.org 
// and displaying them in console as a callback 
dns.lookup('geeksforgeeks.org', options, (err, address, family) =>
   console.log('address: %j family: IPv%s', address, family));
// Output:
// address: "fd00:0:13:13::22da:3e74" family: IPv6

// dns.lookup() method  
// Accessing dns module 
const dns = require('dns');

// Setting options for dns.lookup() 
// method, all as true 
const options = {
   all: true,
};
// Calling dns.lookup() for hostname 
//  geeksforgeeks.org and displaying 
// them in console as a callback 
dns.lookup('geeksforgeeks.org', options, (err, addresses) =>
   console.log('addresses: %j', addresses));
// Output:
// addresses: [
//     {"address":"34.218.62.116","family":4},
//     {"address":"fd00:0:13:13::22da:3e74","family":6}
// ]



// Imagine you're working on a high-traffic web application 
// deployed across multiple servers. To distribute the load 
// efficiently, you use a load balancer that dynamically 
// routes incoming requests to different server instances. 
// The `dns.lookup()` method plays a crucial role in this scenario.

// Here's how it works:

// 1. ** Dynamic Load Balancing **:
//    - Suppose your application has three backend servers(A, B, and C) behind a load balancer.
//    - The load balancer needs to resolve the IP addresses of these servers dynamically based on their availability and performance.

// 2. ** Scenario **:
//    - When a user makes a request, the load balancer performs DNS lookups to resolve the IP addresses of the backend servers.
//    - It uses the `dns.lookup()` method to obtain the current IP addresses for each server.

   const dns = require('dns');

// Assume these are the server hostnames
const serverHostnames = ['serverA.example.com', 'serverB.example.com', 'serverC.example.com'];

// Resolve IP addresses for each server
const serverIPs = serverHostnames.map((hostname) => dns.lookup(hostname));

// Use the resolved IPs for load balancing logic
console.log('Resolved server IPs:');
serverIPs.forEach((ip, index) => {
   console.log(`Server ${index + 1}: ${ip} `);
});

// 4. ** Why`dns.lookup()` Shines Here **:
//    - The`dns.lookup()` method allows the load balancer to dynamically resolve the IP addresses of backend servers.
//    - It ensures that requests are distributed effectively based on the current server availability.

// Node.js dns.lookupService() Method
// the dns module which is used to resolve 
// the addresses and port number to hostname 
// using operating system’s underlying 
// getnameinfo implementation. 

dns.lookupService( address, port, callback )

// address: It specifies a string which denotes 
// the address to be resolved.

// port: It is a number that specifies the port 
// number of the address whose service is 
// to be resolved.

// callback: It specifies a function to be 
// called after resolution of the address and port.


// Example 1: IP for localhost
// Accessing dns module 
const dns = require('dns');

// Calling dns.lookupService() method for 
// 127.0.0.1 port  number 22 
dns.lookupService('127.0.0.1', 22,
    (err, hostname, service) => {
        // Printing hostname and service as callback 
        console.log(hostname, service);
    });
// Output: Here name of my computer is my-lappy
// my-lappy ssh


// Example 2:
// Accessing dns module 
const dns = require('dns');

// Setting options for dns.lookup() method 
const options = {
    // Setting family as 4 i.e. IPv4 
    family: 4,
    hints: dns.ADDRCONFIG | dns.V4MAPPED,
};

dns.lookup('www.geeksforgeeks.org',
    options, (err, address, family) => {
        console.log('address:', address);
        if (err) {
            console.log(err.stack);
        } else {
            // Calling dns.lookupService() method  
            dns.lookupService(address, 80,
                (err, hostname, service) => {
                    if (err) {
                        console.log(err.stack);
                    }
                    // Printing hostname and service 
                    // as callback 
                    console.log(hostname, service);
                });
        }
    });
// Output:
// address: 42.106.162.241
// 42-106-162-241.live.vodafone.in http


// ** Use Case: Custom DNS Configuration for Multi - Region Services **

// Imagine you're working on a large-scale web application 
// that serves users from different regions worldwide.
//  To optimize performance and reduce latency, 
// you want to configure custom DNS servers for 
// specific regions. This ensures that DNS resolution 
// happens efficiently based on the user's location.

// Here's an example where `dns.lookupService()` plays a crucial role:

// 1. ** Multi - Region Service Deployment **:
//     - Suppose your application is deployed across multiple data centers or cloud regions(e.g., US, Europe, Asia).
//    - Each region has its own DNS servers optimized for local resolution.
//    - You need to programmatically retrieve and configure the DNS servers based on the current deployment region.

// 2. ** Scenario **:
//    - Your application starts up in a specific region(e.g., US).
//    - You want to fetch the configured DNS servers for that region and set them as the default DNS resolvers for your application.

const dns = require('dns');
// Get the configured DNS servers for the current region
const regionDnsServers = dns.getServers();
// Set the DNS servers for your application
dns.setServers(regionDnsServers);
console.log('Custom DNS servers configured successfully!');

// 4. ** Why`dns.lookupService()` Shines Here **:
//    - The`dns.lookupService()` method allows you to dynamically resolve the IP addresses of backend servers based on the current region.
//    - It ensures that DNS resolution is efficient and localized, improving overall performance for users.

// Node.js dns.resolve() Method
// Node.js dns.resolve() Method is used to resolve hostname into an array of 
// the resource records.

// Syntax:
dns.resolve(hostname, rrtype, callback)

// hostname: This parameter specifies a string 
// which denotes the hostname to be resolved.
// rrtype: It specifies the resource record type.

// Its default value is ‘A’. The list of records 
// (‘A’, ‘AAAA’, ‘ANY’, ‘CNAME’, ‘MX’, ‘TXT’, ‘NS’,
// ‘NAPTR’, ‘PTR’, ‘SOA’, ‘SRV’) are described below:

// A: IPv4 address
// AAAA: IPv6 address
// ANY: Any records
// CNAME: canonical name records
// MX: mail exchange records
// NAPTR: name authority pointer records
// NS: name server records
// PTR: pointer records
// SOA: start of authority records
// SRV: service records
// TXT: text records
// callback: It specifies a function which to be called 
// after DNS resolution of the hostname.
// error: It specifies error if generated.
// records: It’s string or object that signifies the returned record.

// Accessing dns module 
const dns = require('dns');
// Set the rrtype for dns.resolve() method 
const rrtype = "A";
// Calling dns.resolve() method for hostname 
// geeksforgeeks.org and print them in 
// console as a callback 
dns.resolve('geeksforgeeks.org', rrtype, (err, records)
    => console.log('records: %j', records));
// Output:
// records: ["34.218.62.116"]


// dns.resolve() method 
// Accessing dns module 
const dns = require('dns');
// Set the rrtype for dns.resolve() method 
const rrtype = "MX";
// Calling dns.resolve() method for hostname 
// geeksforgeeks.org and print them in 
// console as a callback 
dns.resolve('geeksforgeeks.org', rrtype, (err, records)
    => console.log('records: %j', records));
// Output:
// records: [
//     {"exchange":"alt1.aspmx.l.google.com", "priority":5},
//     {"exchange":"alt2.aspmx.l.google.com", "priority":5},
//     {"exchange":"aspmx.l.google.com", "priority":1},
//     {"exchange":"alt3.aspmx.l.google.com", "priority":10},
//     {"exchange":"alt4.aspmx.l.google.com", "priority":10}
// ]

// Accessing dns module 
const dns = require('dns');
// Set the rrtype for dns.resolve() method 
const rrtype = "TXT";
// Calling dns.resolve() method for hostname 
// geeksforgeeks.org and print them in 
// console as a callback 
dns.resolve('geeksforgeeks.org', rrtype, (err,
    records) => console.log('records: %j', records));
// Output:
// records: [
//     ["v=spf1 include:amazonses.com include:_spf.google.com -all"],
//     ["fob1m1abcdp777bf2ncvnjm08n"]
// ]

// Node.js dns.resolve4() Method
// Node.js dns.resolve4() Methodwhich is used to resolve IPv4 
// address (‘A’ record) for the specified 
// hostname using DNS protocol. 

dns.resolve4( hostname, options, callback )

// Syntax:
dns.resolve4( hostname, options, callback )

// Parameters: This method accept three parameters 
// as mentioned above and described below:

// hostname: This parameter specifies a string 
// which denotes the hostname to be resolved.

// options: It is in the form of an object.

// ttl: It is a Boolean parameter specifies 
// whether the Time-To-Live value (TTL) for 
// each record to be retrieved or not. 
// If set to true, TTL for each record is retrieved (in seconds).

// callback: It specifies a function to be 
// called after DNS resolution of the hostname.


// Accessing dns module 
const dns = require('dns');
// Calling dns.resolve4() method for hostname 
// geeksforgeeks.org and display them in 
// console as a callback 
dns.resolve4('geeksforgeeks.org', (err,
  address) => console.log('address: %j', address));
// Output:
// address: ["34.218.62.116"]


// Accessing dns module 
const dns = require('dns');
// Setting options value for 
// dns.resolve4() method 
const options = {
  ttl: true,
};
// Calling dns.resolve4() method for hostname 
// geeksforgeeks.org and displaying them 
// in console as a callback 
dns.resolve4('geeksforgeeks.org', options, (err,
  address) => console.log('address: %j', address));
// Output:
// address: [{"address":"34.218.62.116", "ttl":9}]

//** Custom DNS Configuration for Multi - Region Services **:
//    - ** Scenario **: Your application is deployed across multiple data centers or cloud regions(e.g., US, Europe, Asia).
//    - Each region has its own DNS servers optimized for local resolution.
//    - You need to programmatically retrieve and configure the DNS servers based on the current deployment region.

// Node.js dns.resolve6() Method
//is used to resolve
//  IPv6 address (‘AAAA’ record) for 
// the specified hostname using DNS protocol. 

dns.resolve6(hostname, options, callback)
//....// callback: It specifies a function to be 
// called after DNS resolution of the hostname.

dns.resolve6('geeksforgeeks.org', (err,
    address) => console.log('address: %j', address));
// Output:
// address: ["fd00:0:14:13::22da:3e74"]

// **Use Case: Service Discovery in Microservices**

// In a microservices architecture, different services 
// need to communicate with each other. Imagine a scenario 
// where a user-facing web application needs to interact 
// with various backend services (e.g., authentication,
//  payment, and database services). Each of 
// these services has its own hostname.

// 1. The user-facing application receives a request from a client.
// 2. When handling the request, it needs to locate the **IPv6 addresses** 
// of the relevant backend services dynamically.
// 3. It uses `dns.resolve6()` to resolve the hostnames to their corresponding IPv6 addresses.
// 4. Armed with the resolved IP addresses, the application can
//  make API calls or send data to the appropriate services.

const dns = require('dns');

// Resolving the IPv6 address for 'geeksforgeeks.org'
dns.resolve6('geeksforgeeks.org', (err, addresses) => {
    if (err) {
        console.error('Error:', err);
    } else {
        console.log('IPv6 addresses:', addresses);
    }
});
// In this example, the method resolves the IPv6 address for 
// the hostname 'geeksforgeeks.org', providing an array of 
// IP addresses like `["fd00:0:14:13::22da:3e74"]`¹.

// Remember that DNS resolution is a fundamental part of 
// web infrastructure, and the `dns.resolve6()` method plays 
// a crucial role in ensuring efficient communication between 
// clients and servers. 🚀

// The dns.resolveAny() method is used to resolve 
// all records (i.e. ‘ANY’ or ‘*’) for 
// the specified hostname using DNS protocol. 

// Syntax:
dns.resolveAny(hostname, callback)
// hostname: This parameter specifies a string 
// which denotes the hostname to be resolved.
// callback: It specifies a function to be 
// called after DNS resolution of the hostnames.

// error: It specifies error if generated.
// ret: It is an object that signifies the 
// returned records for the hostname.
// Return Value: This method returns error, 
// records through callback function.

// Records that may be returned are:

// A: IPv4 address
// AAAA: IPv6 address
// ANY: Any records
// CNAME: canonical name records
// MX: mail exchange records
// NAPTR: name authority pointer records
// NS: name server records
// PTR: pointer records
// SOA: start of authority records
// SRV: service records
// TXT: text records

// **Use Case: Service Discovery in Microservices**

// In a microservices architecture, different services need 
// to communicate with each other. Imagine a scenario where 
// a user-facing web application interacts with various backend 
// services (e.g., authentication, payment, and database services). 
// Each service has its own hostname.

// 1. The user-facing application receives a request from a client.
// 2. To handle the request, it dynamically resolves all types of 
//    DNS records (A, AAAA, MX, CNAME, etc.) associated with the backend service hostnames.
// 3. It uses `dns.resolveAny()` to retrieve all available records for a given hostname.
// 4. Armed with the resolved records, the application can make API calls 
//    or send data to the appropriate services.

const dns = require('dns');

// Resolving all records for 'geeksforgeeks.org'
dns.resolveAny('geeksforgeeks.org', (err, records) => {
  if (err) {
    console.error('Error:', err);
  } else {
    console.log('Records:', records);
  }
});
// Output:
// ```
Records: [
  { type: 'NS', value: 'ns-1520.awsdns-62.org' },
  { type: 'NS', value: 'ns-1569.awsdns-04.co.uk' },
  { type: 'NS', value: 'ns-245.awsdns-30.com' },
  { type: 'NS', value: 'ns-869.awsdns-44.net' }
]
// ```

// In this example, we resolve all record types (NS in this case) 
// for the hostname 'geeksforgeeks.org'¹. You can adapt this
//  approach to suit your specific use case in a microservices environment.

// Remember that DNS resolution is essential for seamless 
// communication between services, and the `dns.resolveAny()`
//  method provides a comprehensive view of available records. 🚀

// Node.js dns.resolveCname() Method
// The dns.resolveCname() method is 
// used to resolve CNAME records for 
// the specified hostname using DNS protocol. 

// hostname: This parameter specifies a string 
// which denotes the hostname to be resolved.
// callback: It specifies a function to be 
// called after DNS resolution of the hostnames.
// error: It specifies error if generated.
// addresses: It is an array of string that 
// signifies the returned cname addresses 
// for the hostname.
// These data are passed as parameters to 
// the callback function.

// Accessing dns module 
const dns = require('dns');
// Calling dns.resolveCname() method for hostname 
// geeksforgeeks.org and displaying them in 
// console as a callback 
dns.resolveCname('geeksforgeeks.org', (err,
    addresses) => console.log('addresses: %j', addresses));
// Output:
// QueryReqWrap {
//   bindingName: 'queryCname',
//   callback: [Function],
//   hostname: 'geeksforgeeks.org',
//   oncomplete: [Function: onresolve],
//   ttl: false,
//   channel: ChannelWrap {} 
// }
// addresses: undefined

// **Use Case: Service Discovery in Microservices**

// In a microservices architecture, different services 
// need to communicate with each other. Imagine a scenario 
// where a user-facing web application interacts with 
// various backend services (e.g., authentication, 
// payment, and database services). Each service has its own hostname.

// 1. The user-facing application receives a request from a client.
// 2. To handle the request, it dynamically resolves **CNAME records** 
// associated with the backend service hostnames.
// 3. It uses `dns.resolveCname()` to retrieve the canonical names (CNAMEs) for a given hostname.
// 4. Armed with the resolved CNAMEs, the application can make API 
// calls or send data to the appropriate services.

const dns = require('dns');

// Resolving CNAME records for 'geeksforgeeks.org'
dns.resolveCname('geeksforgeeks.org', (err, addresses) => {
    if (err) {
        console.error('Error:', err);
    } else {
        console.log('CNAME records:', addresses);
    }
});
// Output:
// ```
CNAME records: ['www.geeksforgeeks.org']
// ```

// In this example, the method resolves the CNAME records 
// for the hostname 'geeksforgeeks.org', providing an 
// array with the canonical name 'www.geeksforgeeks.org'¹.

// Remember that DNS resolution plays a crucial role in 
// ensuring efficient communication between services, 
//and the `dns.resolveCname()` method helps discover 
// the true identity of hostnames. 🚀

// Node.js dns.resolveMx() Method
// The dns.resolveMx() method is used to resolve MX 
// or mail exchange records for the specified 
// hostname using DNS protocol. 
dns.resolveMx( hostname, callback )

// Accessing dns module 
const dns = require('dns'); 
// Calling dns.resolveMx() method for 
// hostname google.com and displaying 
// them in console as a callback 
dns.resolveMx('google.com', (err,  
    addresses) => console.log('mx records: %j', addresses)); 
// Output:
// mx records: [
//     {"exchange":"alt3.aspmx.l.google.com","priority":40},
//     {"exchange":"aspmx.l.google.com","priority":10},
//     {"exchange":"alt2.aspmx.l.google.com","priority":30},
//     {"exchange":"alt1.aspmx.l.google.com","priority":20},
//     {"exchange":"alt4.aspmx.l.google.com","priority":50}
// ]


// **Use Case: Service Discovery in Microservices**

// In a microservices architecture, different services 
// need to communicate with each other. Imagine a scenario 
// where a user-facing web application interacts with 
// various backend services (e.g., authentication, payment,
//  and database services). Each service has its own hostname.

// 1. The user-facing application receives a request from a client.
// 2. To handle the request, it dynamically resolves **MX records** 
//    associated with the backend service hostnames.
// 3. It uses `dns.resolveMx()` to retrieve the mail exchange records for a given hostname.
// 4. Armed with the resolved MX records, the application can send
//   emails or communicate with the appropriate services.

const dns = require('dns');

// Resolving MX records for 'geeksforgeeks.org'
dns.resolveMx('geeksforgeeks.org', (err, addresses) => {
  if (err) {
    console.error('Error:', err);
  } else {
    console.log('MX records:', addresses);
  }
});


// Output:
// ```
MX records: [
  { exchange: 'aspmx.l.google.com', priority: 1 },
  { exchange: 'alt3.aspmx.l.google.com', priority: 10 },
  { exchange: 'alt4.aspmx.l.google.com', priority: 10 },
  { exchange: 'alt1.aspmx.l.google.com', priority: 5 },
  { exchange: 'alt2.aspmx.l.google.com', priority: 5 }
]
// ```

// In this example, the method resolves the MX records for 
// the hostname 'geeksforgeeks.org', providing an array of 
// objects containing exchange servers and their priorities⁶.

// Remember that DNS resolution is essential for seamless 
// communication between services, and the `dns.resolveMx()` 
// method helps discover mail exchange servers efficiently. 🚀

// The dnsPromises.lookup() method
// is used to resolve IP addresses of 
// the specified hostname for given parameters 
// into the first found A (IPv4) or AAAA (IPv6) record.

dnsPromises.lookup(hostname, options)

// ... 
// family: It is an integer value that specifies 
// the family of the record. Its value must be in 4, 6 or 0, 0 indicates 
// to return both IPv4 and IPv6, 4 indicates to return IPv4 
// and 6 to return IPv6. The default value is 0.

// all: It is a Boolean parameter. If it is set to 
// TRUE then callback returns all resolved address 
// in an array, otherwise it returns single address. 
// Its default value is FALSE.
// .....

// Accessing promises object from dns module 
const dns = require('dns');
const dnsPromises = dns.promises;
// Setting options for dnsPromises.lookup() method 
const options = {
  // Setting family as 6 i.e. IPv6 
  family: 6,
  hints: dns.ADDRCONFIG | dns.V4MAPPED,
};
// Calling dnsPromises.lookup() for hostname 
// geeksforgeeks.org 
dnsPromises.lookup('geeksforgeeks.org', options).then((response) => {
  console.log(' family: IPv%s address: %j', response.family, response.address);
});
// Output:
//  family: IPv6 address: "fd00:0:14:13::22da:3e74"


//  Let's explore some real-world use cases 
// of the `dnsPromises.lookup()` method in web development. 
// While these examples might not be everyday occurrences, 
// they demonstrate how this method can be valuable in specific scenarios:

// 1. **Custom DNS Configuration for Multi-Region Services**:
//- **Scenario**: Your application is deployed across multiple 
// data centers or cloud regions (e.g., US, Europe, Asia).
//- Each region has its own DNS servers optimized for local resolution.
//- You need to programmatically retrieve and configure 
// the DNS servers based on the current deployment region.

//- **Example (Simplified)**:
//      ```javascript
const dns = require('dns');

// Get the configured DNS servers for the current region
const regionDnsServers = dns.getServers();

// Set the DNS servers for your application
dns.setServers(regionDnsServers);

console.log('Custom DNS servers configured successfully!');
//      ```
//- **Why It Shines**: The `dns.lookup()` method allows you to 
// dynamically resolve the IP addresses of backend servers 
// based on the current region. It ensures that DNS resolution 
// is efficient and localized, improving overall performance for users.

// 2. **Dynamic IP Address Resolution for Load Balancing**:
//- **Scenario**: Your application has three backend servers 
// (A, B, and C) behind a load balancer.
//- The load balancer needs to resolve the IP addresses of 
// these servers dynamically based on their availability and performance.

//- **Example (Simplified)**:
//      ```javascript
const dns = require('dns');

// Assume these are the server hostnames
const serverHostnames = ['serverA.example.com', 'serverB.example.com', 'serverC.example.com'];

// Resolve IP addresses for each server
const serverIPs = serverHostnames.map((hostname) => dns.lookup(hostname));

// Use the resolved IPs for load balancing logic
console.log('Resolved server IPs:');
serverIPs.forEach((ip, index) => {
  console.log(`Server ${index + 1}: ${ip}`);
});
//      ```
//- **Why It Shines**: The `dns.lookup()` method allows 
// the load balancer to dynamically resolve the IP addresses 
// of backend servers. It ensures that requests are distributed 
// effectively based on the current server availability.


// In a microservices architecture, different services 
// need to communicate with each other. Imagine a scenario 
// where a user-facing web application interacts with 
// various backend services (e.g., authentication, 
// payment, and database services). Each service has its own hostname.

// 1. The user-facing application receives a request from a client.
// 2. To handle the request, it dynamically resolves **IP addresses** 
//  associated with the backend service hostnames.
// 3. It uses `dnsPromises.lookup()` to retrieve the first found A (IPv4) 
//  or AAAA (IPv6) record for a given hostname.
// 4. Armed with the resolved IP address, the application can make 
//  API calls or send data to the appropriate services.

// Here's a simple example of using `dnsPromises.lookup()` in Node.js:
const dns = require('dns');
const dnsPromises = dns.promises;

// Resolving the IPv6 address for 'geeksforgeeks.org'
dnsPromises.lookup('geeksforgeeks.org', { family: 6 })
  .then((response) => {
    console.log('IPv6 address:', response.address);
  })
  .catch((error) => {
    console.error('Error:', error);
  });
// Output:
// ```
IPv6 address: "fd00:0:14:13::22da:3e74"
// ```

// In this example, the method resolves the IPv6 address 
// for the hostname 'geeksforgeeks.org'¹. You can adapt 
// this approach to suit your specific use case in 
// a microservices environment.

// Remember that DNS resolution is essential for seamless 
// communication between services, and the `dnsPromises.lookup()` 
// method provides a straightforward way to retrieve IP addresses. 🚀

// The dnsPromises.lookupService() method
// is used to resolve the addresses and port
//  number to hostname and service using operating 
// system’s underlying getnameinfo implementation. 

dnsPromises.lookupService(address, port)
// address: It specifies a string which denotes address to be resolved.
// port: It is a number that specifies the port number 
// of the address whose service to be resolved.

// example 1 
// Accessing promises object from dns module 
const dns = require('dns');
const dnsPromises = dns.promises;
// Calling dnsPromises.lookupService() method 
// for 127.0.0.1 port  number 22 
dnsPromises.lookupService('127.0.0.1', 22).then((res) => {
  console.log(res.hostname, res.service);
});
// Output: Here name of my computer is my-lappy
// my-lappy ssh


// Example 2:
// dnsPromises.lookupService() method 
// Accessing promises object from dns module 
const dns = require('dns');
const dnsPromises = dns.promises;
// Setting options for dnsPromises.lookup() method 
const options = {
  // Setting family as 4 i.e. IPv4 
  family: 4,
  hints: dns.ADDRCONFIG | dns.V4MAPPED,
};
dnsPromises.lookup('geeksforgeeks.org', options).then((response) => {
  if (response) {
    console.log(response);

    // Calling dnsPromises.lookupService() method  
    dnsPromises.lookupService(response.address, 80).then((res) => {
      console.log(res.hostname, res.service);
    });
  }
});
// Output:
// { address: '34.218.62.116', family: 4 }
// ec2-34-218-62-116.us-west-2.compute.amazonaws.com 334


// **Use Case: Custom DNS Configuration for Secure Communication**

// Imagine you're building a web application that communicates 
// with external APIs or services over HTTPS. As part of security 
// best practices, you want to verify the SSL certificates of 
// these services by ensuring that their hostnames resolve 
// to the expected IP addresses.


// 1. **Scenario**:
//- Your application interacts with an external API 
// (e.g., payment gateway, authentication service) via HTTPS.
//- You want to verify that the API hostname resolves 
// to the correct IP address.

const dns = require('dns');
const apiHostname = 'api.example.com';
// Resolve the IP address and service for the API hostname
dns.promises.lookupService(apiHostname)
  .then((result) => {
    const { hostname, service } = result;
    console.log(`API IP address for ${apiHostname}: ${hostname}`);
    console.log(`Service for ${apiHostname}: ${service}`);
  })
  .catch((error) => {
    console.error('Error resolving API hostname:', error.message);
  });

//- The `dnsPromises.lookupService()` method allows 
// you to resolve the IP address and service 
// associated with an API hostname.
//- By verifying the resolved IP address, you can 
// ensure that your application communicates 
// securely with the intended service.

// **Use Case: Service Discovery in Microservices**

// In a microservices architecture, different services
//  need to communicate with each other. Imagine 
// a scenario where a user-facing web application 
// interacts with various backend services (e.g., 
// authentication, payment, and database services). 
// Each service has its own hostname.

// 1. The user-facing application receives a request from a client.
// 2. To handle the request, it dynamically resolves **IP addresses** 
// associated with the backend service hostnames.
// 3. It uses `dnsPromises.lookupService()` to retrieve the hostname 
// and service associated with a given address and port.
// 4. Armed with the resolved information, the application can make 
// API calls or send data to the appropriate services.

const dns = require('dns');
const dnsPromises = dns.promises;

// Resolving the hostname and service for IP address '127.0.0.1' and port 22 (SSH)
dnsPromises.lookupService('127.0.0.1', 22)
  .then((result) => {
    const { hostname, service } = result;
    console.log(`Hostname: ${hostname}, Service: ${service}`);
  })
  .catch((error) => {
    console.error('Error:', error);
  });
// ```

// Output:
// ```
Hostname: my - lappy, Service: ssh
// ```
// In this example, the method resolves the hostname and 
// service for the IP address '127.0.0.1' and port 22 (SSH).
//  The hostname is 'my-lappy', and the service is 'ssh'¹.

// Remember that DNS resolution is essential for seamless 
// communication between services, and the `dnsPromises.lookupService()` 
// method provides valuable information for service discovery. 🚀

// The dnsPromises.getServers() method is 
// used to get the IP addresses of the current server. 

dnsPromises.getServers()

// Accessing promises object from dns module 
const { Resolver } = require('dns').promises;
// Calling Resolver constructor 
const dnsPromises = new Resolver();
// Asynchronous function  
(async function () {
  // Address from getServers function 
  const addresses = await dnsPromises.getServers();
  // Printing  addresses 
  console.log(addresses);
})();
// Output:
// [ '10.15.13.139', '8.8.8.8' ]

// ### Real-World Scenario: Load Balancing with Custom DNS Servers

// **Problem Statement:**
// Imagine you're building a high-traffic 
// web application that needs to distribute 
// requests efficiently across multiple servers. 
// Load balancing is crucial to ensure optimal 
// performance and prevent server overload. 
// However, relying solely on default DNS 
// servers might not provide the flexibility you need.

// **Solution:**
// Here's where `dnsPromises.getServers()` shines. 
// By retrieving the configured DNS servers, you 
// can customize your load balancing logic. 
// Let's see how this works in practice:

// 1. **Setting Up Custom DNS Servers:**
//    - In your Node.js application, configure 
// custom DNS servers using `dnsPromises.setServers()`. 
// These servers could be specific to your 
// infrastructure or third-party providers.

const { Resolver } = require('dns').promises;
const dnsPromises = new Resolver();

// Set custom DNS servers (replace with actual IPs)
dnsPromises.setServers(['10.15.13.139', '8.8.8.8']);


// 2. **Load Balancing Logic:**
//    - When handling incoming requests, use 
//    the retrieved DNS servers to distribute traffic.
//    - You can implement various load balancing algorithms 
//    (e.g., round-robin, weighted, or least connections) 
//    based on the list of servers obtained from `dnsPromises.getServers()`.
let currentServerIndex = 0;

function getNextServer() {
  const servers = dnsPromises.getServers();
  const nextServer = servers[currentServerIndex];
  currentServerIndex = (currentServerIndex + 1) % servers.length;
  return nextServer;
}

// 3. **Request Handling:**
//    - Whenever a request arrives, route it to 
//      the next available server obtained from `getNextServer()`.
//    - This dynamic approach ensures that your 
//      application adapts to changes in server availability or performance.

// 4. **Monitoring and Failover:**
//    - Continuously monitor the health of your servers.
//    - If a server becomes unresponsive, remove it from 
//      the list or mark it as unavailable.
//    - Use fallback mechanisms (e.g., retrying with 
//      another server) to handle failures gracefully.


// Suppose you have a load balancer module that uses 
// `dnsPromises.getServers()` to manage server distribution. 
// The code snippet below demonstrates a simplified version:

// LoadBalancer.js
const { Resolver } = require('dns').promises;
const dnsPromises = new Resolver();

class LoadBalancer {
  constructor() {
    this.servers = dnsPromises.getServers();
    this.currentServerIndex = 0;
  }

  getNextServer() {
    const nextServer = this.servers[this.currentServerIndex];
    this.currentServerIndex = (this.currentServerIndex + 1) % this.servers.length;
    return nextServer;
  }

  // Other load balancing methods and error handling go here
}


// Usage
const loadBalancer = new LoadBalancer();
const nextServer = loadBalancer.getNextServer();
console.log(`Routing request to server: ${nextServer}`);
// ```

// In a production environment, consider additional 
// factors like health checks, connection pooling, and security.

// By leveraging `dnsPromises.getServers()`, you gain 
// more control over DNS resolution and can tailor
//  your load balancing strategy to suit your specific needs. 🚀


// **Use Case: DNS Configuration Insights**

// In web applications, understanding the DNS configuration 
// of the current server is crucial. 
// The `dnsPromises.getServers()` method provides 
// insights into the configured IP addresses for 
// DNS resolution on the local machine.


// ```javascript
const dns = require('dns');
const dnsPromises = dns.promises;

(async function () {
  try {
    const addresses = await dnsPromises.getServers();
    console.log('Configured DNS servers:', addresses);
  } catch (error) {
    console.error('Error:', error);
  }
})();
// ```

// Output:
// ```
Configured DNS servers: ['10.15.13.139', '8.8.8.8']
// ```

// In this example:
// - We retrieve the IP addresses of the DNS 
//  servers configured for the current host.
// - The array `[ '10.15.13.139', '8.8.8.8' ]` 
//  represents the DNS servers used for name resolution.

// Remember that understanding DNS configuration 
// helps ensure reliable communication between 
//  your application and external services. 🚀

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Node.js File System
// Node.js is a JavaScript runtime built 
// on Chrome’s V8 JavaScript engine. 
// Node.js helps developers to write 
// JavaScript code to run on the server-side, 
// to generate dynamic content and deliver to 
// the web clients. The two features that
//  make Node.js stand-out are:  

// Event-driven
// Non-blocking I/O model

// About Node.js file system: To handle file 
// operations like creating, reading, deleting, 
// etc., Node.js provides an inbuilt module 
// called FS (File System). Node.js gives the 
// functionality of file I/O by providing wrappers 
// around the standard POSIX functions. 
// All file system operations can have synchronous 
// and asynchronous forms depending upon user 
// requirements. To use this File System module, 
// use the require() method:

var fs = require('fs');
// Common use for File System module:

// Read Files
// Write Files
// Append Files
// Close Files
// Delete Files

// What is Synchronous and Asynchronous approach?

// Synchronous approach: They are called blocking 
// functions as it waits for each operation to complete, 
// only after that, it executes the next operation, 
// hence blocking the next command from execution i.e. 
// a command will not be executed until & unless 
// the query has finished executing to get all 
// the result from previous commands.

// Asynchronous approach: They are called non-blocking 
// functions as it never waits for each operation to 
// complete, rather it executes all operations in the 
// first go itself. The result of each operation will 
// be handled once the result is available i.e.
//  each command will be executed soon after 
// the execution of the previous command. 
// While the previous command runs in the background 
// and loads the result once it is finished processing the data.


// Use cases:
// If your operations are not doing very heavy 
// lifting like querying huge data from DB then 
// go ahead with Synchronous way otherwise Asynchronous way.

// In an Asynchronous way, you can show some 
// progress indicator to the user while in 
// the background you can continue with your 
// heavyweight works. This is an ideal scenario 
// for GUI based apps.


// Example of asynchronous and synchronous: 
// readFile and readFileSync
// Create a text file named input.txt with the following content:
// GeeksforGeeks: A computer science portal

// Now let us create a js file named main.js 
//with the following code: 

var fs = require("fs");
// Asynchronous read
fs.readFile('input.txt', function (err, data) {
   if (err) {
      return console.error(err);
   }
   console.log("Asynchronous read: " + data.toString());
});
// Output:
// Asynchronous read: GeeksforGeeks: A computer science portal
var fs = require("fs");
// Synchronous read
var data = fs.readFileSync('input.txt');
console.log("Synchronous read: " + data.toString());
// Output:
// Synchronous read: GeeksforGeeks: A computer science portal

// Open a File: The fs.open() method is used to create, 
// read, or write a file. The fs.readFile() method is 
// only for reading the file and fs.writeFile() method 
// is only for writing to the file, whereas fs.open() 
// method does several operations on a file.

fs.open(path, flags, mode, callback)

// .... 
// flags: Flags indicate the behavior of the file 
// to be opened. All possible values are
//  ( r, r+, rs, rs+, w, wx, w+, wx+, a, ax, a+, ax+).
// mode: Sets the mode of file i.e. r-read, w-write,
//  r+ -readwrite. It sets to default as readwrite.
// .... 
// err: If any error occurs.
// data: Contents of the file. It is called after 
// the open operation is executed.

var fs = require("fs");
// Asynchronous - Opening File
console.log("opening file!");
fs.open('input.txt', 'r+', function (err, fd) {
   if (err) {
      return console.error(err);
   }
   console.log("File open successfully");
});
// Output:
// opening file!
// File open successfully

// Reading a File: The fs.read() method is used 
// to read the file specified by fd. This method 
// reads the entire file into the buffer. 
fs.read(fd, buffer, offset, length, position, callback)

// Parameters:
// fd: This is the file descriptor returned by fs.open() method.
// buffer: This is the buffer that the data will be written to.
// offset: This is the offset in the buffer to start writing at.
// length: This is an integer specifying the number of bytes to read.
// position: This is an integer specifying where to begin reading 
// from in the file. If the position is null, data will be read 
// from the current file position.
// callback: It is a callback function that is called after reading 
// of the file. It takes two parameters:
// err: If any error occurs.
// data: Contents of the file.

// Example: Let us create a js file named
//  main.js having the following code: 

var fs = require("fs");
var buf = new Buffer(1024);
console.log("opening an existing file");
fs.open('input.txt', 'r+', function (err, fd) {
   if (err) {
      return console.error(err);
   }
   console.log("File opened successfully!");
   console.log("reading the file");

   fs.read(fd, buf, 0, buf.length, 0, function (err, bytes) {
      if (err) {
         console.log(err);
      }
      console.log(bytes + " bytes read");
      // Print only read bytes to avoid junk.
      if (bytes > 0) {
         console.log(buf.slice(0, bytes).toString());
      }
   });
});

// Output:
// opening an existing file
// File opened successfully!
// reading the file
// 40 bytes read
// .....

// The fs.writeFile() method is used to asynchronously 
// write the specified data to a file. By default, 
// the file would be replaced if it exists. 
// The ‘options’ parameter can be used to modify 
// the functionality of the method. 
fs.writeFile(path, data, options, callback)

//  main.js having the following code: 
var fs = require("fs");

console.log("writing into existing file");
fs.writeFile('input.txt', 'Geeks For Geeks', function (err) {
   if (err) {
      return console.error(err);
   }
   console.log("Data written successfully!");
   console.log("Let's read newly written data");
   fs.readFile('input.txt', function (err, data) {
      if (err) {
         return console.error(err);
      }
      console.log("Asynchronous read: " + data.toString());
   });
});
// Output:
// writing into existing file
// Data written successfully!

// Appending to a File: The fs.appendFile() method is 
// used to synchronously append the data to the file. 
// Syntax:
fs.appendFile(filepath, data, options, callback);
// or
fs.appendFileSync(filepath, data, options);

// main.js having the following code: 
var fs = require('fs');
var data = "\nLearn Node.js";
// Append data to file
fs.appendFile('input.txt', data, 'utf8',
   // Callback function
   function (err) {
      if (err) throw err;
      //  If no error
      console.log("Data is appended to file successfully.")
   });
// Output:
// Data is appended to file successfully.
//For synchronously appending 
var fs = require('fs');
var data = "\nLearn Node.js";
// Append data to file
fs.appendFileSync('input.txt', data, 'utf8');
console.log("Data is appended to file successfully.")
// Output:
// Data is appended to file successfully.

// Closing the File: The fs.close() method is used 
// to asynchronously close the given file descriptor
//  thereby clearing the file that is associated with 
// it. This will allow the file descriptor to be reused 
// for other files. Calling fs.close() on a file 
// descriptor while some other operation is being 
// performed on it may lead to undefined behavior. 

// Syntax:
fs.close(fd, callback)

// fd: It is an integer that denotes the file descriptor 
// of the file for which to be closed.

// callback: It is a function that would be 
// called when the method is executed.
// .....

// Close the opened file.
fs.close(fd, function (err) {
   if (err) {
      console.log(err);
   }
   console.log("File closed successfully.");
}
// Output:
// File closed successfully.

// Delete a File: The fs.unlink() method is used 
// to remove a file or symbolic link from the filesystem. 
// This function does not work on directories, therefore 
// it is recommended to use fs.rmdir() to remove a directory. 
fs.unlink(path, callback)

// main.js having the following code: 
var fs = require("fs");
console.log("deleting an existing file");
fs.unlink('input.txt', function (err) {
   if (err) {
      return console.error(err);
   }
   console.log("File deleted successfully!");
});
// Output:
// deleting an existing file
// File deleted successfully!

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Node.js Timers module
// The Timers module in Node.js contains 
// various functions that allow us to execute 
// a block of code / a function after 
// a set period of time. The Timers module 
// is global, we do not need to use require() 
// to import it. 

// Scheduling Timers: It is used to call 
// a function after a set period of time.
// setImmediate()
// setInterval()
// setTimeout()

// Canceling Timers: It is used to cancel the scheduled timer.
// clearImmediate()
// clearInterval()
// clearTimeout()

// setImmediate() method: It schedules the “immediate” 
// execution of the callback after I/O events callbacks. 

// In the following example, multiple setImmediate functions 
// are called. Whenever we do these callback functions are
//  queued for execution in the order in which they are created. 
// The entire callback queue is processed after every 
// event loop iteration. If an immediate timer is queued 
// from inside an executing callback, that timer will 
// not be triggered until the next event loop iteration. 

setImmediate(function A() {
    setImmediate(function B() {
        console.log(1);
        setImmediate(function D() {
            console.log(2);
        });
    });
    setImmediate(function C() {
        console.log(3);
        setImmediate(function E() {
            console.log(4);
        });
    });
});
console.log('Started...');

// Output:
// Started...
// 1
// 3
// 2
// 4
// In the above example, on the first iteration of 
// the event loop function A is fired. Then on the 
// second iteration function B is fired, and C is 
// fired on the third iteration. Similarly, 
// functions D and E are fired on the fourth 
// and fifth iterations respectively. 

// setInterval() method: It repeats the execution 
// of the callback after every t time in 
// milliseconds passed as a parameter. 

// clearImmediate() method: It is used to simply 
// cancel the Immediate object created by 
// the setImmediate() method. 
let si = setImmediate(function A() {
    console.log(1);
});
// clears setInterval si
clearImmediate(si);
console.log(2);
// Output:
// 2

// clearInterval() method: It is used to 
// cancel the Immediate object created 
// by the setInterval() method. 
let si = setInterval(function A() {
    return console.log("Hello World!");
}, 500);
setTimeout(function () {
    clearInterval(si);
}, 2000);

// The clearInterval() clears the setInterval
//  ‘si’ after 500 ms, then function A is 
// executed four times. 

// Output:
// Hello World!
// Hello World!
// Hello World!
// Hello World!

// clearTimeout() method: It is used to cancel 
// the Immediate object created by the setTimeout() method. 
// si1 is cleared by clearTimeout()
let si1 = setTimeout(function A() {
    return console.log("Hello World!");
}, 3000);
// only si2 is executed
let si2 = setTimeout(function B() {
    return console.log("Hello Geeks!");
}, 3000);
clearTimeout(si1);
// Only setInterval ‘si2’ is executed as ‘si1’ 
// is cleared by the clearTimeout() method. 
// Output:
// Hello Geeks!

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Importing and exporting files are important 
// parts of any programming language. Importing 
// functions or modules enhances the reusability 
// of code. When the application grows in size, 
// maintaining a single file with all the functions 
// and logic becomes difficult. It also hinders 
// the process of debugging. Therefore, it is 
// good practice to create separate files for 
// specific functions and later import them as 
// per requirement. Node.js also allows importing 
// and exporting functions and modules. Functions 
// in one module can be imported and called in 
// other modules saving the effort to copy function 
// definitions into the other files. The module can 
// be edited or debugged separately making it easier 
// to add or remove features.

// Exporting a Module: Filename: func.js
module.exports = { add }
// add is a function 

// Importing a Module:require() 
// The result returned by require() is stored 
// in a variable which is used to invoke 
// the functions using the dot notation. 

// Filename: main.js
// Importing the func.js module 
// The ./ says that the func module 
// is in the same directory as  
// the main.js file 
const f = require('./func');

// Require returns an object with add() 
// and stores it in the f variable  
// which is used to invoke the required  
const result = f.add(10, 5);

console.log('The result is:', result);
// Output:
// The result is: 15

// Importing multiple functions from
//  local file: Filename: func.js
function add(x, y) { ... )
function subtract(x, y) (.....}
module.exports = { add, subtract };
// Filename: main.js
const f = require('./func');
console.log(f.add(4, 4));
console.log(f.subtract(8, 4));

// We can also use the destructuring syntax 
// to unpack the properties of the object 
// returned by require() function and store 
// them in respective variables.
const { add, subtract } = require('./func');
console.log(add(4, 4));
console.log(subtract(8, 4));
// Output:
// 8
// 4

// Other ways to export a module
// Defining the functions inside module.exports object.
module.exports = {
  add: function (x, y) {
    return x + y;
  },
  subtract: function (x, y) {
    return x - y;
  },
};

// Defining each function independently 
// as a method of module.exports
module.exports.add = function (x, y) {
  return x + y;
};

module.exports.subtract = function (x, y) {
  return x - y;
};

// Importing a module from a directory: 
// Importing lib.js file inside the directory, 
// by prefixing lib.js with the directory name.
const lib = require('./mod/lib');

////////////////////////////////////////////////////////////////////////////////////////////////////

// Node.js URL() Method
// The ‘url’ module provides utilities for 
// URL resolution and parsing. The getters 
// and setters implement the properties of 
// URL objects on the class prototype, and 
// the URL class is available on the global object.

// The new URL() 
// method is an inbuilt application programming 
// interface of the URL module which creates 
// a new URL object by parsing the input 
// relative to the base. If the base is
//  passed as a string, it will be parsed 
// equivalent to new URL(base).

new URL(input[, base])

// The ‘url’ module can be accessed using:
const url = require('url');

// input <string>: It is the input which 
// is string type that is used to parse 
// the absolute or relative input URL. 
// The base is required if the input is 
// relative and ignored if the input is absolute.

// base <string> | <URL>: It is the base 
// URL which is either of string type or URL, 
// used to resolve against if the input is 
// absolute or not.

// Return Value: It returns the new URL 
// generated along with an array of data 
// like hostname, protocol, pathname, etc.  

const url = require('url');
const parseURL = url.parse(
    'https://geeksforgeeks.org:3000/p/a/t/h?query=string#hash');
console.log("1 =>", parseURL)

// Prints parsed URL 
const newUrl1 = new URL('https://gfg.com');
// prints https://xn--g6w251d/ 
console.log("2 =>", newUrl1.href)


const url = require('url');
const newUrl = new URL(
    'https://geeksforgeeks.org/p/a/t/h?query=string#hash');
// url array in JSON Format 
console.log(newUrl);
const myUR = url.parse(
    'https://geeksforgeeks.org/:3000/p/a/t/h?query=string#hash');
console.log(myUR);
console.log(URL === require('url').URL);
const myURL1 = new URL(
    { toString: () => 'https://geeksforgeeks.org/' });
console.log(myURL1.href)
// Output:
// URL { href: ‘https://geeksforgeeks.org/p/a/t/h?query=string#hash’, 
// origin: ‘https://geeksforgeeks.org’, protocol: ‘https:’, username: ”, 
// password: ”, host: ‘geeksforgeeks.org’, hostname: ‘geeksforgeeks.org’,
//  port: ”, pathname: ‘/p/a/t/h’, search: ‘?query=string’, 
// searchParams: URLSearchParams { ‘query’ => ‘string’ }, hash: ‘#hash’ } 
// Url { protocol: ‘https:’, slashes: true, auth: null, 
// host: ‘geeksforgeeks.org’, port: null, 
// hostname: ‘geeksforgeeks.org’, hash: ‘#hash’, 
// search: ‘?query=string’, query: ‘query=string’, 
// pathname: ‘/:3000/p/a/t/h’, 
// path: ‘/:3000/p/a/t/h?query=string’, 
// href: ‘https://geeksforgeeks.org/:3000/p/a/t/h?query=string#hash’ } 
// true https://geeksforgeeks.org/

//** Custom Web Crawler for Data Extraction **:
// Web crawlers(also known as web spiders or bots) are 
// used to navigate websites and extract specific information.
// The `URL()` method is essential for parsing URLs during 
// web crawling.Let's consider a scenario where you're 
// building a custom web crawler to collect data from news articles:

    const fetch = require('node-fetch'); // For making HTTP requests
    const { URL } = require('url'); // For parsing URLs

    async function crawlNewsArticles(startingUrl) {
        try {
            const response = await fetch(startingUrl);
            const htmlContent = await response.text();

            // Parse the HTML content to find article links
            const articleLinks = extractArticleLinks(htmlContent);

            // Visit each article link and extract relevant data
            for (const link of articleLinks) {
                const articleUrl = new URL(link, startingUrl);
                const articleResponse = await fetch(articleUrl);
                const articleHtml = await articleResponse.text();

                // Extract article title, author, and content
                const articleTitle = extractTitle(articleHtml);
                const articleAuthor = extractAuthor(articleHtml);
                const articleContent = extractContent(articleHtml);

                console.log(`Article: ${ articleTitle } `);
                console.log(`Author: ${ articleAuthor } `);
                console.log(`Content: ${ articleContent } \n`);
            }
        } catch (error) {
            console.error(`Error crawling: ${ error.message } `);
        }
    }

    // Usage
    const startingUrl = 'https://example-news-site.com';
    crawlNewsArticles(startingUrl);

//    In this example:
// - The`URL()` method is used to construct absolute URLs 
// from relative article links found in the HTML content.
//- The web crawler visits each article URL, extracts 
// relevant data(title, author, content), and logs it.

// 2. ** Custom URL Shortener Service **:
// Suppose you're building a URL shortener service (like bit.ly) 
// that converts long URLs into shorter ones. The `URL()` method 
// helps validate and manipulate user-provided URLs:

function shortenUrl(longUrl) {
    try {
        const url = new URL(longUrl);

        // Generate a unique short code (e.g., using a hash function)
        const shortCode = generateShortCode(url);

        // Save the mapping between short code and long URL in a database
        saveMapping(shortCode, longUrl);

        console.log(`Shortened URL: https://short.link/${shortCode}`);
    } catch (error) {
        console.error(`Invalid URL: ${error.message}`);
    }
}

// Usage
const longUrlToShorten = 'https://example.com/very/long/url/to/shorten';
shortenUrl(longUrlToShorten);

//- The `URL()` method validates the long URL provided by the user.
//- A unique short code is generated (e.g., using a hash function) 
// and associated with the long URL.

// 3. **Custom Routing in Express.js Applications**:
//When building an Express.js application, you often define 
// routes based on user input. The `URL()` method helps parse 
// and extract relevant information from URLs:

const express = require('express');
const { URL } = require('url');

const app = express();

app.get('/blog/:postId', (req, res) => {
    const postId = req.params.postId;
    // Fetch blog post content based on the postId
    // ...

    res.send(`Blog post ${postId}: ${blogPostContent}`);
});

// Start the Express server
app.listen(3000, () => {
    console.log('Server listening on port 3000');
});

//- The `URL()` method is not directly used, but Express.js
// internally uses it to parse route parameters (e.g., `: postId`)
// from the URL.
//- When a user visits `/ blog / 123`, the server extracts
// the `postId` from the URL and fetches the corresponding
// blog post content.

// Remember that the `URL()` method is versatile and can
// be used for various URL-related tasks beyond simple parsing.
// Whether it's web crawling, URL shortening, or routing,
// understanding how to work with URLs is essential for web developers! 🌟

// Node url.toString() Method
// The url.toString() method is an inbuilt 
// application programming interface(API) 
// of the URL module within the Node.JS. 
// The url.toString() method is used to 
// return the serialized URL. The returned 
// value is equivalent to that of url.href 
// and url.toJSON(). Syntax:
url.toString()
// Parameters: This method accepts single parameter 
// as mentioned above and described below:

// url: It is an object created by URL constructor.

// Example 1:
// Creating an URL object with URL constructor.  
const url = new URL("https://www.geeksforgeeks.org");

// Using toString() method  
console.log(url.toString());
// Output:
// https://www.geeksforgeeks.org


// 1. ** Custom Web Crawler for Data Extraction **:
//Web crawlers(also known as web spiders or bots) are 
// used to navigate websites and extract specific information.
// The `URL()` method is essential for parsing URLs during 
// web crawling.Let's consider a scenario where you're 
// building a custom web crawler to collect data from news articles:

// ```javascript
    const fetch = require('node-fetch'); // For making HTTP requests
    const { URL } = require('url'); // For parsing URLs

    async function crawlNewsArticles(startingUrl) {
        try {
            const response = await fetch(startingUrl);
            const htmlContent = await response.text();

            // Parse the HTML content to find article links
            const articleLinks = extractArticleLinks(htmlContent);

            // Visit each article link and extract relevant data
            for (const link of articleLinks) {
                const articleUrl = new URL(link, startingUrl);
                const articleResponse = await fetch(articleUrl);
                const articleHtml = await articleResponse.text();

                // Extract article title, author, and content
                const articleTitle = extractTitle(articleHtml);
                const articleAuthor = extractAuthor(articleHtml);
                const articleContent = extractContent(articleHtml);

                console.log(`Article: ${ articleTitle } `);
                console.log(`Author: ${ articleAuthor } `);
                console.log(`Content: ${ articleContent } \n`);
            }
        } catch (error) {
            console.error(`Error crawling: ${ error.message } `);
        }
    }

    // Usage
    const startingUrl = 'https://example-news-site.com';
    crawlNewsArticles(startingUrl);
//     ```

//    In this example:
// - The`URL()` method is used to construct absolute URLs 
// from relative article links found in the HTML content.
//- The web crawler visits each article URL, extracts 
// relevant data(title, author, content), and logs it.

// 2. ** Custom URL Shortener Service **:
//Suppose you're building a URL shortener service 
// (like bit.ly) that converts long URLs into shorter ones. 
// The `URL()` method helps validate and manipulate user-provided URLs:

//     ```javascript
    function shortenUrl(longUrl) {
        try {
            const url = new URL(longUrl);

            // Generate a unique short code (e.g., using a hash function)
            const shortCode = generateShortCode(url);

            // Save the mapping between short code and long URL in a database
            saveMapping(shortCode, longUrl);

            console.log(`Shortened URL: https://short.link/${shortCode}`);
        } catch (error) {
    console.error(`Invalid URL: ${error.message}`);
}
    }

// Usage
const longUrlToShorten = 'https://example.com/very/long/url/to/shorten';
shortenUrl(longUrlToShorten);
// ```

//    In this example:
//- The `URL()` method validates the long URL provided by the user.
//- A unique short code is generated (e.g., using a hash function) 
// and associated with the long URL.

// 3. **Custom Routing in Express.js Applications**:
//When building an Express.js application, you often define 
// routes based on user input. The `URL()` method helps parse 
// and extract relevant information from URLs:

//     ```javascript
const express = require('express');
const { URL } = require('url');

const app = express();

app.get('/blog/:postId', (req, res) => {
    const postId = req.params.postId;
    // Fetch blog post content based on the postId
    // ...

    res.send(`Blog post ${postId}: ${blogPostContent}`);
});

// Start the Express server
app.listen(3000, () => {
    console.log('Server listening on port 3000');
});
// ```

//    In this example:
//- The `URL()` method is not directly used, but Express.js 
// internally uses it to parse route parameters
//  (e.g., `: postId`) from the URL.
//- When a user visits `/ blog / 123`, the server extracts 
// the `postId` from the URL and fetches the corresponding 
// blog post content.

// Remember that the `URL()` method is versatile and can be 
// used for various URL-related tasks beyond simple parsing. 
// Whether it's web crawling, URL shortening, or routing, 
// understanding how to work with URLs is essential 
// for web developers! 🌟

// The url.toJSON() method in the node.js 
// URL module is used to return the serialized 
// URL of the URL object. The return value of 
// this method is equivalent to the URL.href 
// and url.toString() methods. If an URL object 
// is serialized using JSON.stringify() method
//  then it is called automatically. 

url.toJSON()
// Return Value: This method returns 
// the serialized URL of the URL object. 

// Require an URL module
const url = require('url');
// Creating and initializing myURL variable
let urls = [
    new URL('https://www.geeksforgeeks.com'),
    new URL('https://www.google.com'),
    new URL('https://www.mygeeks.com')
];
// Display result
console.log(JSON.stringify(urls));
// Output:
// [
//     "https://www.geeksforgeeks.org/",
//     "https://www.google.com/",
//     "https://www.mygeeks.com/"
// ]

// The url.domainToUnicode() method is 
// an inbuilt application programming interface 
// of class URL with in url module which is used 
// to get the domain for the particular ASCII value. 

const url.domainToUnicode(domain)
// Parameter:s This method takes ASCII value 
// as a parameter which is going to be converted 
// in Unicode. Return value: This method returns 
// the unicode value of the particular domain. 


// Importing the 'url' module 
const http = require('url');

// Getting Unicode value 
// by using domainToUnicode() api 
const ascivalue = http.domainToUnicode(
    "xn--espaol-zwa.com");

// Display result for each value entry 
console.log("Unicode value : " + ascivalue);

// Getting Unicode value 
// by using domainToUnicode() api 
const ascivalue1 = http.domainToUnicode("google.com");

// display result for each value entry 
console.log("\nUnicode value : " + ascivalue1);
// Output:
// ASCII value : xn--espaol-zwa.com
// ASCII value : google.com


// ### Handling Internationalized Domain Names(IDNs)
// #### Problem Statement:
// You're building a multilingual website that allows 
// users to input domain names in their native languages. 
// However, these domain names need to be converted to 
// their corresponding Unicode representations (Punycode) 
// for proper resolution by DNS servers.

// #### Solution:
// The `url.domainToUnicode()` method comes in handy 
// when dealing with IDNs.It converts an ASCII - encoded 
// domain(such as "xn--espaol-zwa.com") to its Unicode 
// representation("español.com").

const { domainToUnicode } = require('url');

function convertToUnicode(domain) {
    try {
        const unicodeDomain = domainToUnicode(domain);
        console.log(`Unicode value for ${ domain }: ${ unicodeDomain } `);
    } catch (error) {
        console.error(`Error converting domain: ${ error.message } `);
    }
}

// Usage
convertToUnicode('xn--espaol-zwa.com'); // Converts to "español.com"
convertToUnicode('google.com'); // Remains unchanged

// Output:
// Unicode value for xn--espaol-zwa.com: español.com
// Unicode value for google.com: google.com
// In this example:
// - We use `url.domainToUnicode()` to convert an ASCII - encoded domain("xn--espaol-zwa.com") to its Unicode representation("español.com").
// - The method ensures that domain names with non - ASCII characters are correctly represented.

// Remember that handling IDNs is crucial for creating 
// a globally accessible and user - friendly web.
// The `url.domainToUnicode()` method simplifies this process, 
// especially when dealing with multilingual websites or applications.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// http module 
// To make HTTP requests in Node.js, there 
// is a built-in module HTTP in Node.js to 
// transfer data over the HTTP. To use the 
// HTTP server in the node, we need to require 
// the HTTP module. The HTTP module creates 
// an HTTP server that listens to server ports
//  and gives a response back to the client.

// Filename: max.js 
const http = require('http');

// Create a server
http.createServer((request, response) => {
    // Sends a chunk of the response body
    response.write('Hello World!');
    // Signals the server that all of
    // the response headers and body
    // have been sent
    response.end();
}).listen(3000); // Server listening on port 3000

console.log("Server started on port 3000");
// Step to run this program: Run this max.js 
// file using the below command:
// node max.js

// To make requests via the HTTP module http.request() method is used. 
// Syntax:
http.request(options[, callback])

// Example 2: In this example, we will see to make 
// requests via the HTTP module http.request() method. 

// Filename: max.js 
const http = require('http');

let options = {
    host: 'www.geeksforgeeks.org',
    path: '/courses',
    method: 'GET'
};

// Making a get request to
// 'www.geeksforgeeks.org'
http.request(options, (response) => {
    // Printing the statusCode
    console.log(`STATUS: ${response.statusCode}`);
}).end();
// Step to run this program: Run this max.js
// file using the below command:
// node max.js

// Node.js http.ClientRequest.abort() Method
// Client Request within http module which is 
// used to abort(cancel) the client request.


// ### Customizing HTTP Requests with `http.ClientRequest.abort()`

// #### Problem Statement:
// You're building a web application that makes 
// asynchronous HTTP requests to external APIs, services, 
// or microservices. Occasionally, you need to cancel 
// ongoing requests due to user interactions 
// (e.g., canceling a search query) or other dynamic conditions.
// #### Solution:
// The `http.ClientRequest.abort()` method allows you 
// to gracefully abort an ongoing HTTP request. By using 
// this method, you can prevent unnecessary data transfer,
//  release resources, and handle cancellation scenarios effectively.

// Let's consider a scenario where you're making asynchronous 
// requests to an external API:

const http = require('http');

function fetchDataFromApi(apiUrl) {
  return new Promise((resolve, reject) => {
    const request = http.request(apiUrl, (response) => {
      let data = '';

      response.on('data', (chunk) => {
        data += chunk;
      });

      response.on('end', () => {
        resolve(data);
      });
    });

    request.on('error', (error) => {
      reject(error);
    });

    // Simulate a user action (e.g., cancel button)
    setTimeout(() => {
      request.abort();
    }, 2000); // Abort the request after 2 seconds

    request.end();
  });
}

// Usage
const apiUrl = 'http://api.example.com/data';
fetchDataFromApi(apiUrl)
  .then((result) => {
    console.log('Received data:', result);
  })
  .catch((error) => {
    console.error('Error fetching data:', error.message);
  });
// - We create an asynchronous function (`fetchDataFromApi`) 
// that makes an HTTP request to an external API.
// - The `request.abort()` method is called after 2 seconds (simulating a user action).
// - If the request is not completed within the specified 
// time, it is gracefully aborted.

// Remember that handling asynchronous requests and managing 
// cancellations is crucial for responsive web applications. 
// The `http.ClientRequest.abort()` method ensures that you 
// can stop ongoing requests when needed, improving user 
// experience and resource utilization. 🚀🌐

//  Filename: index.js
// Importing http module
const http = require('http');

// Creating an HTTP server
http.createServer((req, res) => { })
  .listen(3000, '127.0.0.1', () => {
    // Getting client request
    const req = http.request({
      port: 3000,
      host: '127.0.0.1',
    });
    // Aborting the request
    // by using abort() api
    req.abort()
    // Emit the message
    req.on('abort', () => {
      console.log("client request is aborted")
      process.exit(0);
    })
  });
// node index.js


// Importing http module
const http = require('http');

// Create an HTTP server
const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('okay');
});

// Now that server is running
server.listen(3000, '127.0.0.1', () => {
  console.log("Server is started")
  // Making a request
  const options = {
    port: 3000,
    host: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };
  // Getting client request
  const req = http.request(options);
  // Aborting the request
  // by using abort() method
  req.abort()
  // Emit the message
  req.on('abort', () => {
    console.log("client request is aborted")
  })
});

// Run index.js file using below command:
node index.js

// The http.ClientRequest.connection
// is used to get the reference of underlying 
// client request socket.

//The `http.ClientRequest.connection` property 
// in Node.js provides access to the underlying client request 
// socket. While it might not be an everyday use case, 
// there are scenarios where it can shine. Let's explore a couple of examples:

// 1. **monitor HTTP Requests**:
//- When you need to instrument / monitor HTTP requests, 
// understanding the `http.ClientRequest` object becomes crucial.
//- Imagine you're building a performance monitoring tool 
// for your web application. You want to track the time 
// taken for each HTTP request and log it.
//- By accessing `req.connection`, you can listen to 
// events like `socket`, `connect`, and `close`. 
// These events allow you to measure latency, 
// detect connection issues, and handle retries.

const http = require('http');

const server = http.createServer((req, res) => {
  // Your regular request handling logic here
});

server.listen(3000, '127.0.0.1', () => {
  const options = {
    port: 3000,
    host: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };

  const req = http.request(options);
  const clientSocket = req.connection;

  console.log("Request socket:", clientSocket);
  process.exit(0);
});
//- In this example, we create an HTTP server 
// and initiate a custom request. By accessing 
// `req.connection`, we gain insights into the underlying socket.

// 2. **Handling Connection State**:
//- Suppose you're building a real-time chat application 
//  using WebSockets. You want to manage WebSocket 
//  connections efficiently.
//- The `http.ClientRequest.connection` property allows 
// you to check whether a connection was requested.
//- Consider this scenario:

const http = require('http');

http.createServer((req, res) => {
  // Your regular request handling logic here
}).listen(3000, '127.0.0.1', () => {
  const req = http.request({
    port: 3000,
    host: '127.0.0.1',
  });

  if (req.connection) {
    console.log("Requested for connection");
  } else {
    console.log("Not requested for connection");
  }

  process.exit(0);
});

//- In this example, we check if the connection was 
// requested explicitly. Depending on the outcome, 
// you can handle WebSocket upgrades or other custom logic.

// Remember that these examples are simplified for 
// illustration. In real-world applications, you'd 
// integrate these concepts into more complex scenarios.
//  The `http.ClientRequest.connection` property provides 
// a powerful tool for diving deeper into HTTP 
// interactions and managing connections effectively¹².

// The http.ClientRequest.protocol 
// is used to get the object of client request protocol.

// explore a couple of real-world use cases where it shines:

// 1. ** Customizing WebSsocket Upgrades **:
// - Imagine you're building a real-time chat application 
// that uses WebSockets. When a client initiates 
// a WebSocket connection, it's essential to handle 
// the upgrade process correctly.
//- The`http.ClientRequest.protocol` property allows you 
// to customize the protocol during the WebSocket handshake.
const http = require('http');

const server = http.createServer((req, res) => {
  // Your regular request handling logic here
});

server.listen(3000, '127.0.0.1', () => {
  const options = {
    port: 3000,
    host: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };

  const req = http.request(options);
  req.protocol = 'HTTP'; // Customize the protocol
  const v = req.protocol;
  console.log("Protocol:", v);
  process.exit(0);
});

//- In this example, we set the protocol to `'HTTP'` during 
// the WebSocket handshake.You can adapt this to your specific use case.

// 2. ** Conditional Behavior Based on Protocol **:
// - Suppose you're building an API gateway that handles 
// requests from various clients (e.g., web browsers, 
// mobile apps, IoT devices).
//- By examining the`req.protocol`, you can conditionally 
// route requests or apply different middleware based on the protocol.

const http = require('http');

http.createServer((req, res) => {
  if (req.protocol === 'HTTP') {
    // Handle HTTP requests
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Okay');
  } else if (req.protocol === 'HTTPS') {
    // Handle HTTPS requests
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Secure connection');
  } else {
    // Handle other protocols
    res.writeHead(400, { 'Content-Type': 'text/plain' });
    res.end('Unsupported protocol');
  }
}).listen(3000, '127.0.0.1');


//- In practice, you'd likely have more sophisticated logic, 
// but this demonstrates how you can tailor behavior 
// based on the protocol.

// Remember that these examples are intentionally 
// non - obvious and simplified for clarity.
// In real - world applications, you'd integrate 
// these concepts into more complex scenarios. 
// The `http.ClientRequest.protocol` property 
// provides flexibility for handling different 
// protocols and customizing behavior accordingly¹.

// The http.ClientRequest.aborted 
//is used to check if the client 
// request has been aborted or not.

// Example 1: Filename: index.js
// Importing http module 
const http = require('http');

// Create an HTTP server 
const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('okay');
});

// Now that server is running 
server.listen(3000, '127.0.0.1', () => {

  console.log("Server is Started")
  // Make a request 
  const options = {
    port: 3000,
    host: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };
  // Getting client request 
  const req = http.request(options);
  // Aborting the request 
  // by using abort() api 
  req.abort()
  // checking if the client request 
  // has been aborted or not 
  // by using aborted api 
  if (req.aborted)
    console.log("client request has been aborted")
  else
    console.log("client request has not been aborted")
});
// Run index.js file using below command:
// node index.js


// Example 2: Filename: index.js
// Importing http module 
const http = require('http');

// Creating an HTTP server 
http.createServer((req, res) => { })
  .listen(3000, '127.0.0.1', () => {
    // Getting client request 
    const req = http.request({
      port: 3000,
      host: '127.0.0.1',
    });
    // Checking if the client request 
    // has been aborted or not 
    // by using aborted api 
    if (req.aborted)
      console.log("client request has been aborted")
    else
      console.log("client request has not been aborted")

    process.exit(0)
  });
// Run index.js file using below command:

// node index.js

// To make HTTP requests in Node.js, there 
// is a built-in module HTTP in Node.js to 
// transfer data over the HTTP. To use the 
// HTTP server in the node, we need to require 
// the HTTP module. The HTTP module creates 
// an HTTP server that listens to server ports 
// and gives a response back to the client.

// Importing http module 
const http = require('http');

// Importing agentkeepalive module 
const Agent = require('agentkeepalive');

// Creating new agent 
const keepAliveAgent = new Agent({});

console.log(keepAliveAgent.maxSockets);

// Options object 
const options = {
    host: 'geeksforgeeks.org',
    port: 80,
    path: '/',
    method: 'GET',
    agent: keepAliveAgent,
};

// Requesting via http server module 
const req = http.request(options, (res) => {
    // Printing statuscode 
    console.log("StatusCode: ", res.statusCode);
});

req.end();

// Output:
// Infinity
// StatusCode:  301


// Node.js HTTP Module

// Class: http.Agent
// Class: http.Agent Method

// Description
// new Agent()	            The new Agent({}) (Added in v0.3.4) method is an inbuilt application programming interface
// createConnection()	    This is used to produce a socket or stream which is further used for HTTP requests and by default,
// maxSockets()	            This determines how many concurrent sockets the agent can have open per origin.
// maxFreeSockets()	    the ‘Http‘ module sets the maximum number of sockets that will be left open in the free state.

// Class: http.ClientRequest
// Class: http.Server Properties

// Description
// connection 	            Get the reference of the underlying client request socket.
// aborted	            Check if the client’s request has been aborted or not.
// path 	            Get the request path for the particular client request.
// reusedSocket 	    Check if the request is sent through a reused socket.
// socket	            Get a Proxy object that acts as a net.Socket.

// Class: http.Server Methods
// Description

// abort()	        It aborts the client’s request.
// protocol()	    	Get the object of the client request protocol.
// setNoDelay()	    	Set the socket such as delaying excessive requests while requests are being limited is not desired.
// removeHeader() 	Remove a header that’s already defined in the headers object.
// setHeader() 	    	Set the object of the header.
// setTimeout() 	Get the request time out for the client request.

//  Class: http.Server
// Class: http.Serverv Properties
// Description

// timeout 	        Get the default Timeout value in milliseconds.
// maxHeadersCount	Get the maximum incoming headers to count.
// listening	    	Check if the server is listening for connection or not.
// keepAliveTimeout	Get the number of milliseconds of inactivity a server needs to wait for additional incoming data.

// Class: http.Server Methods
// Description
// setTimeout()	            Set the time-out value for the socket.
// close()	            Stop the server from accepting new connections.
// headersTimeout()	    Get the time the parser will wait to receive the complete HTTP headers.
// listen()	            Start the server from accepting new connections.

//  Class: http.ServerResponse
// Class: http.ServerResponse Properties

// Description
// writableFinished 	    	Check if all the data has been flushed or not.
// writableEnded	        Check if response.end() has been called or not.
// statusCode 	            	This property controls the status code that will be sent to the client when the headers get flushed.
// headersSent	            	Check if the header has been sent or not.
// statusMessage 	        Control the status message that will be sent to the client when the headers get flushed.

// Class: http.ServerResponse Methods
// Description
// setTimeout() 	        Set the Socket’s timeout value to msecs (Milliseconds).
// writeProcessing()	    	Send an HTTP/1.1 102 Processing message to the client.
// sendDate()	            	Check if the date header has been sent or not.
// end()	                Send the signal to the server that all the header has been sent.
// connection()	            	Get the response socket of this HTTP connection.

//  Class: http.IncomingMessage
//  Class: http.IncomingMessage Methods

// Description
// URL()	        Get the request URL string which is also used for validating the particular URL.
// trailers()	    	Get the request/response trailers to object.
// statusMessage()	Get the HTTP response status message.
// method()	        Get the type of request method as a string.
// rawHeaders()	    	Get the raw request/response headers to list exactly as they were received.
// statusCode()	    	Get the 3-digit HTTP response status code.
// rawTrailers()	Get the raw request/response trailer keys and values exactly as they were received.
// aborted()	    	Check if the request has been aborted or not.
// headers()	    	Get all the request/response headers to the object.
// httpVersion()	Get the HTTP version sent by the client. The most commonly used version is HTTP/1.1.
// complete()	    	Check if a complete HTTP message has been received and successfully parsed or not.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Node.js http2session.state Method
// http2 module which is used to return miscellaneous 
// information about the current state of the Http2Session.

// get certificates of private-key.pem and public-cert.pem from 
//http2session.state geeksforgeeks 

// Example 1: Filename: index.js

// Node.js program to demonstrate the 
// http2session.state method 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate 
// for access 
const options = {
    key: fs.readFileSync('private-key.pem'),
    cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
    stream.respond({
        ':status': 200,
        'content-type': 'text/plain'
    });

    stream.write('hello ');

    const http2session = stream.session;
    // Getting state associated with this  
    // session by using state method 
    const status = http2session.state;

    stream.end("local window size : "
        + status.localWindowSize);

    // Stopping the server 
    // by using the close() method 
    server.close(() => {
        console.log("server localSettings");
    })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
    'http://localhost:8000');

const req = client.request({
    ':method': 'GET',
    ':path': '/'
});

req.on('response', (responseHeaders) => {
    console.log("status : "
        + responseHeaders[":status"]);
});

req.on('data', (data) => {
    console.log('Received: %s ',
        data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
    client.close(() => {
        console.log("client localSettings");
    })
});
// Run the index.js file using the following command:
node index.js
// Output:
// status : 200
// Received: hello
// Received: local window size : 65535
// client localSettings
// server localSettings


// 1. **Customizing WebSocket Upgrades**:
//- Imagine you're building a real-time chat application 
// that uses WebSockets. When a client initiates 
// a WebSocket connection, it's essential to handle 
// the upgrade process correctly.
//- The `http2session.state` property allows you to 
// customize the protocol during the WebSocket handshake.

//- Here's an example:

//      ```javascript
const http2 = require('http2');
const fs = require('fs');

const options = {
    key: fs.readFileSync('private-key.pem'),
    cert: fs.readFileSync('public-cert.pem'),
};

const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
    stream.respond({
        ':status': 200,
        'content-type': 'text/plain',
    });

    stream.write('hello ');

    const http2session = stream.session;
    const status = http2session.state;

    stream.end(`local window size: ${status.localWindowSize}`);
});

server.listen(3000, '127.0.0.1');
//      ```

//- In this example, we set up an HTTP/2 server with 
// custom certificates. When a client initiates a stream 
// (which could be a WebSocket upgrade), we access
//  `http2session.state` to retrieve information about 
// the session, such as the local window size.

// 2. **Monitoring and Debugging**:
//- Suppose you're building a performance monitoring tool 
// for your HTTP/2 server. You want to track various session-related metrics.
//- By examining `http2session.state`, you can gather 
// insights into the session's state, including flow 
// control parameters, stream counts, and other relevant details.

//- Here's a simplified snippet:
//      ```javascript
const http2 = require('http2');
const server = http2.createServer();

server.on('stream', (stream) => {
    // Your regular stream handling logic here

    const http2session = stream.session;
    const state = http2session.state;

    console.log('Session ID:', http2session.id);
    console.log('Local window size:', state.localWindowSize);
    console.log('Stream count:', state.streamCount);
    // ... other relevant metrics

    stream.respond({
        ':status': 200,
        'content-type': 'text/plain',
    });
    stream.end('Hello, HTTP/2!');
});

server.listen(3000, '127.0.0.1');
// ```

//- In practice, you'd likely integrate this with 
// a more comprehensive monitoring system.

// Remember that these examples are intentionally 
// non-obvious and simplified for clarity. 
// In real-world applications, you'd integrate these 
// concepts into more complex scenarios. 
// The `http2session.state` property provides flexibility 
// for handling HTTP/2 sessions and gathering 
// session-related information¹.

// The http2session.socket which is used to return a Proxy 
// object that acts as a net.Socket.
// This method return a Proxy object that acts as a net.Socket.

// get the certificates from http2session.socket  gfg


// http2session.socket method 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  const http2session = stream.session;

  // Getting socket associated with this session 
  // by using socket method 
  const status = http2session.socket;

  stream.end("address family of socket : "
    + status.address().family);

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server localSettings");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request(
  { ':method': 'GET', ':path': '/' });

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client localSettings");
  })
});
Run the index.js file using the following command:

  node index.js
// Output:

// status: 200
// Received: hello
// Received: address family of socket: IPv6
// client localSettings
// server localSettings


// 1. ** Customizing WebSocket Upgrades **:
// - Imagine you're building a real-time chat 
// application that uses WebSockets. When a client 
// initiates a WebSocket connection, it's essential 
// to handle the upgrade process correctly.
//- The`http2session.socket` property allows you 
// to customize the protocol during the WebSocket handshake.

//- Here's an example:
//   ```javascript
const http2 = require('http2');
const fs = require('fs');

const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain',
  });

  stream.write('hello ');

  const http2session = stream.session;
  const status = http2session.socket;

  stream.end(`address family of socket: ${status.address().family} `);
});

server.listen(3000, '127.0.0.1');
//      ```

//- In this example, we set up an HTTP / 2 server 
// with custom certificates.When a client initiates 
// a stream(which could be a WebSocket upgrade), 
// we access `http2session.socket` to retrieve 
// information about the socket, such as its address family.

// 2. ** Monitoring and Debugging **:
// - Suppose you're building a performance monitoring 
// tool for your HTTP/2 server. You want to track 
// various session-related metrics.
// - By examining`http2session.socket`, you can gather 
// insights into the socket's state, address, and 
// other relevant details.

// - Here's a simplified snippet:
// ```javascript
const http2 = require('http2');
const server = http2.createServer();

server.on('stream', (stream) => {
  // Your regular stream handling logic here

  const http2session = stream.session;
  const socket = http2session.socket;

  console.log('Session ID:', http2session.id);
  console.log('Address family:', socket.address().family);
  // ... other relevant metrics

  stream.respond({
    ':status': 200,
    'content-type': 'text/plain',
  });
  stream.end('Hello, HTTP/2!');
});

server.listen(3000, '127.0.0.1');
//      ```

// - In practice, you'd likely integrate this
// with a more comprehensive monitoring system.

// Remember that these examples are intentionally
// non - obvious and simplified for clarity.
// In real - world applications, you'd integrate
// these concepts into more complex scenarios.
//  The `http2session.socket` property provides
// flexibility for handling HTTP/2 sessions
// and gathering socket-related information¹⁵..


// The http2session.remoteSettings is 
// used to get a prototype-less object describing 
// the current remote settings of this Http2Session.


// Example 1: Filename: index.js 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server
// by using http2.createServer() method
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  const http2session = stream.session;

  // Getting remote of this session
  // by using remoteSettings method
  const status = http2session.remoteSettings;

  stream.end("header table size : "
    + status.headerTableSize);

  // Stopping the server
  // by using the close() method
  server.close(() => {
    console.log("server localSettings");
  })
});

server.listen(8000);

// Creating and initializing client
// by using tls.connect() method
const client = http2.connect(
  'http://localhost:8000');

const req = client.request(
  { ':method': 'GET', ':path': '/' });

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client localSettings");
  })
});
// Run the index.js file using the following command:

// node index.js
// Output:
// status : 200
// Received: hello
// Received: header table size : 4096
// client localSettings
// server localSettings

// The http2session.destroyed is
// used to check if the session is destroyed or not.

const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  const http2session = stream.session;

  stream.end("session protocol : "
    + http2session.alpnProtocol);

  // Callback for close event 
  http2session.on('close', () => {

    const status = http2session.destroyed;

    if (status)
      console.log("session is destroyed");
    else
      console.log("session is not destroyed");
  })

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server destroyed");
    http2session.destroy();
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request(
  { ':method': 'GET', ':path': '/' });

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Run the index.js file using the following command:

//   node index.js
// Output:

// status: 200
// Received: hello
// Received: session protocol: h2c
// client destroyed
// server destroyed
// session is destroyed

// The http2session.type is  used to return the type of 
// session instance used in the peer process.

// this method return 
// the type of session instance used 
// in the peer process.


// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate
// for access
const options = {
    key: fs.readFileSync('private-key.pem'),
    cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server
// by using http2.createServer() method
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
    stream.respond({
        ':status': 200,
        'content-type': 'text/plain'
    });
    stream.write('hello ');

    const http2session = stream.session;

    // Getting type of the particular session
    // by using type method
    const status = http2session.type;

    if (status)
        stream.end("This session is of "
            + "NGHTTP2_SESSION_CLIENT type");
    else
        stream.end("This session is of "
            + "NGHTTP2_SESSION_SERVER type");

    // Stopping the server by
    // using the close() method
    server.close(() => {
        console.log("server localSettings");
    })
});

server.listen(8000);

// Creating and initializing client
// by using tls.connect() method
const client = http2.connect(
    'http://localhost:8000');

const req = client.request({
    ':method': 'GET',
    ':path': '/'
});

req.on('response', (responseHeaders) => {
    console.log("status : "
        + responseHeaders[":status"]);
});

req.on('data', (data) => {
    console.log('Received: %s ',
        data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
    client.close(() => {
        console.log("client localSettings");
    })
});
// Run the index.js file using the following command:
//node index.js

// Output:
// status: 200
// Received: hello
// Received: This session is of NGHTTP2_SESSION_SERVER type
// client localSettings
// server localSettings


// The http2session.encrypted is used 
// to check if the Http2Session is 
// connected with a TLSSocket or not.

//This method return true if 
// and only if this Http2Session is connected 
// with a TLSSocket otherwise false.


// Example 1: Filename: index.js
// Node.js program to demonstrate the
// http2session.encrypted method
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate
// for access
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server
// by using http2.createServer() api
const server = http2.createServer(options);


server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  const http2session = stream.session;

  const status = http2session.encrypted;

  if (status)
    stream.end("session is associated "
      + "with TLSsocket");
  else
    stream.end("session is not associated"
      + " with other kind of socket");


  // Stopping the server by
  // using the close() method
  server.close(() => {
    console.log("server encrypted");
  })
});
server.listen(8000);


// Creating and initializing client
// by using tls.connect() method
const client = http2.connect(
  'http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {

  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {

  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client encrypted");
  })
});
// Output:

// status : 200
// Received: hello
// Received: session is not associated with other kind of socket
// client encrypted
// server encrypted

// The http2session.localSettings  is used to get 
// a prototype-less object describing 
// the current local settings of this Http2Session.

//This method returns 
// a prototype-less object describing 
// the current local settings of this Http2Session.


// Example 1: Filename: index.js
// Node.js program to demonstrate the
// http2session.localSettings Method
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate
// for access
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server
// by using http2.createServer() api
const server = http2.createServer(options);


server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  const http2session = stream.session;

  // Getting local setting by
  // using localSetting API
  const status = http2session.localSettings;

  stream.end("Max header size : "
    + status.maxHeaderListSize);

  // Stopping the server by
  // using the close() method
  server.close(() => {
    console.log("server localSettings");
  })
});
server.listen(8000);

// Creating and initializing client
// by using tls.connect() method
const client = http2.connect(
  'http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {

  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {

  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client localSettings");
  })

});

// Output:
// status : 200
// Received: hello
// Received: Max header size : 4294967295
// client localSettings
// server localSettings

// The http2session.pendingSettingsAck  is  
// used to indicate whether 
// the Http2Session is currently waiting 
// for acknowledgment of a sent SETTINGS frame.

//This method returns true after 
// calling the http2session.pendingsettingsAck() 
// method otherwise false if all sent SETTINGS 
// frames have been acknowledged.


// Example 1: Filename: index.js
// Node.js program to demonstrate the 
// http2session.pendingSettingsAck API 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate 
// for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() api 
const server = http2.createServer(options);


server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  const http2session = stream.session;

  // Checking if the acknowledgement is received 
  // or not by using pendingSettingsAck API 
  const status = http2session.pendingSettingsAck;


  if (status)
    stream.end("all frame is not  acknowledged")
  else
    stream.end("all frames are acknowledged")

  // Stopping the server by 
  // using the close() method 
  server.close(() => {
    console.log("server localSettings");
  })
});
server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client localSettings");
  })
});
// Output:
// status : 200
// Received: hello
// Received: all frame is not  acknowledged
// client localSettings
// server localSettings

// Node.js http2session.close() Method
// is used to close this particular session.
const http2session.close([callback])
//callback function which 
// is executed when this function call is made.

// This method returns nothing 
// but a callback function for further operations.


// Example 1: Filename: index.js 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server
// by using http2.createServer() method
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Getting session object
  // by using session method
  const http2session = stream.session;

  // Getting alpnProtocol of this session
  // by using alpnProtocol method
  const alpnProtocol = http2session.alpnProtocol;

  stream.end("session protocol : " + alpnProtocol);

  http2session.close(() => {
    console.log("session is closed");
  })

  // Stopping the server
  // by using the close() method
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client
// by using tls.connect() method
const client = http2
  .connect('http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});

// Run the index.js file using the following command:
//   node index.js

// Output:
// server destroyed
// session is closed
// status: 200
// Received: hello
// Received: session protocol: h2c

// The http2session.closed is  used to check if this 
// Http2Session instance has been closed or not.

//This method returns boolean 
// value true if and only if this Http2Session 
// instance has been closed otherwise.


// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Getting session object 
  // by using session method 
  const http2session = stream.session;

  http2session.close()

  // Checking if the session is closed or not 
  const status = http2session.closed;

  if (status)
    stream.end("session is closed");
  else
    stream.end("session is closed");

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2
  .connect('http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
}) 
// Run the index.js file using the following command:
//   node index.js
  
//   Output:
// status: 200
// Received: hello
// server destroyed
// Received: session is closed

// The http2session.unref() is used to return 
// instance of the socket object associated 
// with this session object.
//This method return instance 
// of the socket object associated with this session object.


// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  const http2session = stream.session;

  // Getting instance of the socket 
  // by using unref() method 
  const status = http2session.unref();

  stream.end("socket id : " + stream.id);

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server localSettings");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request({
  ':method': 'GET',
  ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client localSettings");
  })
});
// Run the index.js file using the following command:
// node index.js
// Output:
// status : 200
// Received: hello
// Received: socket id : 1
// client localSettings


// The http2session.destroy() is 
// used to destroy this particular session.
const http2session.destroy([error][, code])
// Parameters: This method takes the following 
// two optional arguments as a parameter:
// error: It is an Error object if 
// the Http2Session is being destroyed due to an error.
// code: It is an HTTP/2 error code otherwise NO_ERROR code.
// Return Value: This method has nothing to return.

// Example 1: Filename: index.js 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server
// by using http2.createServer() method
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Getting session object
  // by using session method
  const http2session = stream.session;

  // Getting alpnProtocol of this session
  // by using alpnProtocol method
  const alpnProtocol = http2session.alpnProtocol;

  stream.end("session protocol : " + alpnProtocol);

  // If any error occur
  http2session.on('error', (code) => {
    console.log(code);
  })

  // Callback for close event
  http2session.on('close', () => {
    console.log("session is destroyed");
  })

  // Stopping the server
  // by using the close() method
  server.close(() => {
    console.log("server destroyed");
    http2session.destroy();
  })
});

server.listen(8000);

// Creating and initializing client
// by using tls.connect() method
const client = http2
  .connect('http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:
// status : 200
// Received: hello
// Received: session protocol : h2c
// client destroyed
// server destroyed
// session is destroyed

// The http2session.connecting is
// used to check if this Http2Session instance 
// is still connecting or not.


// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Getting session object 
  // by using session method 
  const http2session = stream.session;

  // Checking if this session is connecting  
  // or not by using connecting method 
  const status = http2session.connecting;

  if (status)
    stream.end("session is connecting")
  else
    stream.end('session is connecting')

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2
  .connect('http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:
// status: 200
// Received: hello
// Received: session is connecting
// client destroyed
// server destroyed

// Node.js http2session.ping() Method
//is used to sends a PING frame 
// to the connected HTTP/2 peer.

const http2session.ping([payload,]callback)
// Parameters: This method takes the optional 
// ping payload buffer as a parameter.
// Return Value: This method return true if 
// and only if the PING was sent otherwise false.


// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  const http2session = stream.session;

  // Sending ping to http2 peer 
  // by using ping method 
  const status = http2session.ping(
    Buffer.from('abcdefgh'),
    (err, duration, payload) => {
      if (!err) {
        console.log(
          `Ping acknowledged in ${duration} milliseconds`);
        console.log(
          `With payload '${payload.toString()}'`);
      }
    });

  if (status)
    stream.end("ping is sent")
  else
    stream.end("ping is not sent")

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server localSettings");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request(
  { ':method': 'GET', ':path': '/' });

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client localSettings");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:
// status : 200
// Received: hello
// Received: ping is sent
// client localSettings
// server localSettings


// The http2session.setTimeout() is // used to set the duration for a time after 
// which a particular action will take place.
http2session.setTimeout(msecs, callback)


// Example 1: Filename: index.js 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server
// by using http2.createServer() method
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {

  // Getting session object
  // by using session method
  const http2session = stream.session;

  // Haulting session for 3 secs
  // by using setTimeout method
  http2session.setTimeout(3000, () => {
    console.log("Executed after 3 seconds");
  })

  // Stopping the server
  // by using the close() method
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client
// by using tls.connect() method
const client = http2.connect('http://localhost:8000');

const req = client.request(
  { ':method': 'GET', ':path': '/' });

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:
// Executed after 3 seconds
// server destroyed

// Node.js clienthttp2session.request() Method
//used to return the object of ClientHttp2Stream.
clienthttp2session.request(headers[, options])
// Parameters: This method takes the following argument as a parameter.
// header: Header object.
// options: It takes any of the arguments
//  {endStream, exclusive, parent, weight, waitForTrailers}
// Return Value: This method returns the object of ClientHttp2Stream.

// Example 1: Filename: index.js
// Node.js program to demonstrate the
// clienthttp2session.request() method
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate
// for access
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server
// by using http2.createServer() method
const server = http2.createServer(options);

server.on('session', (session) => {

  // Set origin frame
  session.origin('http://localhost:8000');
  console.log("ORIGIN frame is submitted")
});


server.on('stream', (stream, requestHeaders) => {

  // Setting response header to client 
  // by using respond() method
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Checking if header is sent or not
  // by using pushAllowed method
  const status = stream.pushAllowed;

  if (status)
    stream.end("push stream is accepted");
  else
    stream.end("push stream is not accepted");

  // Stopping the server by using the
  // close() method
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client by
// using tls.connect() method
const client = http2.connect(
  'http://localhost:8000');


// Getting object of ClientHttp2Stream 
// by using request() method
const req = client.request({
  ':method': 'GET',
  ':path': '/'
});

req.on('response', (responseHeaders) => {

  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {

  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Output:

// ORIGIN frame is submitted
// status: 200
// Received: hello
// Received: push stream is accepted
// client destroyed
// server destroyed

// Node.js Http2Stream Timeout Event
// The ‘timeout’ Event in the http2 server 
// is emitted if there is no activity on 
// the Http2Stream after the configured 
// number of milliseconds.

// Syntax:
// Event: 'timeout'
// Parameters: This event does not accept any argument as a parameter.
// Return Value: This event returns nothing but a callback function

// Example 1: Filename: index.js
// Node.js program to demonstrate the 
// timeout event 

const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {

  // Setting timeout for the stream  
  // by using setTimeout()  
  stream.setTimeout(3000)

  // Emitting timeout event 
  stream.on('timeout', () => {
    stream.respond({
      ':status': 200,
      'content-type': 'text/plain'
    });

    stream.end("surprise !!!");
  })

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:
// status: 200
// Received: surprise!!!
// client destroyed
// server destroyed

// Node.js Http2Stream close Event
// The ‘close’ Event in http2 server is emitted when 
// the Http2Stream has been destroyed.

// Event: 'close'
// Parameters: This event does not accept any argument as a parameter.
// Return Value: This event returns nothing but a callback function.

// Example 1: Filename: index.js
// Node.js program to demonstrate the 
// close Event API 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate  
// for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);


server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });
  stream.write('hello ');

  // Getting rst stream code 
  // by using rstCode api 
  const status = stream.rstCode;

  stream.end("RST_STREAM error code : "
    + status);

  stream.destroy();

  // Close event is emitted 
  stream.on('close', () => {
    console.log("stream is destroyed")
  })

  // Stopping the server by 
  // using the close() method 
  server.close(() => {
    console.log("server destroyed");
  })
});
server.listen(8000);
// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {

  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {

  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Output:

// stream is destroyed
// status : 200
// Received: hello
// client destroyed
// server destroyed

// Node.js http2stream.state Method is used to get 
// the miscellaneous information about 
// the current state of the Http2Stream.

//  http2stream.state
// Parameters: This method does not accept any parameter.
// Return Value: This method returns the miscellaneous 
// information about the current state of the Http2Stream.


// Example 1: Filename: index.js
// Node.js program to demonstrate the 
// Http2Stream.state method 
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Getting all information of  
  // this http2stream object 
  // by using state method 
  const status = stream.state;

  stream.end("priority weight : "
    + status.weight);

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2
  .connect('http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:

// status : 200
// Received: hello
// Received: priority weight : 16
// client destroyed
// server destroyed


// Node.js http2stream.priority() Method is 
// used to update the priority for this Http2Stream instance.

// http2stream.priority(options)
// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate 
// for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Some element for priority 
const options1 = {
  exclusive: true,
  parent: 8000,
  weight: 24,
  silent: true,
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Checking if stream has been assigned 
  // by using priority(options) method 
  const status = stream.priority(options1);

  stream.end("priority has been set");

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:

// status : 200
// Received: hello
// Received: priority has been set
// client destroyed
// server destroyed

// The http2stream.setTimeout() method
// is used to set the duration for a time
//  after which a particular action will take place.

http2stream.setTimeout(msecs, callback)
//This method returns nothing but 
// a callback function for commencing 
// the particular activity after time out .


// Example 1: Filename: index.js
// Node.js program to demonstrate the
// Http2Stream.setTimeout() API
const http2 = require('http2');
const fs = require('fs');

// private key and public certificate for access
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// creating and initializing server
// by using http2.createServer() api
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  // setting time out for the stream 
  // by using setTimeout() 
  stream.setTimeout(3000, () => {
    stream.respond({
      ':status': 200,
      'content-type': 'text/plain'
    });
    stream.end("surprise !!!");
  })
  // stopping the server
  // by using the close() method
  server.close(() => {
    console.log("server destroyed");
  })
});
server.listen(8000);

// creating and initializing client
// by using tls.connect() method
const client = http2.connect(
  'http://localhost:8000');

const req = client.request(
  { ':method': 'GET', ':path': '/' });
req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Output:
// status : 200
// Received: surprise !!!
// client destroyed
// server destroyed

// Node.js http2stream.id Method is used to return 
// numeric stream identifier of this Http2Stream.
// Syntax:http2stream.id
// Return Value: This method returns numeric 
// stream identifier of this Http2Stream.

// Syntax:http2stream.id
//This method returns numeric 
// stream identifier of this Http2Stream.


// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Getting stream identifier 
  // by using id method 
  const status = stream.id;

  stream.end("stream identifier : " + status);

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server destroyed");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request(
  { ':method': 'GET', ':path': '/' });

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:
// status : 200
// Received: hello
// Received: stream identifier : 1
// client destroyed
// server destroyed

// Node.js http2stream.closed Method
//  which is used to return true if 
// the stream is closed other wise false.
// http2stream.closed
// This method returns true if 
// the stream is closed other wise false.


// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);

server.on('stream', (stream, requestHeaders) => {
  stream.respond({
    ':status': 200,
    'content-type': 'text/plain'
  });

  stream.write('hello ');

  // Checking if stream is closed or not 
  // by using close() method 
  const status = stream.closed;

  if (status)
    stream.end("stream is close");
  else
    stream.end("stream is not closed");

  // Stopping the server 
  // by using the close() method 
  server.close(() => {
    console.log("server closed");
  })
});

server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');

const req = client.request(
  { ':method': 'GET', ':path': '/' });

req.on('response', (responseHeaders) => {
  console.log("status : "
    + responseHeaders[":status"]);
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client closed");
  })
});
// Run the index.js file using the following command:
// node index.js

// Output:

// status : 200
// Received: hello
// Received: stream is not closed
// client closed
// server closed

// Node.js Http2Session timeout Event
// The ‘timeout’ Event in http2 server is emitted  
// if there is no activity on the Http2Session 
// after the configured number of milliseconds.

// Example 1: Filename: index.js
const http2 = require('http2');
const fs = require('fs');

// Private key and public certificate for access 
const options = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('public-cert.pem'),
};

// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options);
server.on('stream', (stream, requestHeaders) => {
  // Getting session object 
  // by using session api 
  const http2session = stream.session;
  // Halting session for 3 secs 
  // by using setTimeout API 
  http2session.setTimeout(3000)
  // Emitting timeout event 
  http2session.on('timeout', () => {
    console.log("Surprise !!!");
  })
  // Stopping the server by 
  // using the close() method 
  server.close(() => {
    console.log("server destroyed");
  })
});
server.listen(8000);

// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect(
  'http://localhost:8000');
const req = client.request({
  ':method': 'GET', ':path': '/'
});

req.on('data', (data) => {
  console.log('Received: %s ',
    data.toString().replace(/(\n)/gm, ""));
});

req.on('end', () => {
  client.close(() => {
    console.log("client destroyed");
  })

});
// Output:
// Surprise !!!
// server destroyed

// Node.js Http2Session Close Event
// The ‘close’ Event in the http2 server is 
// emitted when the Http2Session has been destroyed.
//This event returns nothing but a callback function.


// Example 1: Filename: index.js
const http2 = require('http2'); 
const fs = require('fs'); 
  
// Private key and public certificate for access 
const options = { 
  key: fs.readFileSync('private-key.pem'), 
  cert: fs.readFileSync('public-cert.pem'), 
}; 
  
// Creating and initializing server 
// by using http2.createServer() method 
const server = http2.createServer(options); 
  
server.on('stream', (stream, requestHeaders) => { 
  stream.respond({  
    ':status': 200,  
    'content-type': 'text/plain' 
  }); 
  
  stream.write('hello '); 
  
  // Getting session object 
  // by using session method 
  const http2session = stream.session; 
  
  // Getting alpnProtocol of this session 
  // by using alpnProtocol method 
  const alpnProtocol = http2session.alpnProtocol; 
  
  stream.end("session protocol : " + alpnProtocol); 
  
  http2session.close(); 
  
  // Handling 'close' event 
  http2session.on('close',() => { 
    console.log("session is closed"); 
  }) 
  
  // Stopping the server 
  // by using the close() method 
  server.close(() => { 
    console.log("server destroyed"); 
  }) 
}); 
  
server.listen(8000); 
  
// Creating and initializing client 
// by using tls.connect() method 
const client = http2.connect( 
    'http://localhost:8000'); 
  
const req = client.request({  
  ':method': 'GET', ':path': '/' }); 
  
req.on('response', (responseHeaders) => { 
  console.log("status : " 
  + responseHeaders[":status"]); 
}); 
  
req.on('data', (data) => { 
  console.log('Received: %s ', 
  data.toString().replace(/(\n)/gm,"")); 
}); 
  
req.on('end', () => { 
  client.close(() => { 
    console.log("client destroyed"); 
  }) 
});
// Run the index.js file using the following command:
// node index.js

// Output:
// server destroyed
// session is closed
// status : 200
// Received: hello
// Received: session protocol : h2c

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Node.js OS
// OS is a node module used to provide 
// information about the computer operating system.
// It provides functions to interact with 
// the operating system. 


// Include os module and create its object
const os = require('os');

// return the cpu architecture
console.log("CPU architecture: " + os.arch());

// It returns the amount of free system memory in bytes
console.log("Free memory: " + os.freemem());

// It return total amount of system memory in bytes
console.log("Total memory: " + os.totalmem());

// It returns the list of network interfaces
console.log('List of network Interfaces: ' + os.networkInterfaces());

// It returns the operating systems default directory for temp files.
console.log('OS default directory for temp files : ' + os.tmpdir());


// return the endianness of system
console.log("Endianness of system: " + os.endianness());

// It returns hostname of system
console.log("Hostname: " + os.hostname());

// It return operating system name
console.log("Operating system name: " + os.type());

// It returns the platform of os
console.log('operating system platform: ' + os.platform());

// It returns the operating systems release.
console.log('OS release : ' + os.release());

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The path.basename() method is used to get 
// the filename portion of a path to the file. 
path.basename(path, extension)
//path:It is the file path that would be 
// used to extract the filename.
//extension:It is an optional file extension 
// that would be removed from the returned string.

// Using Windows file paths
// Node.js program to demonstrate the    
// path.basename() method 

// Import the path module 
const path = require('path');
path1 = path.basename('C:\\users\\bash\\index.html');
console.log(path1)

// Using the extension parameter 
path2 = path.basename('C:\\users\\bash\\index.html', '.html');
console.log(path2)
// Output:
// index.html
// index


// **Use Case: Dynamic File Handling in a Web Application**

// In web development, dealing with file paths and 
// filenames is common. The `path.basename()` method 
// allows you to extract the filename portion of a path, 
// which can be useful in various scenarios:

// 1. **File Uploads and Downloads**:
//- When users upload files (e.g., images, documents) 
// to your web app, you receive the full file path.
//- Use `path.basename()` to extract just the filename, 
// which simplifies storage, indexing, and retrieval.
//- For example, when saving user profile pictures, 
// you can store them with filenames like `user123_profile.jpg`.

// 2. **Serving Static Assets**:
//- Web servers often serve static files 
// (CSS, JavaScript, images) from specific directories.
//- By using `path.basename()`, you can map requested 
// URLs to actual filenames on the server.
//- For instance, when a user requests `/assets/styles.css`, 
// you extract `styles.css` and serve the corresponding file.

// 3. **Logging and Auditing**:
//- When logging events (e.g., user actions, API requests), 
// including filenames can be helpful.
//- Use `path.basename()` to extract the relevant part of the file path.
//- For example, log entries like "User downloaded report.pdf" 
// or "Image uploaded: profile.jpg".

// let's see a sample Node.js code snippet demonstrating 
// how to use `path.basename()` for dynamic file handling:
const path = require('path');

// Example 1: Handling uploaded files
const uploadedFilePath = '/uploads/user123_profile.jpg';
const uploadedFileName = path.basename(uploadedFilePath);
console.log('Uploaded filename:', uploadedFileName);

// Example 2: Serving static assets
const requestedUrl = '/assets/styles.css';
const assetFileName = path.basename(requestedUrl);
console.log('Requested asset filename:', assetFileName);

// Example 3: Logging user actions
const originalFilePath = '/data/reports/report2024.pdf';
const actionLog = `User downloaded ${path.basename(originalFilePath)}`;
console.log(actionLog);


// In this example:
// - We extract filenames from different contexts: 
// uploaded files, requested URLs, and original file paths.
// - Adapt the logic based on your specific use case 
// (e.g., handling different file extensions, customizing filenames).
// you can enhance your web application's file management capabilities.

// The path.dirname() method is used to get 
// the directory name of the given path. 
// It ignores the respective platform’s 
// trailing directory separators. 

path.dirname( path )
// path: It is the file path that would 
// be used to extract the directory name. 
//It returns a string with 
// the directory of the path.


// path.dirname() method  
// Import the path module 
const path = require('path');

// Complete file path 
path1 = path.dirname("/users/admin/website/index.html");
console.log(path1)

// Only file name 
// returns a period (.) 
path2 = path.dirname("readme.md");
console.log(path2)

// Path with file not specified 
path3 = path.dirname("website/post/comments")
console.log(path3);
// Output:
// /users/admin/website
// .
// website/post


// Example 2:
// Node.js program to demonstrate the     
// path.dirname() method  

// Import the path module 
const path = require('path');

console.log("File name:", __filename);
path1 = path.dirname(__filename);
console.log(path1);

console.log("Directory name:", __dirname);
path2 = path.dirname(__dirname);
console.log(path2);

// Output:
// File name:  G:\tutorials\nodejs-path-dirname\index.js
// G:\tutorials\nodejs-path-dirname
// Directory name:  G:\tutorials\nodejs-path-dirname
// G:\tutorials


// The path.dirname() method is used to get 
// the directory name of the given path. 
// It ignores the respective platform’s 
// trailing directory separators. 

path.dirname(path)
// It returns a string with 
// the directory of the path.

const path = require('path');

console.log("File name:", __filename);
path1 = path.dirname(__filename);
console.log(path1);

console.log("Directory name:", __dirname);
path2 = path.dirname(__dirname);
console.log(path2);
// Output:
// File name:  G:\tutorials\nodejs-path-dirname\index.js
// G:\tutorials\nodejs-path-dirname
// Directory name:  G:\tutorials\nodejs-path-dirname
// G:\tutorials

//** Use Case: Dynamic File Handling in a Web Application **

//In web development, dealing with file paths 
// and filenames is common.The `path.dirname()` 
// method allows you to extract the directory 
// portion of a path, which can be useful 
// in various scenarios:

// 1. ** File Uploads and Downloads **:
// - When users upload files(e.g., images, documents) 
// to your web app, you receive the full file path.
//- Use`path.dirname()` to extract just the directory,
//  which simplifies storage, indexing, and retrieval.
//- For example, when saving user profile pictures,
//  you can organize them in directories like`/uploads/user123/`.

// 2. ** Serving Static Assets **:
// - Web servers often serve static files(CSS, JavaScript, 
// images) from specific directories.
//- By using`path.dirname()`, you can map requested URLs 
// to actual directory paths on the server.
//- For instance, when a user requests`/assets/styles.css`, 
// you extract `/assets` and serve the corresponding file.

// 3. ** Dynamic Routing and Controllers **:
// - In a web framework(e.g., Express.js), you define routes and controllers.
//- Extracting the directory from the current file path(`__filename`) 
// helps organize your code.
//- For example, you can dynamically load controllers based 
// on the directory structure.

const path = require('path');

// Example 1: Handling uploaded files
const uploadedFilePath = '/uploads/user123_profile.jpg';
const uploadDirectory = path.dirname(uploadedFilePath);
console.log('Uploaded file directory:', uploadDirectory);

// Example 2: Serving static assets
const requestedUrl = '/assets/styles.css';
const assetDirectory = path.dirname(requestedUrl);
console.log('Requested asset directory:', assetDirectory);

// Example 3: Dynamic routing in Express.js
const currentControllerPath = __filename; // Assume this is the controller file
const controllerDirectory = path.dirname(currentControllerPath);
console.log('Controller directory:', controllerDirectory);

// - We extract directories from different contexts: 
// uploaded files, requested URLs, and controller paths.
// - Adapt the logic based on your specific use case 
// (e.g., handling different file extensions, 
// customizing directory structures).
//  you can enhance your web application's file management capabilities. 📂🔍


// The path.extname() method is used to get 
// the extension portion of a file path. 
// The extension string returned from the 
// last occurrence of a period (.) in the
//  path to the end of the path string. 
It returns a string with 
// the extension portion of the path. 

const path = require('path');

path1 = path.extname("hello.txt");
console.log(path1)
// .txt


// Import the path module 
const path = require('path');

// Comparing extensions from a 
// list of file paths 
paths_array = [
   "/home/user/website/index.html",
   "/home/user/website/style.css",
   "/home/user/website/bootstrap.css",
   "/home/user/website/main.js",
   "/home/user/website/contact_us.html",
   "/home/user/website/services.html",
]

paths_array.forEach(filePath => {
   if (path.extname(filePath) == ".html")
      console.log(filePath);
});
// Output:
// /home/user/website/index.html
// /home/user/website/contact_us.html
// /home/user/website/services.html


// ** Use Case: Dynamic File Handling in a Web Application **

// In web development, dealing with file paths and 
// filenames is common.The `path.extname()` method 
// allows you to extract the extension portion of 
// a file path, which can be useful in various scenarios:

// 1. ** File Uploads and Downloads **:
// - When users upload files(e.g., images, documents) to 
// your web app, you receive the full file path.
//- Use`path.extname()` to extract just the filename 
// extension, which simplifies storage, indexing, and retrieval.
//- For example, when saving user profile pictures,
//  you can store them with filenames like`user123_profile.jpg`.

// 2. ** Serving Static Assets **:
// - Web servers often serve static files(CSS, JavaScript, 
// images) from specific directories.
//- By using`path.extname()`, you can map requested URLs 
// to actual filenames on the server.
//- For instance, when a user requests`/assets/styles.css`, 
// you extract `styles.css` and serve the corresponding file.

// 3. ** Dynamic Routing and Controllers **:
// - In a web framework(e.g., Express.js), you define routes and controllers.
//- Extracting the extension from the current file path(`__filename`) 
// helps organize your code.
//- For example, dynamically loading controllers based on 
// the file extension(e.g., `.js`, `.json`).

const path = require('path');

// Example 1: Handling uploaded files
const uploadedFilePath = '/uploads/user123_profile.jpg';
const fileExtension = path.extname(uploadedFilePath);
console.log('Uploaded file extension:', fileExtension);

// Example 2: Serving static assets
const requestedUrl = '/assets/styles.css';
const assetExtension = path.extname(requestedUrl);
console.log('Requested asset extension:', assetExtension);

// Example 3: Dynamic routing in Express.js
const currentControllerPath = __filename; // Assume this is the controller file
const controllerExtension = path.extname(currentControllerPath);
console.log('Controller extension:', controllerExtension);

// - We extract extensions from different contexts: 
// uploaded files, requested URLs, and controller paths.
// - Adapt the logic based on your specific use case 
// (e.g., handling different file extensions, customizing 
// directory structures).

// Node.js path.format() Method
// The path.format() method is used to return 
// a path string from the given path object. 
// The “root” parameter of the path object is 
// ignored if the “dir” parameter is provided.
// The “ext” and “name” parameter of the path 
// object are ignored if the “base” parameter is provided.

path.format(pathObject)

// Parameters: This function accepts single parameter 
// pathObject that contains the details of the path. 
// It has the following parameters:
// dir: It specifies the directory name of the path object.
// root: It specifies the root of the path object.
// base: It specifies the base of the path object.
// name: It specifies the file name of the path object.
// ext: It specifies the file extension of the path object.

//It returns a path string from 
// the provided path object.

// Import the path module 
const path = require('path');

// CASE 1 
// If "dir", "root" and "base" are all given, 
// "root" is ignored. 
let path1 = path.format({
    root: "/ignored/root/",
    dir: "/home/user/personal",
    base: "details.txt",
});
console.log("Path 1:", path1);

// CASE 2 
// If "dir" is not specified then "root" will be used  
// If only "root" is provided 
// platform separator will not be included. 
// "ext" will be ignored. 
let path2 = path.format({
    root: "/",
    base: "game.dat",
    ext: ".noextension",
});
console.log("Path 2:", path2);

// CASE 3 
// If "base" is not specified 
// "name" and "ext" will be used  
let path3 = path.format({
    root: "/images/",
    name: "image",
    ext: ".jpg",
});
console.log("Path 3:", path3);

// Import the path module 
const path = require('path');

// CASE 1 
// If "dir", "root" and "base" are all given, 
// "root" is ignored. 
let path1 = path.format({
    root: "C:\\ignored\\root",
    dir: "website\\dist",
    base: "index.html",
});
console.log("Path 1:", path1);

// CASE 2 
// If "dir" is not specified then "root" 
// will be used  
// If only "root" is provided platform 
// separator will not be included. 
// "ext" will be ignored. 
let path2 = path.format({
    root: "C:\\",
    base: "style.css",
    ext: ".ignored",
});
console.log("Path 2:", path2);

// CASE 3 
// If "base" is not specified 
// "name" and "ext" will be used  
let path3 = path.format({
    root: "website\\",
    name: "main",
    ext: ".js",
});
console.log("Path 3:", path3);

// ** Use Case: Dynamic File Handling in a Web Application **

// In web development, dealing with file paths 
// and filenames is common.The `path.format()` 
// method allows you to construct a path string 
// from a path object, which can be useful in various scenarios:

// 1. ** File Uploads and Downloads **:
// - When users upload files(e.g., images, documents) 
// to your web app, you receive the full file path.
//- Use`path.format()` to create a standardized path 
// string that includes the directory, filename, and extension.
//- For example, when saving user profile pictures, 
// you can construct the full path dynamically.

// 2. ** Serving Static Assets **:
// - Web servers often serve static files(CSS, 
// JavaScript, images) from specific directories.
//- By using`path.format()`, you can generate 
// the correct file path based on requested URLs.
//- For instance, when a user requests`/assets/styles.css`, 
// you construct the corresponding file path.

// 3. ** Dynamic Routing and Controllers **:
// - In a web framework(e.g., Express.js), 
// you define routes and controllers.
//- Constructing paths dynamically based on 
// the current environment or configuration is essential.
//- For example, dynamically loading controllers 
// based on the directory structure or environment.


const path = require('path');

// Example 1: Constructing file paths for uploaded files
const userUploadsDir = '/uploads';
const uploadedFileName = 'user123_profile.jpg';
const fullPath = path.format({ dir: userUploadsDir, base: uploadedFileName });
console.log('Full path for uploaded file:', fullPath);

// Example 2: Constructing asset paths for serving static files
const requestedUrl = '/assets/styles.css';
const staticAssetsDir = '/public';
const assetPath = path.format({ dir: staticAssetsDir, base: path.basename(requestedUrl) });
console.log('Asset path for serving:', assetPath);

// Example 3: Dynamic routing in Express.js
const currentControllerPath = __filename; // Assume this is the controller file
const controllerDir = path.dirname(currentControllerPath);
const controllerName = path.basename(currentControllerPath, '.js');
const controllerPath = path.format({ dir: controllerDir, base: controllerName });
console.log('Controller path:', controllerPath);

// - We construct paths for uploaded files, 
// static assets, and dynamic routing.
// - Adapt the logic based on your specific use 
// case (e.g., handling different file extensions, 
// customizing directory structures).

// The path.isAbsolute() method is used to check
//  whether the given path is an absolute path or not. 
// An absolute path is defined as a path that contains 
// the complete details needed to locate a file. 

path.isAbsolute( path )

//It returns a Boolean value 
// indicating whether the path is an absolute path. 

const path = require('path');

path1 = path.isAbsolute("/user/bash/");
console.log(path1);

path2 = path.isAbsolute("user/bash/readme.md");
console.log(path2);
// Output:
// true
// false

const path = require('path');

path1 = path.isAbsolute("\\user\\bash\\");
console.log(path1);

path2 = path.isAbsolute("user\\bash\\readme.md");
console.log(path2);
// Output:
// true
// false


//   ** Use Case: Dynamic File Handling in a Web Application **

//In web development, dealing with file paths 
// and filenames is common.The `path.isAbsolute()` 
// method allows you to check whether a given path 
// is an absolute path or not.An absolute path 
// contains complete details needed to locate
//  a file.Here are some scenarios where 
// `path.isAbsolute()` can be useful:

// 1. ** File Uploads and Downloads **:
// - When users upload files(e.g., images, documents) 
// to your web app, you receive the full file path.
//- Use`path.isAbsolute()` to determine if the path 
// is absolute or relative.
//- For example, when saving user profile pictures, 
// you can validate whether the provided path is absolute.

// 2. ** Serving Static Assets **:
// - Web servers often serve static files(CSS, JavaScript, images) 
// from specific directories.
//- Before serving a requested file, check if the path is 
// absolute using`path.isAbsolute()`.
//- This ensures that you're serving files from the correct location.

// 3. ** Dynamic Routing and Controllers **:
// - In a web framework(e.g., Express.js), you define routes and controllers.
//- Validate user input paths to prevent security 
// vulnerabilities(e.g., directory traversal attacks).
//- Use`path.isAbsolute()` to ensure that user - provided paths are absolute.

//   Now, let's see a sample Node.js code snippet 
// demonstrating how to use `path.isAbsolute()` for dynamic file handling:

    // ```javascript
const path = require('path');

// Example 1: Validating uploaded file paths
function handleUploadedFile(filePath) {
  if (path.isAbsolute(filePath)) {
    // Save the file securely
    console.log('Saving uploaded file:', filePath);
    // ...
  } else {
    console.error('Invalid file path. Expected an absolute path.');
    // Handle the error (e.g., reject the upload)
  }
}

handleUploadedFile('/uploads/user123_profile.jpg'); // Valid absolute path
handleUploadedFile('user456_profile.jpg'); // Invalid relative path

// Example 2: Serving static assets
function serveStaticAsset(requestedPath) {
  if (path.isAbsolute(requestedPath)) {
    // Serve the requested asset
    console.log('Serving asset:', requestedPath);
    // ...
  } else {
    console.error('Invalid asset path. Expected an absolute path.');
    // Handle the error (e.g., return a 404 response)
  }
}

serveStaticAsset('/assets/styles.css'); // Valid absolute path
serveStaticAsset('../config/secrets.json'); // Invalid relative path
// ```

// In this example:
// - We validate uploaded file paths and serve static assets.
// - Adapt the logic based on your specific use case (e.g.,
//  handling different file extensions, customizing directory structures).

// The path.join() method is used to join 
// a number of path-segments using 
// the platform-specific delimiter to 
// form a single path.
path.join( [...paths] )

// Import the path module 
const path = require('path');

// Joining 2 path-segments 
path1 = path.join("users/admin/files", "index.html");
console.log(path1)

// Joining 3 path-segments 
path2 = path.join("users", "geeks/website", "index.html");
console.log(path2)

// Joining with zero-length paths 
path3 = path.join("users", "", "", "index.html");
console.log(path3)
// Output: 
// users\admin\files\index.html
// users\geeks\website\index.html
// users\index.html

// path.join() Method   

// Import the path module 
const path = require('path');

// Normalizing of the final path 
path1 = path.join("users", "..", "files", "readme.md");
console.log(path1)

// Zero length final path 
// returns a period (.) 
path2 = path.join("users", "..");
console.log(path2)

// Getting the directory path one folder above 
console.log("Current Directory: ", __dirname);
path3 = path.join(__dirname, "..");
console.log("Directory above:", path3)

// Node.js path.normalize() Method
// The path.normalize() method is used to normalize 
// the given path. Normalization resolves the (.) and (..) 
// segments of the path to their correct form.If 
// the method encounters multiple path separators, 
// it replaces all of them by a single platform-specific 
// path separator. This method preserves all trailing 
// separators. 

// Import the path module 
const path = require('path');

path1 = path.normalize("/users/admin/.");
console.log(path1)

path2 = path.normalize("/users/admin/..");
console.log(path2)

path3 = path.normalize("/users/admin/../comments")
console.log(path3);

path4 = path.normalize("/users///admin///comments")
console.log(path4);
// Output:
// \users\admin
// \users
// \users\comments
// \users\admin\comments

//    ** Use Case: Dynamic File Handling in a Web Application **

//In web development, dealing with file paths and filenames 
// is common.The `path.normalize()` method allows you to 
// resolve and standardize paths, fixing any inconsistencies 
// related to directory separators(`/` or`\`) and 
// redundant dots (`.` and `..`). Here are some scenarios 
// where `path.normalize()` shines:

// 1. **File Uploads and Downloads**:
//- When handling uploaded files, you often receive filenames and directory names separately.
//- Use `path.normalize()` to ensure that the resulting path is consistent across different platforms (Windows, macOS, Linux).
//- For example, when saving user profile pictures, you can normalize the provided path to avoid unexpected behavior.

// 2. **Serving Static Assets**:
//- Web servers serve static files (CSS, JavaScript, images) from specific directories.
//- Normalize requested URLs using `path.normalize()` to handle variations in path formats.
//- This ensures that you correctly map URLs to actual file paths.

// 3. **Dynamic Routing and Controllers**:
//- In web frameworks (e.g., Express.js), you define routes and controllers.
//- Normalize paths when constructing dynamic routes or loading controllers.
//- For example, when dynamically loading a controller based on a user request, normalize the path to avoid discrepancies.


const path = require('path');

// Example 1: Handling uploaded files
const userUploadsDir = '/uploads';
const uploadedFileName = 'user123_profile.jpg';
const fullPath = path.normalize(path.join(userUploadsDir, uploadedFileName));
console.log('Normalized full path for uploaded file:', fullPath);

// Example 2: Serving static assets
const requestedUrl = '/assets/styles.css';
const staticAssetsDir = '/public';
const assetPath = path.normalize(path.join(staticAssetsDir, path.basename(requestedUrl)));
console.log('Normalized asset path for serving:', assetPath);

// Example 3: Dynamic routing in Express.js
const currentControllerPath = __filename; // Assume this is the controller file
const controllerDir = path.dirname(currentControllerPath);
const controllerName = path.basename(currentControllerPath, '.js');
const normalizedControllerPath = path.normalize(path.join(controllerDir, controllerName));
console.log('Normalized controller path:', normalizedControllerPath);

// In this example:
// - We construct normalized paths for uploaded files, 
// static assets, and dynamic routing.
// - The `path.normalize()` method ensures consistent 
// path formats across different platforms.
// - Adapt the logic based on your specific use case 
// (e.g., handling different file extensions, customizing directory structures).

//Use it to enhance your web application's robustness. 📂🔧

// The path.parse() method is used to return 
// an object whose properties represent the given path. 

// This method returns the following properties:
// root (root name)
// dir (directory name)
// base (filename with extension)
// ext (only extension)
// name (only filename)
// The values of these properties may be different 
// for every platform. It ignores the platform’s 
// trailing directory separators during parsing. 
// This method returns an object 
// with the details of the path. 

// Import the path module 
const path = require('path');

path1 = path.parse("C:\\users\\admin\\website\\index.html");
console.log(path1);

path2 = path.parse("website\\style.css");
console.log(path2);
// Output:
// {
//   root: 'C:\\',
//   dir: 'C:\\users\\admin\\website',
//   base: 'index.html',
//   ext: '.html',
//   name: 'index'
// }
// {
//   root: '',
//   dir: 'website',
//   base: 'style.css',
//   ext: '.css',
//   name: 'style'
// }

// Here are some 
// scenarios where it shines:

// 1. ** Dynamic File Handling in a Web Application **:
// - Imagine you're building a web application that 
// handles file uploads, serves static assets, and 
// dynamically routes requests. The `path.parse()` 
// method can help you extract essential details 
// from file paths.

//- Let's dive into examples to illustrate its usage:
//** Example 1: Handling Uploaded Files **
//Suppose your web app allows users to upload profile 
// pictures.You receive the full file path, including 
// the directory and filename.You want to extract 
// relevant information for storage and indexing.

const path = require('path');

// Uploaded file path (example)
const uploadedFilePath = '/uploads/user123_profile.jpg';

// Parse the file path
const parsedPath = path.parse(uploadedFilePath);
console.log('Parsed file path:', parsedPath);

// Extract specific properties
console.log('Root:', parsedPath.root); // Root name (e.g., '/')
console.log('Directory:', parsedPath.dir); // Directory name (e.g., '/uploads')
console.log('Base:', parsedPath.base); // Filename with extension (e.g., 'user123_profile.jpg')
console.log('Extension:', parsedPath.ext); // Only extension (e.g., '.jpg')
console.log('Name:', parsedPath.name); // Only filename (e.g., 'user123_profile')

//** Example 2: Serving Static Assets **
//Your web server serves static CSS and JavaScript 
// files from a specific directory.You want to 
// construct the correct file path based on requested URLs.

// Requested URL (example)
const requestedUrl = '/assets/styles.css';

// Static assets directory
const staticAssetsDir = '/public';

// Construct the asset path
const assetPath = path.join(staticAssetsDir, path.basename(requestedUrl));
console.log('Asset path for serving:', assetPath);

//** Example 3: Dynamic Routing in Express.js **
//In an Express.js application, you define routes 
// and controllers.Constructing dynamic paths 
// based on the current environment or configuration is essential.

// Assume this is the controller file
const currentControllerPath = __filename;

// Extract directory and filename without extension
const controllerDir = path.dirname(currentControllerPath);
const controllerName = path.basename(currentControllerPath, '.js');

// Construct the controller path
const controllerPath = path.join(controllerDir, controllerName);
console.log('Controller path:', controllerPath);
// Load controllers dynamically based on the path

// Node.js path.relative() Method
// The path.relative() method is used to 
// find the relative path from a given path 
// to another path based on the current working 
// directory. If both the given paths are the same, 
// it would resolve to a zero-length string. 

path.relative(from, to)
// from: It is the file path that would be used as base path.
// to: It is the file path that would be used 
// to find the relative path.
// It returns a string with 
// the normalized form of the path. 

// Import the path module 
const path = require('path');

path1 = path.relative("geeks/website", "geeks/index.html");
console.log(path1)

path2 = path.relative("users/admin", "admin/files/website");
console.log(path2)

// When both the paths are same 
// It returns blank string 
path3 = path.relative("users/admin", "users/admin");
console.log(path3)
// Output:
// ..\index.html
// ..\..\admin\files\website


//    ** Use Case: Dynamic File Paths in a Web Application **

//In web development, handling file paths dynamically 
// is essential for organizing and accessing resources.
// The `path.relative()` method allows you to find 
// the relative path from one given path to another 
// based on the current working directory.Here are 
// some scenarios where `path.relative()` shines:

// 1. ** File Uploads and Downloads **:
// - When users upload files(e.g., images, documents) to 
// your web app, you receive the full file path.
//- Use`path.relative()` to determine the relative path 
// between the uploaded file and a predefined directory.
//- For example, when saving user profile pictures, you 
// can calculate the relative path from the uploads directory.

// 2. ** Serving Static Assets **:
// - Web servers serve static files(CSS, JavaScript, images) 
// from specific directories.
//- Construct the relative path using `path.relative()` 
// to map requested URLs to actual file paths.
//- This ensures that you're serving files from the correct location.

// 3. ** Dynamic Routing and Controllers **:
// - In web frameworks(e.g., Express.js), you define routes and controllers.
//- Calculate relative paths dynamically based on the current 
// environment or configuration.
//- For instance, when dynamically loading a controller 
// based on a user request, use`path.relative()` to 
// find the relative path.

const path = require('path');

// Example 1: Calculating relative paths for uploaded files
const uploadsDir = '/uploads';
const uploadedFilePath = '/uploads/user123_profile.jpg';

// Calculate the relative path from uploads directory
const relativePath = path.relative(uploadsDir, uploadedFilePath);
console.log('Relative path for uploaded file:', relativePath);

// Example 2: Serving static assets
const requestedUrl = '/assets/styles.css';
const staticAssetsDir = '/public';

// Calculate the relative path for serving the asset
const assetRelativePath = path.relative(staticAssetsDir, requestedUrl);
console.log('Relative asset path for serving:', assetRelativePath);

// Example 3: Dynamic routing in Express.js
const currentControllerPath = __filename; // Assume this is the controller file
const controllerDir = path.dirname(currentControllerPath);
const controllerName = path.basename(currentControllerPath, '.js');

// Calculate the relative path for loading the controller
const controllerRelativePath = path.relative(controllerDir, controllerName);
console.log('Relative controller path:', controllerRelativePath);

// Node path.resolve() Method
// The path.resolve() method is used to resolve 
// a sequence of path segments to an absolute path. 
// It works by processing the sequence of paths 
// from right to left, prepending each of the 
// paths until the absolute path is created. 
// The resulting path is normalized and trailing 
// slashes are removed as required.

// If no path segments are given as parameters, 
// then the absolute path of the current working 
// directory is used.

path.resolve( [...paths] )

// paths: It is a series of file paths that 
// would be resolved together to form an absolute path. 

// Import the path module
const path = require('path');

console.log("Current directory:", __dirname);

// Resolving 2 path-segments
// with the current directory
path1 = path.resolve("users/admin", "readme.md");
console.log(path1)

// Resolving 3 path-segments
// with the current directory
path2 = path.resolve("users", "admin", "readme.md");
console.log(path2)

// Treating of the first segment
// as root, ignoring the current directory
path3 = path.resolve("/users/admin", "readme.md");
console.log(path3)

// Current directory: G:\tutorials\nodejs-path-resolve
// G:\tutorials\nodejs-path-resolve\users\admin\readme.md
// G:\tutorials\nodejs-path-resolve\users\admin\readme.md
// G:\users\admin\readme.md

// Import the path module
const path = require('path');

console.log("Current directory:", __dirname);

// Normalization of the absolute paths
path1 = path.resolve("users", "..", "readme.md");
console.log(path1)

path2 = path.resolve("users", "admin",
   "..", "files", "readme.md");
console.log(path2)

path3 = path.resolve("users", "admin",
   "..", "files", "..", "readme.md");
console.log(path3)
// Current directory: G:\tutorials\nodejs-path-resolve
// G:\tutorials\nodejs-path-resolve\readme.md
// G:\tutorials\nodejs-path-resolve\users\files\readme.md
// G:\tutorials\nodejs-path-resolve\users\readme.md

// The path.resolve() method is used to resolve 
// a sequence of path segments to an absolute path. 
// It works by processing the sequence of paths 
// from right to left, prepending each of the 
// paths until the absolute path is created. 
// The resulting path is normalized and trailing 
// slashes are removed as required.

// If no path segments are given as parameters, 
// then the absolute path of the current working 
// directory is used.

path.resolve([...paths])

//// paths: It is a series of file paths that 
// would be resolved together to form an absolute path. 

// Import the path module
const path = require('path');

console.log("Current directory:", __dirname);

// Resolving 2 path-segments
// with the current directory
path1 = path.resolve("users/admin", "readme.md");
console.log(path1)

// Resolving 3 path-segments
// with the current directory
path2 = path.resolve("users", "admin", "readme.md");
console.log(path2)

// Treating of the first segment
// as root, ignoring the current directory
path3 = path.resolve("/users/admin", "readme.md");
console.log(path3)
// Current directory: G:\tutorials\nodejs-path-resolve
// G:\tutorials\nodejs-path-resolve\users\admin\readme.md
// G:\tutorials\nodejs-path-resolve\users\admin\readme.md
// G:\users\admin\readme.md

const path = require('path');

console.log("Current directory:", __dirname);

// Normalization of the absolute paths
path1 = path.resolve("users", "..", "readme.md");
console.log(path1)

path2 = path.resolve("users", "admin",
   "..", "files", "readme.md");
console.log(path2)

path3 = path.resolve("users", "admin",
   "..", "files", "..", "readme.md");
console.log(path3)
// node index.js
// Current directory: G:\tutorials\nodejs-path-resolve
// G:\tutorials\nodejs-path-resolve\readme.md
// G:\tutorials\nodejs-path-resolve\users\files\readme.md
// G:\tutorials\nodejs-path-resolve\users\readme.md

//In web development, handling file paths dynamically 
// is essential for organizing and accessing resources.
// The `path.resolve()` method allows you to resolve 
// a sequence of path segments to an absolute path.
// It works by processing the sequence of paths from 
// right to left, prepending each of the paths until 
// the absolute path is created.The resulting path 
// is normalized, and trailing slashes are removed as required.


// Here are some scenarios where `path.resolve()` can be valuable:

// 1. ** File Uploads and Downloads **:
// - When users upload files(e.g., images, documents) to 
// your web app, you receive the full file path.
//- Use`path.resolve()` to create an absolute path by 
// joining the base directory and the filename.
//- For example, when saving user profile pictures, 
// you can construct the complete path dynamically.

// 2. ** Serving Static Assets **:
// - Web servers often serve static files(CSS, 
// JavaScript, images) from specific directories.
//- Construct the correct file path using 
// `path.resolve()` based on requested URLs.
//- This ensures that you're serving files from the right location.

// 3. ** Dynamic Routing and Controllers **:
// - In web frameworks(e.g., Express.js), you 
// /define routes and controllers.
//- Construct paths dynamically based on 
// the current environment or configuration.
//- For example, when dynamically loading 
// a controller based on a user request, 
// use`path.resolve()` to find the absolute path.


//       ** Example 1: Handling Uploaded Files **
//Suppose your web app allows users to upload 
// profile pictures.You receive the full file path, 
// including the directory and filename.You want 
// to construct the full path dynamically.
const path = require('path');

// Uploaded file path (example)
const uploadedFilePath = '/uploads/user123_profile.jpg';

// Resolve the file path
const resolvedPath = path.resolve(uploadedFilePath);
console.log('Resolved file path:', resolvedPath);

//** Example 2: Serving Static Assets **
//Your web server serves static CSS and JavaScript 
// files from a specific directory.You want to 
// construct the correct file path based on requested URLs.
const requestedUrl = '/assets/styles.css';

// Static assets directory
const staticAssetsDir = '/public';

// Resolve the asset path
const resolvedAssetPath = path.resolve(staticAssetsDir, path.basename(requestedUrl));
console.log('Resolved asset path:', resolvedAssetPath);

//** Example 3: Dynamic Routing in Express.js **
//In an Express.js application, you define routes 
// and controllers.Constructing dynamic paths based 
// on the current environment or configuration is essential.

const currentControllerPath = __filename;

// Resolve the controller path
const resolvedControllerPath = path.resolve(currentControllerPath);
console.log('Resolved controller path:', resolvedControllerPath);

// Node.js path.toNamespacedPath() Method
// The path.toNamespacedPath() method is used to find 
// the equivalent namespace-prefixed path from 
// the given path.
path.toNamespacedPath(path)
// path: It is an string which contains 
// the path that has to be converted.
It returns a string with 
// an equivalent namespace-prefixed path. 

const path = require('path');

let originalPath = "C:\\Windows\\users";
console.log("Original Path:", originalPath);

let nameSpacedPath = path.toNamespacedPath(originalPath);
console.log("Namespaced Path:", nameSpacedPath);
// Output:
// Original Path: C:\Windows\users
// Namespaced Path: \\?\C:\Windows\users

// Example 2:

// Import the path module 
const path = require('path');

let originalPath = "C:\\Windows\\users\\..\\admin";
console.log("Original Path:", originalPath);

let nameSpacedPath = path.toNamespacedPath(originalPath);
// console.log("Namespaced Path:", nameSpacedPath); 
// Output:
// Original Path: C:\Windows\users\..\admin
// Namespaced Path: \\?\C:\Windows\admin

//// ### Use Case: Handling User - Provided Paths in a Windows File System

//When 
// a user uploads a file, you receive the file 
// path as input. However, you need to ensure 
// that the path is correctly formatted for
//  the specific operating system.

// 1. ** User Uploads a File:**
//- A user uploads a file named "mydocument.txt" from their local machine.
//- The file path provided by the user is`"C:\Users\John\Documents\mydocument.txt"`.

// 2. ** Processing the Path:**
//- You receive the user - provided path in your Node.js backend.
//- Since your application runs on both Windows and POSIX systems,
//  you need to convert the path to the appropriate format.

   const path = require('path');

   // User-provided path (Windows format)
   const userPath = 'C:\\Users\\John\\Documents\\mydocument.txt';

   // Convert to the equivalent namespace-prefixed path
   const namespacedPath = path.toNamespacedPath(userPath);

   console.log('Original Path:', userPath);
   console.log('Namespaced Path:', namespacedPath);

   // Original Path: C:\Users\John\Documents\mydocument.txt
   // Namespaced Path: \\?\C:\Users\John\Documents\mydocument.txt
//- The`path.toNamespacedPath()` method prepends the `\\?\` 
// prefix to the path, indicating that it is a namespace-prefixed path.
//- This ensures that the path is correctly interpreted 
// by Windows APIs, even if it contains special characters 
// or exceeds the usual path length limit.

// 6. **Why It Shines:**
//- Without `path.toNamespacedPath()`, you'd need to manually 
// handle path conversions based on the operating system.
//- By using this method, your code remains concise, and 
// you ensure compatibility across different platforms.

// it returns the same path without modification. So, 
// it's a powerful tool for cross-platform development,
//  especially when dealing with user-generated paths.

// The path.delimiter property is an inbuilt application 
// programming interface of the path module which is used 
// to get platform-specific path delimiter. 
path.delimiter;
//This property returns a string 
// that represents platform specific path delimiter. 

// Allocating path module 
const path = require('path');

// Printing path.delimiter value 
console.log(path.delimiter);
// Output:
// ;


// Allocating path module 
const path = require('path');

// Allocating process module 
const process = require('process');

// Printing path.delimiter value 
var delimiter = path.delimiter;

console.log(process.env.PATH);
console.log(process.env.PATH.split(path.delimiter));
// Output:
// C:\wamp64\bin\php\php7.3.1\ext\ImageMagick;C:\Program Files (x86)\Common 
// Files\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;
// C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;
// C:\Windows\System32\OpenSSH\;D:\programfiles\Git\cmd;
// D:\programfiles\Cmake\bin;
// C:\Program
// Files\nodejs\;C:\Users\gekcho\AppData\Local\Microsoft\WindowsApps;
// C:\Users\gekcho\AppData\Roaming\npm
// [ 'C:\\wamp64\\bin\\php\\php7.3.1\\ext\\ImageMagick',
//   'C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath',
//   'C:\\Windows\\system32',
//   'C:\\Windows',
//   'C:\\Windows\\System32\\Wbem',
//   'C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\',
//   'C:\\Windows\\System32\\OpenSSH\\',
//   'D:\\programfiles\\Git\\cmd',
//   'D:\\programfiles\\Cmake\\bin',
//   'C:\\Program Files\\nodejs\\',
//   'C:\\Users\\gekcho\\AppData\\Local\\Microsoft\\WindowsApps',
//   'C:\\Users\\gekcho\\AppData\\Roaming\\npm' ]

//This method is particularly 
// useful when dealing with environment variables 
// and system paths, especially in cross-platform 
// development scenarios.


// ### Use Case: Managing Environment Variables in a Web Application

// Imagine you're building a web application that 
// relies on external tools or libraries installed 
// on the user's system.These tools are often 
// accessible via environment variables(e.g., 
// `PATH` on Windows or`PATH` and`LD_LIBRARY_PATH` 
// on Unix - like systems).Your goal is to ensure 
// that your application can locate these tools 
// regardless of the user's operating system.


// 1. ** Scenario:**
//- Your web application needs to execute a command - 
// line tool(e.g., a compiler, image processing utility, 
// or database client) based on user input.
//- The tool's executable is located in different 
// directories depending on the user's system.

// 2. ** Environment Variables:**
//- You rely on the `PATH` environment variable 
// to find the tool's executable.
//- On Windows, directories in `PATH` are separated by semicolons(`;`).
//- On Unix - like systems(including macOS and Linux),
//  directories are separated by colons(`:`).

const path = require('path');
const process = require('process');

// Get the platform-specific path delimiter
const delimiter = path.delimiter;

// Assume the tool's executable is named "mytool"
const toolName = 'mytool';

// Get the directories from the PATH environment variable
const pathDirectories = process.env.PATH.split(delimiter);

// Search for the tool in each directory
for (const dir of pathDirectories) {
   const toolPath = path.join(dir, toolName);
   // Check if the tool exists at this path
   // (You can use fs.existsSync or other file system checks)
   if (toolExists(toolPath)) {
      console.log(`Found ${toolName} at: ${toolPath} `);
      break; // Stop searching once found
   }
}

function toolExists(toolPath) {
   // Implement your logic to check if the tool exists
   // (e.g., using fs.existsSync or other checks)
   // Return true if the tool exists, false otherwise
   return true; // Placeholder for demonstration
}

// - The`path.delimiter` property provides the correct 
// delimiter for the current platform(either`;` or`:`).
// - By splitting the `PATH` environment variable using 
// this delimiter, you get an array of directories to search.
// - The code then constructs potential paths for the tool 
// by joining each directory with the tool name.
// - It checks if the tool exists at each path and 
// stops searching once found.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// The process.arch property is used to 
// get CPU architecture of the computer 
// for which the current node.js is compiled. 

This property returns 
// the operating system CPU architecture 
// for which the current node.js is compiled for. 
// The possible values are ‘x32’, ‘x64’, ‘arm’,
//  ‘arm64’, ‘s390’, ‘s390x’, ‘mipsel’, ‘ia32’,
//  ‘mips’, ‘ppc’ and ‘ppc64’.


const process = require('process');

// Printing process.arch property value 
console.log(process.arch);
// Output:
// x64

const process = require('process');

// Printing process.arch property value 
switch (process.arch) {
    case 'x32':
        console.log("32-bit extended systems");
        break;
    case 'x64':
        console.log("64-bit extended systems");
        break;
    case 'arm':
        console.log("32-bit  Advanced RISC Machine");
        break;
    case 'arm64':
        console.log("64-bit  Advanced RISC Machine");
        break;
    case 's390':
        console.log("31-bit The IBM System/390, the "
            + "third generation of the System/360"
            + " instruction set architecture");
        break;
    case 's390x':
        console.log("64-bit The IBM System/390, the "
            + "third generation of the System/360"
            + " instruction set architecture");
        break;
    case 'mipsel':
        console.log("64-bit Microprocessor without "
            + "Interlocked Pipelined Stages");
        break;
    case 'mips':
        console.log("32-bit Microprocessor without "
            + "Interlocked Pipelined Stages");
        break;
    case 'ia32':
        console.log("32-bit Intel Architecture");
        break;
    case 'ppc':
        console.log("PowerPC Architecture.");
        break;
    case 'ppc64':
        console.log("64-bit PowerPC Architecture.");
        break;
    default:
        colsole.log(" unknown architecture");
}
// Output:
// 64-bit extended systems


// The process.argv property is used to get the arguments 
// passed to the node.js process when 
// run in the command line. 

This property returns 
// an array containing the arguments 
// passed to the process when run it 
// in the command line. The first element 
// is the process execution path and 
// the second element is the path for 
// the js file.

const process = require('process');

// Printing process.argv property value 
console.log(process.argv);
// Output:
// [ 'C:\\Program Files\\nodejs\\node.exe',
//   'C:\\nodejs\\g\\process\\argv_1.js',
//   'extra_argument1',
//   'extra_argument2',
//   '3' 
// ]


const process = require('process');

// Printing process.argv property value 
var args = process.argv;

console.log("number of arguments is " + args.length);

args.forEach((val, index) => {
    console.log(`${index}: ${val}`);
});
// number of arguments is 5
// 0: C:\Program Files\nodejs\node.exe
// 1: C:\nodejs\g\process\argv_2.js
// 2: extra_argument1
// 3: extra_argument2
// 4: 3

// The process.config property isto get 
// the JavaScript representation of 
// the configure options that are used 
// to compile the current node.js code.

const process = require('process');

// Printing process.config property value
var no_conf = 0;
var conf = process.config;
for (var key in conf) {
   console.log(key);
   var sub_conf = conf[key];

   for (var attr in sub_conf) {
      console.log("\t" + attr + "=>" + sub_conf[attr]);
      no_conf++;
   }
}

console.log("total no of configuration available is "
   + no_conf);
// ### Use Case: Customizing Node.js Compilation Options
// You want to tweak certain compilation options 
// to optimize performance or enable specific 
// features. The `process.config` property 
// allows you to access these configuration settings.

// 1. ** Scenario:**
//- You're building a specialized Node.js distribution 
// for an embedded system or a specific use case.
//- You want to customize compilation options based on your requirements.


   // Assume you're working on a custom Node.js build process
   const customConfig = process.config;

   // Example: Adjusting V8 optimization settings
   customConfig.variables.v8_optimized_debug = 1;
   customConfig.variables.v8_enable_gdbjit = 1;

   // Example: Enabling specific features
   customConfig.variables.node_use_large_pages = true;
   customConfig.variables.node_use_dtrace = false;

   // Log the modified configuration
   console.log('Custom Node.js Configuration:');
   console.log(customConfig);

//    - You access the `process.config` object, which contains various configuration options.
//    - In this example, we modify the V8 optimization settings(`v8_optimized_debug` and`v8_enable_gdbjit`) and enable large pages support(`node_use_large_pages`).
//    - You can adjust other options based on your project's needs.
//    - Customizing compilation options allows you to fine - tune Node.js behavior.
//    - It's especially useful when building specialized distributions or optimizing for specific use cases.
//    - By leveraging`process.config`, you gain insights into the underlying compilation choices.

// The process.env property is used to 
// get the user environment. 

//This property returns 
// an object containing the user environment. 

const process = require('process');

// Printing process.env property value
console.log(process.env);

// Include process module
const process = require('process');

// Printing process.env property value
var no_env = 0;

// Calling process.env
var env = process.env;

// Iterating through all returned data
for (var key in env) {
     // Print value
     console.log(key + ":\t\t\t" + env[key]);
     no_env++;
}

// Printing count
console.log("total no of values available = "
     + no_env);

// Accessing one by one
console.log("operating system: " + env['OS']);
console.log("alluserprofile: " + env['ALLUSERSPROFILE']);
console.log("public directory: " + env['PUBLIC']);

// Include process module
const process = require('process');

// Printing process.env property value
var env = process.env;

console.log("operating system: " + env.OS);
console.log("alluserprofile: " + env.ALLUSERSPROFILE);
console.log("public directory: " + env.PUBLIC);

// Setting new data
env.gekcho = "gekcho custom data";
console.log("stored in env.gekcho: " + env.gekcho);

// Delete data
delete env.gekcho
console.log("stored in env.gekcho: " + env.gekcho);

//it plays a crucial role in 
// configuring applications across different 
// environments

//    - ** Use Case **: Configuring different application environments(e.g., development, testing, production).
//    - ** Scenario **: Your application behaves differently based on the environment(e.g., database connections, API keys, logging levels).
const environment = process.env.NODE_ENV || 'development';
const config = require(`./ config / ${environment}.json`);
//    - ** Use Case **: Safely storing sensitive data(e.g., API keys, database credentials).
//    - ** Scenario **: You want to avoid hardcoding secrets directly in your code.
const apiKey = process.env.API_KEY;
const dbPassword = process.env.DB_PASSWORD;
//    - ** Use Case **: Adjusting application behavior based on environment variables.
//    - ** Scenario **: You want to enable or disable specific features dynamically.
if (process.env.FEATURE_FLAG === 'true') {
     // Enable experimental feature
} else {
     // Use default behavior
}
//    - ** Use Case **: Controlling logging levels or enabling debugging.
//    - ** Scenario **: You want to log different messages based on the environment.

if (process.env.LOG_LEVEL === 'debug') {
     // Log detailed information
} else {
     // Log only essential messages
}
//    - ** Use Case **: Integrating with external services(e.g., cloud providers, payment gateways).
//    - ** Scenario **: You need to provide API keys or endpoints.
const awsAccessKey = process.env.AWS_ACCESS_KEY;
const paymentGatewayUrl = process.env.PAYMENT_GATEWAY_URL;
// `process.env` provides
// a convenient way to access environment
// variables across different
// platforms(Windows, Unix - like systems).
// It's a powerful tool for managing
// configurations and ensuring your
// application behaves consistently
// across various environments.

// The process.execPath property is used to get the absolute pathname 
// of the node.js executable which started 
// the node.js process.
process.execPath

//This property returns a string 
// signifies the absolute path of the node.js 
// executable which started the node.js process.

const process = require('process');

// Printing process.execPath
console.log(process.execPath);
// C:\Program Files\nodejs\node.exe


// Include process module
const process = require('process');

// Include path module
const path = require('path');

// Printing process.execPath
var execpath = process.execPath
console.log(execpath);

// Separated directories and file
console.log(execpath.split(path.sep));
// C:\Program Files\nodejs\node.exe
// [ 'C:', 'Program Files', 'nodejs', 'node.exe' ]

// Imagine you're developing firmware for 
// an embedded system that runs Node.js. 
// This system has resource constraints, 
// and you want to optimize the Node.js 
// execution path. The `process.execPath` 
// property allows you to customize 
// the Node.js binary path dynamically 
// based on the system's requirements.

//    - You're building an IoT device that relies on Node.js for specific tasks (e.g., sensor data processing, communication).
//    - The device has limited storage, and you want to use a custom Node.js binary optimized for size and performance.
//    - Instead of using the default Node.js binary path (e.g., `/usr/bin/node`), you'll provide a custom path.
//    - The goal is to use a stripped-down Node.js binary or a version compiled with specific flags.

const customNodePath = '/opt/mycustomnode/bin/node'; // Example custom path

// Update the Node.js executable path
process.execPath = customNodePath;

// Now your application uses the custom Node.js binary
console.log(`Using custom Node.js binary at: ${process.execPath}`);
//    - By assigning a custom path to `process.execPath`, you override the default Node.js binary location.
//    - You can place your custom Node.js binary in a specific directory (e.g., `/opt/mycustomnode`) and adjust the path accordingly.
//    - Customizing the execution path allows you to use a tailored Node.js binary.
//    - You can strip unnecessary features, enable specific flags, or compile Node.js with minimal dependencies.
//    - It's especially valuable for resource-constrained devices where every byte matters.
//    - Consider cross-compiling Node.js for your target architecture (e.g., ARM, MIPS) to further optimize size and performance.
//    - Tools like `musl-cross-make` or `buildroot` can help create custom Node.js binaries.

// Node.js process.platform Property is used to get 
// the Operating System platform information.

process.platform
// This property returns a string 
// that represents the operating system platform. 
// The returned value can be one of these ‘aix’,
//  ‘android’, ‘darwin’, ‘freebsd’, ‘linux’, ‘openbsd’, 
// ‘sunprocess’, and ‘win32’. This values is set 
// at compile time.

// Include process module 
const process = require('process');

// Printing process.platform property value 
console.log(process.platform);
// Output: 
// win32


// Include process module 
const process = require('process');

// Printing process.platform property value 
var platform = process.platform;
switch (platform) {
    case 'aix':
        console.log("IBM AIX platform");
        break;
    case 'darwin':
        console.log("Darwin platform(MacOS, IOS etc)");
        break;
    case 'freebsd':
        console.log("FreeBSD Platform");
        break;
    case 'linux':
        console.log("Linux Platform");
        break;
    case 'openbsd':
        console.log("OpenBSD platform");
        break;
    case 'sunos':
        console.log("SunOS platform");
        break;
    case 'win32':
        console.log("windows platform");
        break;
    default:
        console.log("unknown platform");
}
// Output: 
//// windows platform

//    - **Use Case**: Customizing behavior based on the operating system.
//    - **Scenario**: Your application needs to execute different 
//          logic or use platform-specific features.
if (process.platform === 'win32') {
    // Windows-specific code
} else if (process.platform === 'linux') {
    // Linux-specific code
} else if (process.platform === 'darwin') {
    // macOS-specific code
}

// 2. **File Path Handling:**
//    - **Use Case**: Constructing file paths dynamically.
//    - **Scenario**: You want to create paths that work 
//      seamlessly across different platforms.
const path = require('path');
const userConfigPath = path.join(process.env.HOME, '.myapp', 'config.json');

// 3. **Binary Distribution:**
//    - **Use Case**: Distributing platform-specific binaries.
//    - **Scenario**: You're packagin
const binaryPath = path.join(__dirname, 'bin', process.platform, 'mybinary');

// 4. **System Information:**
//    - **Use Case**: Gathering system-related details.
//    - **Scenario**: You want to display OS-specific information 
//      in your application.
console.log(`Running on ${process.platform}`);

// 5. **Cross-Platform Compatibility:**
//    - **Use Case**: Ensuring compatibility across Windows, Linux, and macOS.
//    - **Scenario**: Your application relies on external tools or libraries 
//      with different behavior on each platform.
const isWindows = process.platform === 'win32';
const isLinux = process.platform === 'linux';
const isMac = process.platform === 'darwin';

// 6. **Conditional Dependencies:**
//    - **Use Case**: Installing platform-specific dependencies.
//    - **Scenario**: Your project requires different packages based on the OS.
"dependencies": {
    "my-package": "^1.0.0",
    "my-package-win32": "^1.0.0",
    "my-package-linux": "^1.0.0"
}

// `process.platform` provides 
// a consistent way to detect the operating 
// system, making your Node.js applications 
// more robust and adaptable. Whether you're
//  handling paths, configuring behavior, 
// or managing dependencies, this property 
// ensures cross-platform compatibility.



































