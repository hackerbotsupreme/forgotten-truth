// Node.js is not a framework or a programming language. 

// What is Node.js?
// Node.js is an open-source and cross-platform 
// runtime environment for executing JavaScript 
// code outside a browser(on the server). It is free and runs 
// on different platforms. It lets developers 
// run JavaScript code on the server.

// Node.js = Runtime Environment + JavaScript Library

// Why Node.js?
// Node.js is used to build back-end services 
// like APIs like Web App, Mobile App or Web Server. 
// A Web Server will open a file on the server and
//  return the content to the client. It’s used 
// in production by large companies such 
// as Paypal, Uber, Netflix, Walmart, and so on.


// Node.js is an open source server-side 
// Javascript run-time environment built 
// on Chrome’s JavaScript Engine(V8). 
// Node.js is used for building fast and 
// scalable applications and is an event driven,
//  non-blocking I/O model. REPL (READ, EVAL, 
// PRINT, LOOP) is a computer environment similar 
// to Shell (Unix/Linux) and command prompt. 
// Node comes with the REPL environment when 
// it is installed. 

System interacts with 
// the user through outputs of commands/expressions 
// used. It is useful in writing and debugging the 
// codes. The work of REPL can be understood from 
// its full form: 

// Read : It reads the inputs from 
// users and parses it into JavaScript data structure. 
// It is then stored to memory. 

// Eval : The parsed
//  JavaScript data structure is evaluated for the
//  results. 

//  Print : The result is printed after the
//  evaluation. 

// Loop : Loops the input command. To come 
// out of NODE REPL, press ctrl+c twice 

REPLs are valuable because they allow developers to:
Experiment: Quickly test code snippets, explore new features, and try out ideas.
Debug: Inspect intermediate results and identify issues.
Learn: Understand language features interactively.
Iterate: Modify and reuse code rapidly.
Explore Libraries: Test library functions and APIs.


how to open node js repl ?
Open Your Terminal or Command Prompt
Type the Following Command:
node
Press Enter.
You’ll See a Prompt Like This:
>

This indicates that you’re now in the Node.js REPL.
Start Entering JavaScript and Node.js Code:
For example, type:
> console.log('test')

You’ll see the output:
test
undefined

Understanding the Output:
The first value, “test,” is what we told the console to print.
The second line, “undefined,” is the return value of running console.log().
Node evaluates each line of code, prints the result, and waits for more input.
Experiment and Explore:
You can test expressions, define functions, and interactively develop code.
To exit the REPL, press Ctrl + C twice or type .exit.

// NPM (Node Package Manager) is the default 
// package manager for Node and is written entirely 
// in JavaScript

 The required packages 
// and modules in Node project are installed 
// using NPM. A package contains all the files 
// needed for a module and modules are 
// the JavaScript libraries that can be 
// included in Node project according to 
// the requirement of the project.

// NPM can install all the dependencies of 
// a project through the package.json file. 
// It can also update and uninstall packages. 
// In the package.json file, each dependency 
// can specify a range of valid versions using 
// the semantic versioning scheme, allowing 
// developers to auto-update their packages 
// while at the same time avoiding unwanted 
// breaking changes.

// Some facts about NPM:
// At the time of writing this article, 
// NPM has 580096 registered packages. 
// The average rate of growth of this number 
// is 291/day which outraces every other 
// package registry.

// As npm is a global package, -g flag 
// is used to update it globally.

// Creating a Node Project:
// To create a Node project, npm init is 
// used in the folder in which user want 
// to create project. The npm command line 
// will ask a number of questions like name,
// license, scripts, description, author, 
// keywords, version, main file etc. 
// After npm is done creating the project, 
// a package.json file will be visible in 
// project folder as a proof that 
// the project has been initialized.


// Installing Packages:
// After creating the project, next step 
// is to incorporate the packages and modules 
// to be used in the Node Project. To install 
// packages and modules in the project 
// use the following syntax:

// Syntax to install Node Package:
npm install package_name


// Example: Installing the express package 
// into the project. Express is the web 
// development framework used by the Node

npm install express

// Using a package in Node
// To use express in the Node, follow the below syntax:

// Syntax to use Installed Packages:
var express = require('express');


// Installing a Package Globally
// To install a package globally (accessible 
// by all projects in system), add an extra -g tag 
// in syntax used to install the package. 
// Installing nodemon package globally.

// Syntax to Install Packages Globally:
npm install nodemon -g


// Controlling where the package gets installed:
// To install a package and simultaneously save 
// it in package.json file (in case using Node.js), 
// add –save flag. The –save flag is default 
// in npm install command so it is equal 
// to npm install package_name command.

// Example:
npm install express --save

// Usage of Flags:

// –save:
// flag one can control where the packages are to be installed.

// –save-prod :
// Using this, packages will appear in Dependencies which is also by default.

// –save-dev :
// Using this packages will get appear in devDependencies 
// and will only be used in the development mode.

// Note: If there is a package.json file with all 
// the packages mentioned as dependencies already, 
// just type npm install in terminal

// Save Directory of Installed Modules
// NPM installs the dependencies in local mode (Default) 
// which go to the node_modules directory present in 
// the folder of Node application. To see all 
// the locally installed modules use npm ls command.

// Uninstalling Packages:
// To uninstall packages using npm, follow the below syntax:

// Syntax to uninstall packages:
npm uninstall
// Example: To uninstall the express package

npm install package_name example
// Uninstalling express

// Syntax to uninstall Global Packages:

npm uninstall package_name - g
// Using Semantic Versioning to manage packages:
// versioning major minor patch explanation
// To install a package of a specific version, 
// mention the full and exact version in 
// the package.json file.

// To install the latest version of the package, 
// mention “*” in front of the dependency or “latest”. 
// This will find the latest stable version of 
// the module and install it.

// If you’re using npm:

// npm install express@latest

// Or, if you’re specifying it in your package.json file:

// JSON
// "dependencies": {
//   "express": "*"
// }

// In both cases, npm will fetch and install 
// the latest stable version of the express package. 
// The @latest tag in the command line and the * in 
// the package.json file are used to specify that 
// you want the latest version.

// Remember to run npm install after updating 
// your package.json file to install 
// the specified versions of your dependencies.

// To install any version (stable one) above 
// a given version, mention it like in the example 
// below: “express”:”^4.1.1″. in package.json file. 
// The caret symbol (^) is used to tell the npm 
// to find a version greater than 4.1.1 and install it.
// like this:

// "dependencies": {
//     "express": "^4.1.1"
// }

// Remember to run npm install after updating your package.json 
// file to install the specified versions of your dependencies.

// Node.js is an open-source project that 
// can be used for server-side scripting. 

// Node.js is an open-source project that 
// can be used for server-side scripting. 

// Node.js Global Objects are the objects 
// that are available in all modules.
//  Global Objects are built-in objects 
// that are part of the JavaScript and 
// can be used directly in the application 
// without importing any particular module. 
globally it can be used without importing 
// any module.

Global objects#
These objects are available in all modules.
and they are accessible without importing any modules . 

In **Node.js**, global objects and built-in objects are related but not exactly the same. Let's explore the distinction:

1. **Built-in Objects**:
    - These objects are **part of the JavaScript language itself** and are available globally.
    - Examples include `String`, `Array`, `Number`, `Math`, `Date`, and `RegExp`.
    - You can use them directly without requiring any specific module imports.
    - Built-in objects provide essential functionality for working with data and performing common operations.

2. **Global Objects**:
    - These objects are available globally within a Node.js environment.
    - While some global objects are also built-in (like `String` and `Array`), others are specific to Node.js.
    - Examples of Node.js-specific global objects include:
        - `__dirname` and `__filename`: Provide information about the current directory and filename of the module.
        - `exports` and `module`: Related to the CommonJS module system for exporting and managing modules.
        - `require()`: Used to import other modules.
        - `process`: Provides information about the current Node.js process, environment variables, and more.
        - `console`: Used for logging messages and debugging.
        - `Buffer`: Handles binary data and streams.
        - `setImmediate()`, `setTimeout()`, and `setInterval()`: Functions for scheduling asynchronous tasks.
        - `global`: Contains the objects mentioned above, although it's specific to Node.js modules.

Remember that while built-in objects are a subset of global objects, the latter extends beyond the core JavaScript language to include Node.js-specific functionality. 🌟¹²³


// Node.js Modules
// In Node.js, Modules are the blocks of 
// encapsulated code that communicate with 
// an external application on the basis of 
// their related functionality. Modules can
//  be a single file or a collection of 
// multiple files/folders. The reason 
// programmers are heavily reliant on modules 
// is because of their reusability as well as 
// the ability to break down a complex piece 
// of code into manageable chunks. 

// Modules are of three types:
// Core Modules
// local Modules
// Third-party Modules

// Core Modules: Node.js has many built-in 
// modules that are part of the platform and 
// come with Node.js installation. These modules 
// can be loaded into the program by using 
// the required function.

const http = require('http');
http.createServer(function (req, res) {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.write('Welcome to this page!');
    res.end();
}).listen(3000);

// In the above example, the require() function 
// returns an object because the Http module 
// returns its functionality as an object. 

// The function http.createServer() method 
// will be executed when someone tries to 
// access the computer on port 3000. 
// The res.writeHead() method is the status 
// code where 200 means it is OK, while 
// the second argument is an object containing 
// the response headers. The following list 
// contains some of the important core modules in Node.js:

// Core Modules	            Description
// http	                    creates an HTTP server in Node.js.
// assert	                set of assertion functions useful for testing.
// fs	                    used to handle file system.
// path	                    includes methods to deal with file paths.
// process	                provides information and control about the current Node.js process.
// os	                    provides information about the operating system.
// querystring	            utility used for parsing and formatting URL query strings.
// url	                    module provides utilities for URL resolution and parsing.



// Local Modules: Unlike built-in and external modules, 
// local modules are created locally in your Node.js 
// application. Let’s create a simple calculating module 
// that calculates various operations. 
// Create a calc.js file that has the following code: 

// Filename: calc.js 
exports.add = function (x, y) {
    return x + y;
};

exports.sub = function (x, y) {
    return x - y;
};

exports.mult = function (x, y) {
    return x * y;
};

exports.div = function (x, y) {
    return x / y;
};
// Since this file provides attributes to 
// the outer world via exports, another file 
// can use its exported functionality using 
// the require() function. 

// Filename: index.js 
const calculator = require('./calc');

let x = 50, y = 10;

console.log("Addition of 50 and 10 is "
    + calculator.add(x, y));

console.log("Subtraction of 50 and 10 is "
    + calculator.sub(x, y));

console.log("Multiplication of 50 and 10 is "
    + calculator.mult(x, y));

console.log("Division of 50 and 10 is "
    + calculator.div(x, y));
// Step to run this program: Run the index.js 
// file using the following command:

// node index.js
// Output:

// Addition of 50 and 10 is 60
// Subtraction of 50 and 10 is 40
// Multiplication of 50 and 10 is 500
// Division of 50 and 10 is 5

// Note: This module also hides functionality 
// that is not needed outside of the module.

// Third-party modules: Third-party modules 
// are modules that are available online using 
// the Node Package Manager(NPM). These modules 
// can be installed in the project folder or globally. 
// Some of the popular third-party modules are 
// Mongoose, express, angular, and React. 


// Node.js comes with different predefined(built-in) 
// modules (e.g. http, fs, path, etc.) that 
// we use and scale our project. We can 
// define modules locally as Local Module. 
// It consists of different functions 
// declared inside a JavaScript object 
// and we reuse them according to the requirement. 
// We can also package it and distribute it using NPM. 



// Defining local module: Local module must 
// be written in a separate JavaScript file. 
// In the separate file, we can declare 
// a JavaScript object with different
//  properties and methods. 

// Step 1: Create a local module with 
// the filename Welcome.js 

const welcome = {
    sayHello: function () {
        console.log("Hello GeekforGeeks user");
    },
    currTime: new Date().toLocaleDateString(),
    companyName: "GeekforGeeks"
}
module.exports = welcome

// Explanation: Here, we declared 
// an object ‘welcome’ with a function sayHello 
// and two variables currTime and companyName. 
// We use the module.export to make 
// the object available globally. 

// Part 2: In this part, use 
// the above module in the app.js file. 

const local = require("./Welcome.js");
local.sayHello();
console.log(local.currTime);
console.log(local.companyName);

// Explanation: Here, we import our 
// local module ‘sayHello’ in a variable 
// ‘local’ and consume the function and 
// variables of the created modules.


// Assert module in Node.js provides 
// a bunch of facilities that are useful 
// for the assertion of the function. 
// The assert module provides a set 
// of assertion functions for verifying 
// invariants. If the condition is true 
// it will output nothing else 
// an assertion error is given by the console.


console.clear()
const assert = require('assert');

let x = 4;
let y = 5;

try {
    // Checking condition 
    assert(x == y);
}
catch {
    // Error output 
    console.log(
        `${x} is not equal to ${y}`);
}

// Buffers are instances of the Buffer 
// class in Node.js. Buffers are designed 
// to handle binary raw data. Buffers allocate 
// raw memory outside the V8 heap. Buffer class 
// is a global class

// Create an uninitiated buffer: It creates 
// the uninitiated buffer of given size.
// Syntax: 
var ubuf = Buffer.alloc(5);
// The above syntax is used to create 
// an uninitiated buffer of 5 octets.



// Asynchronous flow control
// The material in this post is heavily 
// inspired by Mixu's Node.js Book.
// https://book.mixu.net/node/ch7.html 
// - very good resource , do read it 

// At its core, JavaScript is designed to 
// be non-blocking on the "main" thread, 
// this is where views are rendered. You 
// can imagine the importance of this in 
// the browser. When the main thread 
// becomes blocked it results in the 
// infamous "freezing" that end users 
// dread, and no other events can be 
// dispatched resulting in the loss of 
// data acquisition, for example.

// This creates some unique constraints 
// that only a functional style of 
// programming can cure. This is where 
// callbacks come in to the picture.

// However, callbacks can become 
// challenging to handle in more 
// complicated procedures. This 
// often results in "callback hell" 
// where multiple nested functions 
// with callbacks make the code more 
// challenging to read, debug, organize, etc.

async1(function (input, result1) {
  async2(function (result2) {
    async3(function (result3) {
      async4(function (result4) {
        async5(function (output) {
          // do something with output
        });
      });
    });
  });
});
// JavaScript

// Of course, in real life there would 
// most likely be additional lines of 
// code to handle result1, result2, etc., 
// thus, the length and complexity of 
// this issue usually results in code 
// that looks much more messy than 
// the example above.

// This is where functions come in 
// to great use. More complex operations 
// are made up of many functions:
// 1.initiator style / input
// 2.middleware
// 3.terminator

// The "initiator style / input" is the 
// first function in the sequence. This 
// function will accept the original input, 
// if any, for the operation. The operation 
// is an executable series of functions, 
// and the original input will primarily be:
// 1.variables in a global environment
// 2.direct invocation with or without arguments
// 3.values obtained by file system or network requests

// Network requests can be incoming requests 
// initiated by a foreign network, by another 
// application on the same network, or by 
// the app itself on the same or foreign network.

// A middleware function will return another 
// function, and a terminator function will 
// invoke the callback. The following 
// illustrates the flow to network or file 
// system requests. Here the latency is 0 
// because all these values are available in memory.

function final(someInput, callback) {
  callback(`${someInput} and terminated by executing callback `);
}
function middleware(someInput, callback) {
  return final(`${someInput} touched by middleware `, callback);
}
function initiate() {
  const someInput = 'hello this is a function ';
  middleware(someInput, function (result) {
    console.log(result);
    // requires callback to `return` result
  });
}
initiate();
// JavaScript

// State management
// Functions may or may not be state 
// dependent. State dependency arises 
// when the input or other variable of 
// a function relies on an outside function.

// In this way there are two primary 
// strategies for state management:

// 1.passing-in variables directly to a function, and
// 2.acquiring a variable value from 
//a cache, session, file, database, network, or other outside source.

// Note, I did not mention global variable. 
// Managing state with global variables is 
// often a sloppy anti-pattern that makes 
// it difficult or impossible to guarantee 
// state. Global variables in complex programs 
// should be avoided when possible.

// Control flow
// If an object is available in memory, 
// iteration is possible, and there will 
// not be a change to control flow:

function getSong() {
  let _song = '';
  let i = 100;
  for (i; i > 0; i -= 1) {
    _song += `${i} beers on the wall, you take one down and pass it around, ${
      i - 1
    } bottles of beer on the wall\n`;
    if (i === 1) {
      _song += "Hey let's get some more beer";
    }
  }
  return _song;
}
function singSong(_song) {
  if (!_song) throw new Error("song is '' empty, FEED ME A SONG!");
  console.log(_song);
}
const song = getSong();
// this will work
singSong(song);
// JavaScript

// However, if the data exists outside of 
// memory the iteration will no longer work:

function getSong() {
  let _song = '';
  let i = 100;
  for (i; i > 0; i -= 1) {
    /* eslint-disable no-loop-func */
    setTimeout(function () {
      _song += `${i} beers on the wall, you take one down and pass it around, ${
        i - 1
      } bottles of beer on the wall\n`;
      if (i === 1) {
        _song += "Hey let's get some more beer";
      }
    }, 0);
    /* eslint-enable no-loop-func */
  }
  return _song;
}
function singSong(_song) {
  if (!_song) throw new Error("song is '' empty, FEED ME A SONG!");
  console.log(_song);
}
const song = getSong('beer');
// this will not work
singSong(song);
// Uncaught Error: song is '' empty, FEED ME A SONG!


// JavaScript
// Why did this happen? setTimeout instructs 
// the CPU to store the instructions elsewhere 
// on the bus, and instructs that the data is 
// scheduled for pickup at a later time. 
// Thousands of CPU cycles pass before the 
// function hits again at the 0 millisecond 
// mark, the CPU fetches the instructions 
// from the bus and executes them. The only 
// problem is that song ('') was returned 
// thousands of cycles prior.

// The same situation arises in dealing 
// with file systems and network requests. 

// The main thread simply cannot be blocked 
// for an indeterminate period of time-- 
// therefore, we use callbacks to schedule 
// the execution of code in time in a controlled manner.

// You will be able to perform almost 
// all of your operations with the 
// following 3 patterns:

// 1.In series: 
//functions will be executed 
// in a strict sequential order, this one 
// is most similar to for loops.
// operations defined elsewhere and ready to execute
const operations = [
  { func: function1, args: args1 },
  { func: function2, args: args2 },
  { func: function3, args: args3 },
];
function executeFunctionWithArgs(operation, callback) {
  // executes function
  const { args, func } = operation;
  func(args, callback);
}
function serialProcedure(operation) {
  if (!operation) process.exit(0); // finished
  executeFunctionWithArgs(operation, function (result) {
    // continue AFTER callback
    serialProcedure(operations.shift());
  });
}
serialProcedure(operations.shift());
// JavaScript


// 2.Full parallel: when ordering is not an 
// issue, such as emailing a list of 
// 1,000,000 email recipients.
let count = 0;
let success = 0;
const failed = [];
const recipients = [
  { name: 'Bart', email: 'bart@tld' },
  { name: 'Marge', email: 'marge@tld' },
  { name: 'Homer', email: 'homer@tld' },
  { name: 'Lisa', email: 'lisa@tld' },
  { name: 'Maggie', email: 'maggie@tld' },
];
function dispatch(recipient, callback) {
  // `sendEmail` is a hypothetical SMTP client
  sendMail(
    {
      subject: 'Dinner tonight',
      message: 'We have lots of cabbage on the plate. You coming?',
      smtp: recipient.email,
    },
    callback
  );
}
function final(result) {
  console.log(`Result: ${result.count} attempts \
      & ${result.success} succeeded emails`);
  if (result.failed.length)
    console.log(`Failed to send to: \
        \n${result.failed.join('\n')}\n`);
}
recipients.forEach(function (recipient) {
  dispatch(recipient, function (err) {
    if (!err) {
      success += 1;
    } else {
      failed.push(recipient.name);
    }
    count += 1;
    if (count === recipients.length) {
      final({
        count,
        success,
        failed,
      });
    }
  });
});
// JavaScript


//3. Limited parallel: parallel with limit, such as 
// successfully emailing 1,000,000 recipients 
// from a list of 10E7 users.
let successCount = 0;
function final() {
  console.log(`dispatched ${successCount} emails`);
  console.log('finished');
}
function dispatch(recipient, callback) {
  // `sendEmail` is a hypothetical SMTP client
  sendMail(
    {
      subject: 'Dinner tonight',
      message: 'We have lots of cabbage on the plate. You coming?',
      smtp: recipient.email,
    },
    callback
  );
}
function sendOneMillionEmailsOnly() {
  getListOfTenMillionGreatEmails(function (err, bigList) {
    if (err) throw err;
    function serial(recipient) {
      if (!recipient || successCount >= 1000000) return final();
      dispatch(recipient, function (_err) {
        if (!_err) successCount += 1;
        serial(bigList.pop());
      });
    }
    serial(bigList.pop());
  });
}
sendOneMillionEmailsOnly();
// JavaScript
// Each has its own use cases, benefits, 
// and issues you can experiment and read 
// about in more detail. Most importantly, 
// remember to modularize your operations 
// and use callbacks! If you feel any doubt, 
// treat everything as if it were middleware!


// Anatomy of an HTTP Transaction
// The purpose of this guide is to 
// impart a solid understanding of 
// the process of Node.js HTTP handling. 
// We'll assume that you know, in 
// a general sense, how HTTP requests
//  work, regardless of language or 
// programming environment. We'll 
// also assume a bit of familiarity 
// with Node.js EventEmitters and 
// Streams. If you're not quite familiar
//  with them, it's worth taking a 
// quick read through the API docs 
// for each of those.

// Create the Server
// Any node web server application 
// will at some point have to create 
// a web server object. This is done 
// by using createServer.

const http = require('node:http');
const server = http.createServer((request, response) => {
  // magic happens here!
});
// JavaScript
// The function that's passed in 
// to createServer is called once 
// for every HTTP request that's 
// made against that server, so 
// it's called the request handler. 
// In fact, the Server object 
// returned by createServer is 
// an EventEmitter, and what we 
// have here is just shorthand 
// for creating a server object 
// and then adding the listener later.

const server = http.createServer();
server.on('request', (request, response) => {
  // the same kind of magic happens here!
});

// JavaScript
// When an HTTP request hits the 
// server, node calls the request 
// handler function with a few 
// handy objects for dealing 
// with the transaction, request 
// and response. We'll get to 
// those shortly.

// In order to actually serve 
// requests, the listen method 
// needs to be called on the 
// server object. In most cases, 
// all you'll need to pass to 
// listen is the port number you 
// want the server to listen on.

// There are some other options too, 
// so consult the API reference.

// Method, URL and Headers -> 
// When handling a request, the 
// first thing you'll probably want 
// to do is look at the method and 
// URL, so that appropriate actions 
// can be taken. Node.js makes this 
// relatively painless by putting 
// handy properties onto the 
// request object.

const { method, url } = request;
// JavaScript
// The request object is an 
// instance of IncomingMessage.

// The method here will always 
// be a normal HTTP method/verb. 
// The url is the full URL without 
// the server, protocol or port. 
// For a typical URL, this means 
// everything after and including 
// the third forward slash.

// Headers are also not far away. 
// They're in their own object on 
// request called headers.

const { headers } = request;
const userAgent = headers['user-agent'];
// JavaScript

// It's important to note here 
// that all headers are represented 
// in lower-case only, regardless of 
// how the client actually sent them. 
// This simplifies the task of 
// parsing headers for whatever purpose.

// If some headers are repeated, 
// then their values are overwritten 
// or joined together as comma-separated 
// strings, depending on the header. 
// In some cases, this can be problematic, 
// so rawHeaders is also available.

// Request Body
// When receiving a POST or PUT request, 
// the request body might be important 
// to your application. Getting at the 
// body data is a little more involved 
// than accessing request headers. The 
// request object that's passed in to 
// a handler implements the 
// ReadableStream interface. This 
// stream can be listened to or piped 
// elsewhere just like any other stream. 
// We can grab the data right out of the 
// stream by listening to the stream's 
// 'data' and 'end' events.

// The chunk emitted in each 'data' 
// event is a Buffer. If you know it's 
// going to be string data, the best 
// thing to do is collect the data 
// in an array, then at the 'end',
//  concatenate and stringify it.

let body = [];
request
  .on('data', chunk => {
    body.push(chunk);
  })
  .on('end', () => {
    body = Buffer.concat(body).toString();
    // at this point, `body` has the entire request body stored in it as a string
  });


// JavaScript
// This may seem a tad tedious, 
// and in many cases, it is. Luckily, 
// there are modules like concat-stream 
// and body on npm which can help hide 
// away some of this logic. It's 
// important to have a good understanding 
// of what's going on before going down 
// that road, and that's why you're here!

// A Quick Thing About Errors
// Since the request object is a 
// ReadableStream, it's also an 
// EventEmitter and behaves like 
// one when an error happens.

// An error in the request stream 
// presents itself by emitting an 
// 'error' event on the stream. 
// If you don't have a listener 
// for that event, the error will 
// be thrown, which could crash 
// your Node.js program. You should 
// therefore add an 'error' listener 
// on your request streams, even if 
// you just log it and continue on 
// your way. (Though it's probably 
// best to send some kind of HTTP 
// error response. More on that later.)

request.on('error', err => {
  // This prints the error message and stack trace to `stderr`.
  console.error(err.stack);
});
// JavaScript
// There are other ways of 
// handling these errors such 
// as other abstractions and tools, 
// but always be aware that errors 
// can and do happen, and you're 
// going to have to deal with them.

// What We've Got so Far
// At this point, we've covered 
// creating a server, and grabbing 
// the method, URL, headers and body 
// out of requests. When we put that 
// all together, it might look 
// something like this:

const http = require('node:http');
http
  .createServer((request, response) => {
    const { headers, method, url } = request;
    let body = [];
    request
      .on('error', err => {
        console.error(err);
      })
      .on('data', chunk => {
        body.push(chunk);
      })
      .on('end', () => {
        body = Buffer.concat(body).toString();
        // At this point, we have the headers, method, url and body, and can now
        // do whatever we need to in order to respond to this request.
      });
  })
  .listen(8080); // Activates this server, listening on port 8080.


// JavaScript
// If we run this example, 
// we'll be able to receive requests, 
// but not respond to them. In fact, 
// if you hit this example in a web 
// browser, your request would time out, 
// as nothing is being sent back to the client.

// So far we haven't touched on 
// the response object at all, which 
// is an instance of ServerResponse, 
// which is a WritableStream. It 
// contains many useful methods for 
// sending data back to the client. 
// We'll cover that next.

// HTTP Status Code
// If you don't bother setting it, 
// the HTTP status code on a response 
// will always be 200. Of course, not 
// every HTTP response warrants this, 
// and at some point you'll definitely 
// want to send a different status code. 
// To do that, you can set 
// the statusCode property.

response.statusCode = 404; // Tell the client that the resource wasn't found.
// JavaScript

// There are some other 
// shortcuts to this, 
// as we'll see soon.

// Setting Response Headers
// Headers are set through 
// a convenient method called 
// setHeader.

response.setHeader('Content-Type', 'application/json');
response.setHeader('X-Powered-By', 'bacon');
// JavaScript

// When setting the headers on 
// a response, the case is insensitive
//  on their names. If you set a 
// header repeatedly, the last value 
// you set is the value that gets sent.

// Explicitly Sending Header Data
// The methods of setting the headers 
// and status code that we've already 
// discussed assume that you're using 
// "implicit headers". This means 
// you're counting on node to send 
// the headers for you at the correct 
// time before you start sending body data.

// If you want, you can explicitly 
// write the headers to the response 
// stream. To do this, there's a method 
// called writeHead, which writes the 
// status code and the headers to 
// the stream.

response.writeHead(200, {
  'Content-Type': 'application/json',
  'X-Powered-By': 'bacon',
});
// JavaScript


// Once you've set the headers 
// (either implicitly or explicitly), 
// you're ready to start sending 
// response data.

// Sending Response Body
// Since the response object is 
// a WritableStream, writing a 
// response body out to the client 
// is just a matter of using 
// the usual stream methods.

response.write('<html>');
response.write('<body>');
response.write('<h1>Hello, World!</h1>');
response.write('</body>');
response.write('</html>');
response.end();
// JavaScript

// The end function on streams 
// can also take in some optional 
// data to send as the last bit 
// of data on the stream, so we 
// can simplify the example 
// above as follows.

response.end('<html><body><h1>Hello, World!</h1></body></html>');
// JavaScript

// It's important to set the 
// status and headers before 
// you start writing chunks 
// of data to the body. This 
// makes sense, since headers 
// come before the body in 
// HTTP responses.

// Another Quick Thing About Errors
// The response stream can also 
// emit 'error' events, and at 
// some point you're going to 
// have to deal with that as 
// well. All of the advice for 
// request stream errors still 
// applies here.

// Put It All Together
// Now that we've learned about 
// making HTTP responses, let's 
// put it all together. Building 
// on the earlier example, we're 
// going to make a server that 
// sends back all of the data that 
// was sent to us by the user. 
// We'll format that data as 
// JSON using JSON.stringify.

const http = require('node:http');
http
  .createServer((request, response) => {
    const { headers, method, url } = request;
    let body = [];
    request
      .on('error', err => {
        console.error(err);
      })
      .on('data', chunk => {
        body.push(chunk);
      })
      .on('end', () => {
        body = Buffer.concat(body).toString();
        // BEGINNING OF NEW STUFF
        response.on('error', err => {
          console.error(err);
        });
        response.statusCode = 200;
        response.setHeader('Content-Type', 'application/json');
        // Note: the 2 lines above could be replaced with this next one:
        // response.writeHead(200, {'Content-Type': 'application/json'})
        const responseBody = { headers, method, url, body };
        response.write(JSON.stringify(responseBody));
        response.end();
        // Note: the 2 lines above could be replaced with this next one:
        // response.end(JSON.stringify(responseBody))
        // END OF NEW STUFF
      });
  })
  .listen(8080);


// JavaScript
// Echo Server Example
// Let's simplify the previous 
// example to make a simple echo 
// server, which just sends whatever 
// data is received in the request 
// right back in the response. 
// All we need to do is grab the 
// data from the request stream 
// and write that data to the 
// response stream, similar to 
// what we did previously.

const http = require('node:http');
http
  .createServer((request, response) => {
    let body = [];
    request
      .on('data', chunk => {
        body.push(chunk);
      })
      .on('end', () => {
        body = Buffer.concat(body).toString();
        response.end(body);
      });
  })
  .listen(8080);
// JavaScript

// Now let's tweak this. 
// We want to only send an 
// echo under the following 
// conditions:

// The request method is POST.
// The URL is /echo.
// In any other case, we 
// want to simply respond with a 404.

const http = require('node:http');
http
  .createServer((request, response) => {
    if (request.method === 'POST' && request.url === '/echo') {
      let body = [];
      request
        .on('data', chunk => {
          body.push(chunk);
        })
        .on('end', () => {
          body = Buffer.concat(body).toString();
          response.end(body);
        });
    } else {
      response.statusCode = 404;
      response.end();
    }
  })
  .listen(8080);


// JavaScript
// By checking the URL in 
// this way, we're doing a 
// form of "routing". Other 
// forms of routing can be as 
// simple as switch statements 
// or as complex as whole frameworks 
// like express. If you're looking 
// for something that does routing 
// and nothing else, try router.

// Great! Now let's take a stab 
// at simplifying this. Remember, 
// the request object is a 
// ReadableStream and the response 
// object is a WritableStream. That 
// means we can use pipe to direct 
// data from one to the other. 
// That's exactly what we want 
// for an echo server!

const http = require('node:http');
http
  .createServer((request, response) => {
    if (request.method === 'POST' && request.url === '/echo') {
      request.pipe(response);
    } else {
      response.statusCode = 404;
      response.end();
    }
  })
  .listen(8080);
// JavaScript
// Yay streams!

// We're not quite done yet though. 
// As mentioned multiple times in 
// this guide, errors can and do 
// happen, and we need to deal with them.

// To handle errors on the request 
// stream, we'll log the error to 
// stderr and send a 400 status code 
// to indicate a Bad Request. In a 
// real-world application, though, 
// we'd want to inspect the error 
// to figure out what the correct 
// status code and message would be. 
// As usual with errors, you should 
// consult the Error documentation.

// On the response, we'll just 
// log the error to stderr.

const http = require('node:http');
http
  .createServer((request, response) => {
    request.on('error', err => {
      console.error(err);
      response.statusCode = 400;
      response.end();
    });
    response.on('error', err => {
      console.error(err);
    });
    if (request.method === 'POST' && request.url === '/echo') {
      request.pipe(response);
    } else {
      response.statusCode = 404;
      response.end();
    }
  })
  .listen(8080);
  
// JavaScript
// We've now covered most of
// the basics of handling HTTP
// requests. At this point,
// you should be able to:

// Instantiate an HTTP server
// with a request handler
// function, and have it
// listen on a port.

// Get headers, URL, method
// and body data from request objects.

// Make routing decisions
// based on URL and/or other
// data in request objects.

// Send headers, HTTP status
// codes and body data via
// response objects.

// Pipe data from request
// objects and to response objects.

// Handle stream errors in
// both the request and
// response streams.

// From these basics, Node.js HTTP
// servers for many typical use
// cases can be constructed. There
// are plenty of other things these
// APIs provide, so be sure to read
// through the API docs for
// EventEmitters, Streams, and HTTP.



Source Code: lib/buffer.js

Buffer objects are used to represent a fixed-length sequence of bytes. Many Node.js APIs support Buffers.

While the Buffer class is available within the global scope, it is still recommended to explicitly reference it via an import or require statement.

import { Buffer } from 'node:buffer';

// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10,
// filled with bytes which all have the value `1`.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using fill(), write(), or other functions that fill the Buffer's
// contents.
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing the bytes [1, 2, 3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
// are all truncated using `(value & 255)` to fit into the range 0–255.
const buf5 = Buffer.from([257, 257.5, -255, '1']);

// Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':
// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
// [116, 195, 169, 115, 116] (in decimal notation)
const buf6 = Buffer.from('tést');

// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf7 = Buffer.from('tést', 'latin1');

Node.js buffers accept all case variations of encoding strings that they receive. For example, UTF-8 can be specified as 'utf8', 'UTF8', or 'uTf8'.


Node.js v21.7.0

Usage#
node [options] [V8 options] [script.js | -e "script" | - ] [arguments]

Please see the Command-line options document for more information.

Example#
An example of a web server written with Node.js which responds with 'Hello, World!':

Commands in this document start with $ or > to replicate how they would appear in a user's terminal. Do not include the $ and > characters. They are there to show the start of each command.

Lines that don't start with $ or > character show the output of the previous command.

First, make sure to have downloaded and installed Node.js. See Installing Node.js via package manager for further install information.

Now, create an empty project folder called projects, then navigate into it.

Linux and Mac:

mkdir ~/projects
cd ~/projects COPY
Windows CMD:

mkdir %USERPROFILE%\projects
cd %USERPROFILE%\projects COPY
Windows PowerShell:

mkdir $env:USERPROFILE\projects
cd $env:USERPROFILE\projects COPY
Next, create a new source file in the projects folder and call it hello-world.js.

Open hello-world.js in any preferred text editor and paste in the following content:

const http = require('node:http');

const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!\n');
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`);
}); COPY
Save the file. Then, in the terminal window, to run the hello-world.js file, enter:

node hello-world.js COPY
Output like this should appear in the terminal:

Server running at http://127.0.0.1:3000/ COPY
Now, open any preferred web browser and visit http://127.0.0.1:3000.

If the browser displays the string Hello, World!, that indicates the server is working.

















