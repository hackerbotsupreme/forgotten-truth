1.C:\Users\rekha\OneDrive\Desktop\js-topics-code-main\js-code-flow\71.exercise and event loop.js\Script1-Concurrency model and Event Loop.js

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

event loop and concurrency model 

// The first two arguments to the function setTimeout are 
// a message to add to the queue and a time value (optional; 
// defaults to 0). The time value represents the (minimum) 
// delay after which the message will be pushed into the 
// queue. If there is no other message in the queue, and 
// the stack is empty, the message is processed right after 
// the delay. However, if there are messages, the setTimeout 
// message will have to wait for other messages to be 
// processed. For this reason, the second argument indicates 
// a minimum time â€” not a guaranteed time.

// Here is an example that demonstrates this concept 
// (setTimeout does not run immediately after its timer 
// expires):

// JS
// Copy to Clipboard
const seconds = new Date().getTime() / 1000;

setTimeout(() => {
    // prints out "2", meaning that the callback is not called immediately after 500 milliseconds.
    console.log(`Ran after ${new Date().getTime() / 1000 - seconds} seconds`);
}, 500);

while (true) {
    if (new Date().getTime() / 1000 - seconds >= 2) {
        console.log("Good, looped for 2 seconds");
        break;
    }
}
// Zero delays
// Zero delay doesn't mean the call back will fire-off after 
// zero milliseconds. Calling setTimeout with a delay of 
// 0 (zero) milliseconds doesn't execute the callback 
// function after the given interval.

// The execution depends on the number of waiting tasks in 
// the queue. In the example below, the message "this is 
// just a message" will be written to the console before 
// the message in the callback gets processed, because the 
// delay is the minimum time required for the runtime to 
// process the request (not a guaranteed time).

// The setTimeout needs to wait for all the code for queued 
// messages to complete even though you specified a 
// particular time limit for your setTimeout.

// JS
// Copy to Clipboard
(() => {
    console.log("this is the start");

    setTimeout(() => {
        console.log("Callback 1: this is a msg from call back");
    }); // has a default time value of 0

    console.log("this is just a message");

    setTimeout(() => {
        console.log("Callback 2: this is a msg from call back");
    }, 0);

    console.log("this is the end");
})();

// "this is the start"
// "this is just a message"
// "this is the end"
// "Callback 1: this is a msg from call back"
// "Callback 2: this is a msg from call back"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Several runtimes communicating together
// A web worker or a cross-origin iframe has its own stack, 
// heap, and message queue. Two distinct runtimes can only 
// communicate through sending messages via the postMessage 
// method. This method adds a message to the other runtime 
// if the latter listens to message events.


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const name = "Miriam";
const greeting = `Hello, my name is ${name}!`;
console.log(greeting);
// "Hello, my name is Miriam!"

We should note here that the browser effectively steps through the program one line at a time, in the order we wrote it. At each point, the browser waits for the line to finish its work before going on to the next line. It has to do this because each line depends on the work done in the preceding lines.

That makes this a synchronous program. It would still be synchronous even if we called a separate function, like this:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

The trouble with long-running synchronous functions

JavaScript program is single-threaded. A thread is a sequence of instructions that a program follows. Because the program consists of a single thread, it can only do one thing at a time: so if it is waiting for our long-running synchronous call to return, it can't do anything else.

What we need is a way for our program to:

Start a long-running operation by calling a function.
Have that function start the operation and return immediately, so that our program can still be responsive to other events.
Have the function execute the operation in a way that does not block the main thread, for example by starting a new thread.
Notify us with the result of the operation when it eventually completes.
That's precisely what asynchronous functions enable us to do

/////////////////////////////////////////////////////////////////

The description we just saw of asynchronous functions might remind you of event handlers, and if it does, you'd be right. Event handlers are really a form of asynchronous programming: you provide a function (the event handler) that will be called, not right away, but whenever the event happens. If "the event" is "the asynchronous operation has completed", then that event could be used to notify the caller about the result of an asynchronous function call.

An event handler is a particular type of callback. A callback is just a function that's passed into another function, with the expectation that the callback will be called at the appropriate time. As we just saw, callbacks used to be the main way asynchronous functions were implemented in JavaScript.


////////////////////////////////////////////////////////////////////

// synchronous code -  one line at a time and next line is dependent on the previous line for the execution

///////////////////////////////////////////////////////////////////////

function doStep1(init) {
  return init + 1;
}

function doStep2(init) {
  return init + 2;
}

function doStep3(init) {
  return init + 3;
}

function doOperation() {
  let result = 0;
  result = doStep1(result);
  result = doStep2(result);
  result = doStep3(result);
  console.log(`result: ${result}`);
}

doOperation();
// using callback 

function doStep1(init, callback) {
  const result = init + 1;
  callback(result);
}

function doStep2(init, callback) {
  const result = init + 2;
  callback(result);
}

function doStep3(init, callback) {
  const result = init + 3;
  callback(result);
}

function doOperation() {
  doStep1(0, (result1) => {
    doStep2(result1, (result2) => {
      doStep3(result2, (result3) => {
        console.log(`result: ${result3}`);
      });
    });
  });
}

doOperation();

///////////////////////////////////////////////////////////////////////

// so i can easily say dooperation2 has deeply nested callback function 
//  calling callbacks inside callbacks 
// which is creating a callback hell why 
// bcz is hard to understand , manage , debug and fragile too 

///////////////////////////////////////////////

Promises are the foundation of asynchronous programming in modern JavaScript. 
 A promise is an object returned by an asynchronous function ,  which represents the current state of the operation.At the time the promise is returned to the caller, the operation often isn't finished, but the promise object provides methods to handle the eventual success or failure of the operation.
In the previous article, we talked about the use of callbacks to implement asynchronous functions. With that design, you call the asynchronous function, passing in your callback function. The function returns immediately and calls your callback when the operation is finished.You can then attach handlers to this promise object, and these handlers will be executed when the operation has succeeded or failed.
////////////////////////////////////////////////////////////////////
In this example, we'll download the JSON file from https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json, and log some information about it.

To do this, we'll make an HTTP request to the server. In an HTTP request, we send a request message to a remote server, and it sends us back a response.

the fetch() API, which is the modern, promise-based replacement for XMLHttpRequest.
////////////////////////////////////////////////////////////////////
passing a handler function into the Promise's then() method.
When (and if) the fetch operation succeeds, the promise will call our handler, passing in a Response object, which contains the server's response.
////////////////////////////////////////////////////////////////////
With the fetch() API, once you get a Response object, you need to call another function to get the response data.

////////////////////////////////////////////////////////////////////

In this case, we want to get the response data as JSON, so we would call the json() method of the Response object. It turns out that json() is also asynchronous.
////////////////////////////////////////////////////////////////////

Chaining promises
With the fetch() API, once you get a Response object, you need to call another function to get the response data. In this case, we want to get the response data as JSON, so we would call the json() method of the Response object. It turns out that json() is also asynchronous. So this is a case where we have to call two successive asynchronous functions.

Try this:

JS
Copy to Clipboard
const fetchPromise = fetch(
  "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
);

fetchPromise.then((response) => {
  const jsonPromise = response.json();
  jsonPromise.then((data) => {
    console.log(data[0].name);
  });
});
////////////////////////////////////////////////////////////////////

But wait! Remember the last article, where we said that by calling a callback inside another callback, we got successively more nested levels of code? And we said that this "callback hell" made our code hard to understand? Isn't this just the same, only with then() calls?

It is, of course. But the elegant feature of promises is that then() itself returns a promise, which will be completed with the result of the function passed to it. This means that we can (and certainly should) rewrite the above code like this:

JS
Copy to Clipboard
const fetchPromise = fetch(
  "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
);

fetchPromise
  .then((response) => response.json())
  .then((data) => {
    console.log(data[0].name);
  });

Instead of calling the second then() inside the handler for the first then(), we can return the promise returned by json(), and call the second then() on that return value. This is called promise chaining and means we can avoid ever-increasing levels of indentation when we need to make consecutive asynchronous function calls.

////////////////////////////////////////////////////////////////////

Promise terminology

pending: the promise has been created, and the asynchronous function it's associated with has not succeeded or failed yet. This is the state your promise is in when it's returned from a call to fetch(), and the request is still being made.
fulfilled: the asynchronous function has succeeded. When a promise is fulfilled, its then() handler is called.
rejected: the asynchronous function has failed. When a promise is rejected, its catch() handler is called.
Note that what "succeeded" or "failed" means here is up to the API in question. For example, fetch() rejects the returned promise if (among other reasons) a network error prevented the request being sent, but fulfills the promise if the server sent a response, even if the response was an error like 404 Not Found.

////////////////////////////////////////////////////////////////////

The promise chain is what you need when your operation consists of several asynchronous functions, and you need each one to complete before starting the next one. But there are other ways you might need to combine asynchronous function calls, and the Promise API provides some helpers for them.

Yes, the Promise object is a part of the JavaScript language specification, and itâ€™s provided by the JavaScript runtime environment, which could be a web browser or a Node.js server.

Sometimes, you need all the promises to be fulfilled, but they don't depend on each other. In a case like that, it's much more efficient to start them all off together, then be notified when they have all fulfilled. The Promise.all() method is what you need here. It takes an array of promises and returns a single promise.

The promise returned by Promise.all() is:

fulfilled when and if all the promises in the array are fulfilled. In this case, the then() handler is called with an array of all the responses, in the same order that the promises were passed into all().
rejected when and if any of the promises in the array are rejected. In this case, the catch() handler is called with the error thrown by the promise that rejected.

 Promise.any()->Note that in this case we can't predict which fetch request will complete first.
////////////////////////////////////////////////////////////////////

// async and await helps to write promise based code 
// more cleaner and better 

////////////////////////////////////////////////////////////////////
Inside an async function, you can use the await keyword before a call to a function that returns a promise. This makes the code wait at that point until the promise is settled, at which point the fulfilled value of the promise is treated as a return value, or the rejected value is thrown.

This enables you to write code that uses asynchronous functions but looks like synchronous code.
////////////////////////////////////////////////////////////////////

async function fetchProducts() {
  try {
    // after this line, our function will wait for the `fetch()` call to be settled
    // the `fetch()` call will either return a Response or throw an error
    const response = await fetch(
      "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
    );
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    // after this line, our function will wait for the `response.json()` call to be settled
    // the `response.json()` call will either return the parsed JSON object or throw an error
    const data = await response.json();
    console.log(data[0].name);
  } catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}

fetchProducts();

Here, we are calling await fetch(), and instead of getting a Promise, our caller gets back a fully complete Response object, just as if fetch() were a synchronous function!

We can even use a try...catch block for error handling, exactly as we would if the code were synchronous.

Note though that async functions always return a promise, so you can't do something like:

async function fetchProducts() {
  try {
    const response = await fetch(
      "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
    );
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}

const promise = fetchProducts();
console.log(promise[0].name); // "promise" is a Promise object, so this will not work

Instead, you'd need to do something like:

async function fetchProducts() {
  try {
    const response = await fetch(
      "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
    );
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}

const promise = fetchProducts();
promise.then((data) => console.log(data[0].name));


////////////////////////////////////////////////////////////////////

Also, note that you can only use await inside an async function, unless your code is in a JavaScript module. That means you can't do this in a normal script:

try {
  // using await outside an async function is only allowed in a module
  const response = await fetch(
    "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
  );
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  const data = await response.json();
  console.log(data[0].name);
} catch (error) {
  console.error(`Could not get products: ${error}`);
}
////////////////////////////////////////////////////////////////////


Keep in mind that just like a promise chain, await forces asynchronous operations to be completed in series. This is necessary if the result of the next operation depends on the result of the last one, but if that's not the case then something like Promise.all() will be more performant.

////////////////////////////////////////////////////////////////////

Promises are the foundation of asynchronous programming in modern JavaScript. They make it easier to express and reason about sequences of asynchronous operations without deeply nested callbacks, and they support a style of error handling that is similar to the synchronous try...catch statement.

The async and await keywords make it easier to build an operation from a series of consecutive asynchronous function calls, avoiding the need to create explicit promise chains, and allowing you to write code that looks just like synchronous code.

Many modern Web APIs are promise-based, including WebRTC, Web Audio API, Media Capture and Streams API, and many more.

promise is a web api provided by the browser 

////////////////////////////////////////////////////////////////////
How to implement a promise-based API
The Promise() constructor takes a single function as an argument. We'll call this function the executor.

This executor function itself takes two arguments, which are both also functions, and which are conventionally called resolve and reject.

 In your executor implementation, you call the underlying asynchronous function. If the asynchronous function succeeds, you call resolve, and if it fails, you call reject. If the executor function throws an error, reject is called automatically.

function alarm(person, delay) {
  return new Promise((resolve, reject) => {
    if (delay < 0) {
      throw new Error("Alarm delay must not be negative");
    }
    setTimeout(() => {
      resolve(`Wake up, ${person}!`);
    }, delay);
  });
}


const name = document.querySelector("#name");
const delay = document.querySelector("#delay");
const button = document.querySelector("#set-alarm");
const output = document.querySelector("#output");

function alarm(person, delay) {
  return new Promise((resolve, reject) => {
    if (delay < 0) {
      throw new Error("Alarm delay must not be negative");
    }
    setTimeout(() => {
      resolve(`Wake up, ${person}!`);
    }, delay);
  });
}

button.addEventListener("click", () => {
  alarm(name.value, delay.value)
    .then((message) => (output.textContent = message))
    .catch((error) => (output.textContent = `Couldn't set alarm: ${error}`));
});
the alarm function youâ€™ve written is indeed a Promise-based API.

chaining Promises can handle sequences of asynchronous operations much like nested callbacks, but with improved readability and error handling.

When you chain Promises, each .then() waits for the Promise before it to resolve before it runs.

//////////////////////////////////////////////////////////////////

Using async and await with the alarm() API
Since alarm() returns a Promise, we can do everything with it that we could do with any other promise: promise chaining, Promise.all(), and async / await:

const name = document.querySelector("#name");
const delay = document.querySelector("#delay");
const button = document.querySelector("#set-alarm");
const output = document.querySelector("#output");

function alarm(person, delay) {
  return new Promise((resolve, reject) => {
    if (delay < 0) {
      throw new Error("Alarm delay must not be negative");
    }
    setTimeout(() => {
      resolve(`Wake up, ${person}!`);
    }, delay);
  });
}

button.addEventListener("click", async () => {
  try {
    const message = await alarm(name.value, delay.value);
    output.textContent = message;
  } catch (error) {
    output.textContent = `Couldn't set alarm: ${error}`;
  }
});
/////////////////////////////////////////////////////////////
Introducing workers
now i understand why the workers are introduced here ,

we'll introduce workers, which enable you to run some tasks in a separate thread of execution.

we saw what happens when you have a long-running synchronous task in your program â€” the whole window becomes totally unresponsive.

In the first article of this module, we saw what happens when you have a long-running synchronous task in your program â€” the whole window becomes totally unresponsive. Fundamentally, the reason for this is that the program is single-threaded. A thread is a sequence of instructions that a program follows. Because the program consists of a single thread, it can only do one thing at a time: so if it is waiting for our long-running synchronous call to return, it can't do anything else.

Workers give you the ability to run some tasks in a different thread, so you can start the task, then continue with other processing (such as handling user actions).


One concern from all this is that if multiple threads can have access to the same shared data, it's possible for them to change it independently and unexpectedly (with respect to each other). This can cause bugs that are hard to find.

To avoid these problems on the web, your main code and your worker code never get direct access to each other's variables, and can only truly "share" data in very specific cases. Workers and the main code run in completely separate worlds, and only interact by sending each other messages. In particular, this means that workers can't access the DOM (the window, document, page elements, and so on).

There are three different sorts of workers:

dedicated workers
shared workers
service workers

Prime generation with a worker

The "main.js" and "generate.js" files are empty. We're going to add the main code to "main.js", and the worker code to "generate.js".

steps/what we gonna do - 
First, we're creating the worker using the Worker() constructor. We pass it a URL pointing to the worker script. As soon as the worker is created, the worker script is executed.
Next, as in the synchronous version, we add a click event handler to the "Generate primes" button. But now, rather than calling a generatePrimes() function, we send a message to the worker using worker.postMessage(). This message can take an argument, and in this case, we're passing a JSON object containing two properties:
command: a string identifying the thing we want the worker to do (in case our worker could do more than one thing)
quota: the number of primes to generate.
Next, we add a message event handler to the worker. This is so the worker can tell us when it has finished, and pass us any resulting data. Our handler takes the data from the data property of the message, and writes it to the output element (the data is exactly the same as quota, so this is a bit pointless, but it shows the principle).
Finally, we implement the click event handler for the "Reload" button. This is exactly the same as in the synchronous version.

Remember that this runs as soon as the main script creates the worker.

The first thing the worker does is start listening for messages from the main script. It does this using addEventListener(), which is a global function in a worker. Inside the message event handler, the data property of the event contains a copy of the argument passed from the main script. If the main script passed the generate command, we call generatePrimes(), passing in the quota value from the message event.

The generatePrimes() function is just like the synchronous version, except instead of returning a value, we send a message to the main script when we are done. We use the postMessage() function for this, which like addEventListener() is a global function in a worker. As we already saw, the main script is listening for this message and will update the DOM when the message is received.


Note: To run this site, you'll have to run a local web server, because file:// URLs are not allowed to load workers. See our guide to setting up a local testing server. With that done, you should be able to click "Generate primes" and have your main page stay responsive.

If you have any problems creating or running the example, you can review the finished version and try it live.

The worker we just created was what's called a dedicated worker. This means it's used by a single script instance.

There are other types of workers, though:

Shared workers can be shared by several different scripts running in different windows.
Service workers act like proxy servers, caching resources so that web applications can work when the user is offline. They're a key component of Progressive Web Apps.

In this article we've introduced web workers, which enable a web application to offload tasks to a separate thread. The main thread and the worker don't directly share any variables, but communicate by sending messages, which are received by the other side as message events.

Workers can be an effective way to keep the main application responsive, although they can't access all the APIs that the main application can, and in particular can't access the DOM.

////////////////////////////////////////////////////////////////

ECMAScript 2015, also known as ES6
////////////////////////////////////////////////////////////////
ES6 introduced JavaScript Classes
////////////////////////////////////////////////////////////////
the new is a ky word 
////////////////////////////////////////////////////////////////
classes in js 

class Car {
    constructor(name, year) {
        this.name = name;
        this.year = year;
    }
}
// The example above creates a class named "Car".
// The class has two initial properties: "name" and "year".

// A JavaScript class is not an object.
// It is a template for JavaScript objects.

////////////////////////////////////////////////////////////////

 In JavaScript, classes are primarily used to create objects.

A class in JavaScript is a type of function, but instead of using the keyword function to initiate it, we use the keyword class, and the properties are assigned inside a constructor() method , The constructor method is called automatically when a new object is created which initialize object properties on new object creation .

class Car {
    constructor(name, year) {
        this.name = name;
        this.year = year;
    }
    age() {
        const date = new Date();
        return date.getFullYear() - this.year;
    }
}
const myCar = new Car("Ford", 2014);
document.getElementById("demo").innerHTML =
    "My car is " + myCar.age() + " years old.";
age is a class method 
////////////////////////////////////////////////////////////////

"use strict" -> enables strivt mode for that module/file 
////////////////////////////////////////////////////////////////

extends keyword

In JavaScript, inheritance is a mechanism that allows one object to gain the properties and methods of another object. 
1.Prototype-based inheritance :  Every JavaScript object has a prototype. The prototype is also an object. All JavaScript objects inherit their properties and methods from their prototype, 2. Class-based inheritance:In ES6, JavaScript introduced class and extends keywords to perform inheritance 

// The super() method refers to the parent class.
// By calling the super() method in the constructor method, 
// we call the parent's constructor method and gets access 
// to the parent's properties and methods.
// Inheritance is useful for code reusability: reuse 
// properties and methods of an existing class when you 
// create a new class.

// It can be smart to use getters and setters for your 
// properties, especially if you want to do something 
// special with the value before returning them, or before 
// you set them.

// To add getters and setters in the class, use the get and set keywords.

// Note: even if the getter is a method, you do not use 
// parentheses when you want to get the property value.
// The name of the getter/setter method cannot be the same 
// as the name of the property, in this case carname.
// Many programmers use an underscore character _ before 
// the property name to separate the getter/setter from 
// the actual property:

// You cannot call a static method on an object, only on an object class.
// You can call 'hello()' on the Car Class:
// But NOT on a Car Object:
// this will raise an error.

////////////////////////////////////////////////////////////////
















