PostgreSQL Tutorial
Last Updated : 18 Sep, 2023
PostgreSQL is one of the most advanced general-purpose Relational database management systems (RDMS). It is open-source software, which means the source code is available under the PostgreSQL license. Anyone with the right skills is free to use, modify, and distribute PostgreSQL in any form. It supports both relational as well as Non-Relational JSON Queries.

PostgreSQL Tutorial
In this PostgreSQL tutorial you’ll learn the basic data types(Boolean, char, text, time, int etc.), Querying and Filtering techniques like select, where, in, order by, etc. managing and modifying the tables in PostgreSQL. We’ll cover all the basic to advance concepts of PostgreSQL in this tutorial.

What is PostgreSQL?
PostgreSQL is an advanced and open-source relational database system and is used as a database for many web applications, mobile and analytics applications. It supports both SQL (relational) and JSON (non-relational) querying and It is a stable database supported by more than 20 years of development by the open-source community.



Features of PostgreSQL
PostgreSQL runs on all operating systems, Like Linux, UNIX, MAC OS and Windows and It supports text, images, sounds, and video, and includes programming interfaces for C / C++, Java, Perl, Python, Ruby, and Open Database Connectivity (ODBC).

PostgreSQL supports a big part of the SQL standard and provides many features mentioned below:

Complex SQL queries
SQL Sub-selects
Foreign keys
Trigger
Views
Transactions
Multiversion concurrency control (MVCC)
Streaming Replication (as of 9.0)
Hot Standby (as of 9.0)
Asynchronous replication
Tablespaces
Advantages of PostgreSQL
PostgreSQL has the feature of write-ahead logging.
Many replication methods are supported.
It has ability to make large-scale web applications because it is robust and powerful.
It is easy to learn.
According to the organization we can edit and modify it easily because PostgreSQL is available for free to its open source license.
Conclusion
In this PostgreSQL tutorial, You will learn all the essentials of working with PostgreSQL Like installation, connecting to the database, creating and managing databases, SQL basics, querying data, advanced queries and joins, indexing and optimization, transactions and concurrency control, security and user management, backup and restore, PostGIS for geospatial data, and PostgreSQL extensions. PostgreSQL provides number of features Which makes it a versatile and reliable choice for building robust database-driven applications.

PostgreSQL Tutorial – FAQs
1. How to create new Database in PostgreSQL?
There are two methods of creating a new database:

CREATE DATABASE (SQL command)
createdb (command-line executable)
2. What are the different Operators in PostgreSQL?
There are 4 different type of operators in PostgreSQL are as follow-

Arithmetic operators
Logic operators
Comparison operators
Bitwise operators
3. What are the disadvantages with PostgreSQL?
Performance wise PostgreSQL is slower than MySQL and Open source applications are less than MySQL.

4. How to delete a PostgreSQL database?
DROP DATABASE (SQL command)
dropdb (command-line)


What is PostgreSQL – Introduction
Last Updated : 28 Feb, 2023
This is an introductory article for the PostgreSQL database management system. In this we will look into the features of PostgreSQL and why it stands out among other relational database management systems.

Brief History of PostgreSQL:
PostgreSQL also known as Postgres, was developed by Michael Stonebraker of the University of California, Berkley. It started as the Ingres Project and later evolved into Postgresql as we know today. In the year 1982, Michael Stonebraker started a post-Ingres project to address the problems with contemporary database systems. He was awarded the Turing Award in the year 2014 for the projects and techniques pioneered in them. The POSTGRES project aimed at adding fewest features like the ability to define various data types and to fully describe relationships – something used widely, but maintained completely by the end-user. POSTGRES used various ideas of Ingres, but had its unique source code. The initial version of PostgreSQL was designed to run on UNIX-like platforms. However, it was then evolved to be mobile so that it could run on other platforms such as Mac OS X, Solaris, and Windows.

What is PostgreSQL?
PostgreSQL is one of the most advanced general-purpose object-relational database management system and is open-source. Being an open-source software, its source code is available under PostgreSQL license, a liberal open source license. Anyone with the right skills is free to use, modify, and distribute PostgreSQL in any form. As it is highly stable, very low effort is required to maintain this DBMS.

Why PostgreSQL is best for you?
The key features that make PostgreSQL a reliable and user-friendly are listed below:

User-defined types
Table inheritance
Sophisticated locking mechanism
Foreign key referential integrity
Views, rules, subquery
Nested transactions (savepoints)
Multi-version concurrency control (MVCC)
Asynchronous replication
Native Microsoft Windows Server version
Tablespaces
Point-in-time recovery
Why PostgreSQL is unique in itself?
Below is the list of features that makes PostgreSQL stand-out among other DBMS:

The multi-version concurrency control (MVCC) feature was first implemented by PostgreSQL.
Custom functions developed in languages like C/C++, Python, Java, etc can be added to PostgreSQL.
As PostgreSQL is designed to be extensible, one can define their own data types, index types, functional languages, etc.
If one intends to remove any part of the system, one can always develop a custom plugin to enhance it to meet their specific requirements.


Install PostgreSQL on Windows
Last Updated : 01 Mar, 2023
This is a step-by-step guide to install PostgreSQL on a windows machine. Since PostgreSQL version 8.0, a window installer is available to make the installation process fairly easier. 
We will be installing PostgreSQL version 11.3 on Windows 10 in this article. 

There are three crucial steps for the installation of PostgreSQL as follows: 

Download PostgreSQL installer for Windows 
 
Install PostgreSQL 
 
Verify the installation 
 
Downloading PostgreSQL Installer for Windows
You can download the latest stable PostgreSQL Installer specific to your Windows by clicking here 
 

Installing the PostgreSQL installer
After downloading the installer double click on it and follow the below steps: 

Step 1: Click the Next button 


Step 2: Choose the installation folder, where you want PostgreSQL to be installed, and click on Next. 


Step 3: Select the components as per your requirement to install and click the Next button. 


Step 4: Select the database directory where you want to store the data and click on Next. 


Step 5: Set the password for the database superuser (Postgres) 


Step 6: Set the port for PostgreSQL. Make sure that no other applications are using this port. If unsure leave it to its default (5432) and click on Next. 


Step 7: Choose the default locale used by the database and click the Next button. 


Step 8: Click the Next button to start the installation. 


Wait for the installation to complete, it might take a few minutes. 


Step 9: Click the Finish button to complete the PostgreSQL installation. 


Verifying the Installation of PostgreSQL
There are couple of ways to verify the installation of PostgreSQL like connecting to the database server using some client applications like pgAdmin or psql. 
The quickest way though is to use the psql shell. For that follow the below steps: 
 

Step 1: Search for the psql shell in the windows search bar and open it. 
 

Step 2: Enter all the necessary information like the server, database, port, username, and 
password and press Enter. 
 

Step 3: Use the command SELECT version(); you will see the following result: 
 
 

Database Operations

PostgreSQL – Create Database
Last Updated : 28 Aug, 2020
PostgreSQL has multiple ways to create a database. In this article we will discuss multiple ways to do so.

1. Using psql Shell:

To create a database through the psql shell we make the use of the CREATE DATABASE statement as below:

CREATE DATABASE db_name
 OWNER =  role_name
 TEMPLATE = template
 ENCODING = encoding
 LC_COLLATE = collate
 LC_CTYPE = ctype
 TABLESPACE = tablespace_name
 CONNECTION LIMIT = max_concurrent_connection
The various options provided by the CREATE DATABASE statement are explained below:

db_name: It is the name of the new database that you want to create.It must always be a unique name.
role_name: It is the role name of the user who will own the new database.
template: It is the name of the database template from which the new database gets created.
encoding: It specifies the character set encoding for the new database. By default, it is the encoding of the template database.
collate: It specifies a collation for the new database.
ctype: It specifies the character classification for the new database like digit, lower and upper.
tablespace_name: It specifies the tablespace name for the new database.
max_concurrent_connection: It specifies the maximum concurrent connections to the new database.
Example 1:
Here we will create a test database with all default settings.

CREATE DATABASE my_test_db1;
Output:

Example 2:
Here we will create a test database with the following parameters:

Encoding: utf-8.
Owner: GeeksForGeeks with postgres as the user.
Maximum concurrent connections: 30.
CREATE DATABASE my_test_db2
 WITH ENCODING='UTF8'
 OWNER=GeeksForGeeks
 CONNECTION LIMIT=30;
Output:


2. Using pgAdmin:

Follow the below steps to create a new database using pgAdmin.

Step 1: Log in to PostgreSQL via pgAdmin.
Step 2: Right click on the Databases menu and then click on New Database… sub-menu item as depicted below:

Step 3: Now enter the new database name, owner, and configure parameters and click the OK button as depicted below:



PostgreSQL – Loading a Database
Last Updated : 20 Sep, 2021
In this article we will look into the process of loading a PostgreSQL database into the PostgreSQL database server. 
Before moving forward we just need to make sure of two things: 

PostgreSQL database server is installed on your system. 
A sample database. 
For the purpose of this article, we will be using a sample database which is DVD rental database. 
You can download the sample dvdrental database from here.  

The Sample Database:
So, the DVD rental database that we will be using ahead in the article represents a DVD rental store. The objects in the database includes: 

15 tables 
1 trigger 
8 functions 
1 domain 
7 views 
13 sequences 
ER Model of the sample Database:  



Tables in the Sample Database: 
There are 15 tables in our sample database which are listed below: 

actor – stores actors data including first name and last name. 
film – stores films data such as title, release year, length, rating, etc 
film_actor – stores the relationships between films and actors. 
category – stores film’s categories data. 
film_category– stores the relationships between films and categories. 
store – contains the store data including manager staff and address. 
inventory – stores inventory data. 
rental – stores rental data. 
payment – stores customer’s payments. 
staff – stores staff data. 
customer – stores customers data. 
address – stores address data for staff and customers 
city – stores the city names. 
country – stores the country names. 
So now we know everything about our sample DVD rental database, let us move on to loading the same database to the PostgreSQL database server. The steps to which are listed below:  

Step 1: Create a DVD rental Database, by opening the SQL shell. Once you open up the shell, you will need to add the necessary credentials for your database, which would somewhat look like below: 
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Password for user postgres:
Now using the CREATE DATABASE statement create a new database as follows: 

CREATE DATABASE dvdrental;
Step 2: Load the database file by creating a folder at your desired location(say, c:\users\sample_database\dvdrental.tar). Now open up command prompt and Navigate to the bin folder of the PostgreSQL installation folder as below: 


Use the pg_restore tool to load data into the dvdrental database that we had just created as using the command: 

pg_restore -U postgres -d dvdrental C:\users\sample_datbase\dvdrental.tar
It would somewhat look like below: 



Now enter your database user Password and your sample database will be loaded.  

Verify Database Load:
Now if you need to verify if the sample database is loaded, use the below command to get into the database in SQL shell:  

\c
Now to list all the tables in the database, use the below command: 

\dt
The result should look like below:  


PostgreSQL – ALTER DATABASE
Last Updated : 22 Feb, 2021
PostgreSQL has an ALTER DATABASE statement that is used for modifying an existing database. The features of a database, once created can be changed using the ALTER DATABASE statement. 

Syntax: ALTER DATABASE target_database action;
As the above syntax depicts, the database where modifications are to be done are mentioned after the ALTER DATABASE statement followed by the action that is to be performed on the database. 

Below is the list of actions that PostgreSQL allows: 

Rename a database: 
The ALTER DATABASE RENAME TO statement is used to rename a database as follows: 

ALTER DATABASE target_database RENAME TO new_database;
Change owner of the database: 
The ALTER DATABASE OWNER TO statement is used to change the owner of a database as follows: 

ALTER DATABASE target_database OWNER TO new_owner;
It is important to note that only the superuser or the owner of the database can perform this action. 

Change tablespace of the database: 
The ALTER DATABASE SET TABLESPACE statement is used to change the default tablespace of a database as follows: 

ALTER DATABASE target_database SET TABLESPACE new_tablespace;
The statement moves tables and indexes from the legacy tablespace to the new one.

Change session defaults for run-time configuration variables: 
By, default, PostgreSQL loads the configuration variable from the postgresql.conf file. This file contains information regarding the database roles and their respective authentication hashing types. These settings or information can be edited using the ALTER DATABASE SET statement as shown below:

ALTER DATABASE target_database SET config_data = value;
It is important to note that only the superuser or the database owner can change the default session variables for a database. 
Now, let’s look into an example of the implementation of the ALTER DATABASE statement. 

Example: 
Let’s log in as the Postgres user and create a sample database (say, my_test_db) using the below command:

CREATE DATABASE my_test_db; 


Now use the below command to rename the database from “my_test_db” to “my_renamed_db“: 

ALTER DATABASE my_test_db RENAME TO my_renamed_db;


Now execute the following statement to change the owner of the “my_renamed_db” database from “postgres” to “geeks”, with the assumption that the “geeks” role already exists. 

ALTER DATABASE my_renamed_db OWNER TO geeks;


If the “geeks” role does not exist, create it by using the following statement: 

CREATE ROLE geeks
 VALID UNTIL 'infinity';


Now change the default tablespace of the my_renamed_db from pg_default to geeks_default, with the assumption that the geeks_defaulttablespace already exists. 

ALTER DATABASE my_renamed_db
SET TABLESPACE geeks_default;


If the geeks_defaulttablespace does not exist, you can create it by using the following statement: 

CREATE TABLESPACE geeks_default
 OWNER geeks
 LOCATION E'C:\\pgdata\\geeks';


Now set escape_string_warning configuration variable to off using the below commands: 

ALTER DATABASE my_renamed_db SET escape_string_warning TO off; 




PostgreSQL – Rename Database
Last Updated : 22 Feb, 2021
In PostgreSQL, the ALTER DATABASE RENAME TO statement is used to rename a database. The below steps need to be followed while renaming a database: 

Disconnect from the database that you want to rename by connecting to a different database.
Terminate all connections, connected to the database to be renamed.
Now you can use the ALTER DATABASE statement to rename the database. 
Now let’s look into the below example to see how to rename a database in PostgreSQL. 

Example: 

Step 1: Create a database named “test_db” using the below commands:
CREATE DATABASE test_db;


Step 2: Now to rename the “test_db” database, disconnect from that database using the below command and connect to the Postgres database: 
test_db=# \connect postgres;


Step 3: Use the below query to check all active connections to the “test_db” database: 
SELECT
    *
FROM
    pg_stat_activity
WHERE
    datname = 'test_db';


Step 4: Use the below query to terminate all the connections to the test_db database: 
SELECT
    pg_terminate_backend (pid)
FROM
    pg_stat_activity
WHERE
    datname = 'test_db';


Step 5: Now use the ALTER DATABASE RENAME TO statement to rename the database as “new_test_db”(say) as follows: 
ALTER DATABASE test_db RENAME TO new_test_db; 



PostgreSQL – Show Databases
Last Updated : 28 Aug, 2020
In PostgreSQL,  there are couple of ways to list all the databases present on the server. In this article, we will explore them.

Using the pSQL command:
To list all the database present in the current database server use one of the following commands:

Syntax: \l or \l+
Example:

First log into the PostgreSQL server using the pSQL shell:



Now use the below command to list all databases using a superuser such as postgres:

\l
This will lead to the following:



Alternatively one can use the below command:

\l+
Output:



Using SELECT statement:
The SELECT statement can also be used to list all the database present on the server:

Syntax: SELECT datname FROM pg_database;
Example:

Below is the simple use of the SELECT statement to list all database present on the server:

SELECT datname FROM pg_database;
Output:




PostgreSQL – Data Types
Last Updated : 07 Oct, 2022
In this article, we will look into the various data types available in PostgreSQL. The following data types are supported by PostgreSQL: 

Boolean
Character Types [ such as char, varchar, and text]
Numeric Types [ such as integer and floating-point number]
Temporal Types [ such as date, time, timestamp, and interval]
UUID [ for storing UUID (Universally Unique Identifiers) ]
Array [ for storing array strings, numbers, etc.]
JSON [ stores JSON data]
hstore [ stores key-value pair]
Special Types [ such as network address and geometric data]
Now let’s get an overview of the above-mentioned data types. 

Boolean:
In PostgreSQL, the “bool” or”boolean” keyword is used to initialize a Boolean data type. These data types can hold true, false, and null values. A boolean data type is stored in the database according to the following:

1, yes, y, t, true values are converted to true
0, no, false, f values are converted to false
When queried for these boolean data types are converted and returned according to the following:

t to true
f to false
space to null
Characters :
PostgreSQL has three character data types namely, CHAR(n), VARCHAR(n), and TEXT. 

CHAR(n) is used for data(string) with a fixed-length of characters with padded spaces.  In case the length of the string is smaller than the value of “n”, then the rest of the remaining spaces are automatically padded. Similarly for a string with a length greater than the value of “n”,  PostgreSQL throws an error.
VARCHAR(n) is the variable-length character string.Similar to CHAR(n), it can store “n” length data. But unlike CHAR(n) no padding is done in case the data length is smaller than the value of “n”.
TEXT is the variable-length character string. It can store data with unlimited length.
Numeric:
PostgreSQL has 2 types of numbers namely, integers and floating-point numbers. 

1. Integer: 

Small integer (SMALLINT) has a range -32, 768 to 32, 767 and has a size of 2-byte.
Integer (INT) has a range -2, 147, 483, 648 to 2, 147, 483, 647 and has a size of 4-byte.
Serial (SERIAL) works similar to the integers except these are automatically generated in the columns by PostgreSQL.
2. Floating-point number: 

float(n) is used for floating-point numbers with n precision and can have a maximum of 8-bytes.
float8 or real is used to represent 4-byte floating-point numbers.
A real number N(d,p) meaning with d number of digits and p number of decimal points after, are part of numeric or numeric(d, p). These are generally very precise.
Temporal data type:
This data type is used to store date-time data. PostgreSQL has 5 temporal data type: 

DATE is used to store the dates only.
TIME is used to stores the time of day values.
TIMESTAMP is used to stores both date and time values.
TIMESTAMPTZ is used to store a timezone-aware timestamp data type.
INTERVAL is used to store periods of time.
Arrays:
In PostgreSQL, an array column can be used to store an array of strings or an array of integers etc. It can be handy when storing data likes storing days of months, a year, or even a week, etc. 

JSON:
PostgreSQL supports 2 types of JSON types namely JSON and JSONB(Binary JSON). The JSON data type is used to store plain JSON data that get parsed every time it’s called by a query. Whereas the JSONB data type is used to store JSON data in a binary format. It is one hand makes querying data faster whereas slows down the data insertion process as it supports indexing of table data.

UUID:
The UUID data type allows you to store Universal Unique Identifiers defined by RFC 4122. The UUID values guarantee a better uniqueness than SERIAL and can be used to hide sensitive data exposed to the public such as values of id in URL. 

The UUID stands for Unique Universal Identifiers. These are used to give a unique ID to a data that is unique throughout the database. The UUID data type are used to store UUID of the data defined by RFC 4122. These are generally used to protect sensitive data like credit card informations and is better compared to SERIAL data type in the context of uniqueness.

Special data types:
In addition to the primitive data types, PostgreSQL also supports some special data types that are related to network or geometric. These special data types are listed below: 

box: It is used to store rectangular box.
point: It is used to store geometric pair of numbers.
lseg: It is used to store line segment.
point: It is used to store geometric pair of numbers.
polygon:It is used to store closed geometric.
inet: It is used to store an IP4 address.
macaddr: It is used to store MAC address.


PostgreSQL – Boolean Data Type
Last Updated : 08 Jun, 2020
In this article, we will look into the PostgreSQL Boolean data type and it’s implementation while designing a database table. PostgreSQL boolean data type has 3 states namely TRUE< FALSE and NULL. It uses single byte for storing boolean value and can be abbreviated as BOOL.
The below table depicts all valid literal values for TRUE and FALSE in PostgreSQL:

True	False
true	false
‘t’	‘f’
‘true’	‘false’
‘y’	‘n’
‘yes’	‘no’
1	0
Now, let’s look into a few examples. For the same reason let’s create a sample database(say, bookstore) using the below command:

CREATE DATABASE bookstore;
Add a table (say, book_availability) to the bookstore database using the below command:

CREATE TABLE book_availability (
    book_id INT NOT NULL PRIMARY KEY,
    available BOOLEAN NOT NULL
);
Now insert some data to the book_availability table using the below command:

INSERT INTO book_availability (book_id, available)
VALUES
    (100, TRUE),
    (200, FALSE),
    (300, 't'),
    (400, '1'),
    (500, 'y'),
    (600, 'yes'),
    (700, 'no'),
    (800, '0');
Now that our database is ready let’s look into some examples.

Example 1:
In this example we will query for all the available books in the bookstore.

SELECT
    *
FROM
    book_availability
WHERE
    available = 'yes';
Output:

Example 2:
In this example we will query for all books that are NOT available in the bookstore.

SELECT
    *
FROM
    book_availability
WHERE
    available = 'no';
Output:


Example 3:
In this example we will make the use of NOT operator to check for books that are not available in the bookstore.

SELECT
    *
FROM
    book_availability
WHERE
    NOT available;


PostgreSQL – CHAR Data Type
Last Updated : 28 Aug, 2020
PostgreSQL supports a character data type called CHAR. This data type is used to store character of limited length. It is represented as char(n) in PostgreSQL, where n represents the limit of the length of the characters. If n is not specified it defaults to char(1) or character(1). Any attempt to store a longer string in the column that defined with char(n) results in PostgreSQL issuing an error. However, one exception is that if the excess characters are all spaces, PostgreSQL will truncate the spaces to the maximum length and store the string.

Syntax: variable_name CHAR(n)
Example :
Let’s create a new table(say, char_test) for the demonstration using the below commands:

CREATE TABLE char_test (
    id serial PRIMARY KEY,
    x CHAR (1),
        y CHAR(10)
);
Now let’s insert a new row into the char_test table using the below command:

INSERT INTO char_test (x, y)
VALUES
    (
        'Geeks',
        'This is a test for char'
        
    );
At this stage PostgreSQL will raise an error as the data type of the x column is char(1) and we tried to insert a string with three characters into this column as shown below:

ERROR:  value too long for type character(1)


So, now let’s fix it.

INSERT INTO char_test (x, y)
VALUES
    (
        'G',
        'This is a test for char'
        
    );
Now, we will get the same error for the y column as the number of characters entered is greater than 10 as shown below:

ERROR:  value too long for type character(10)

Let’s fix it too.

INSERT INTO char_test (x, y)
VALUES
    (
        'G',
        'hello Geek'
        
    );
Now that we have managed to successfully assign the values to the character data type, check it by running the below command:

SELECT * FROM char_test;
Output:



PostgreSQL – VARCHAR Data Type
Last Updated : 28 Aug, 2020
PostgreSQL supports a character data type called VARCHAR. This data type is used to store characters of limited length. It is represented as varchar(n) in PostgreSQL, where n represents the limit of the length of the characters. If n is not specified it defaults to varchar which has unlimited length. Any attempt to store a longer string in the column that defined with varchar(n) results in PostgreSQL issuing an error. However, one exception is that if the excess characters are all spaces, PostgreSQL will truncate the spaces to the maximum length and store the string. The only advantage of specifying the length specifier for the varchar data type is that PostgreSQL will check and issue an error if you try to insert a longer string into the varchar(n) column.

Syntax: variable_name VARCHAR(n)
Example :
Let’s create a new table(say, char_test) for the demonstration using the below commands:

CREATE TABLE varchar_test (
    id serial PRIMARY KEY,
    x VARCHAR (1),
        y VARCHAR(10)
);
Now let’s insert a new row into the char_test table using the below command:

INSERT INTO varchar_test (x, y)
VALUES
    (
        'Geeks',
        'This is a test for char'
        
    );
At this stage PostgreSQL will raise an error as the data type of the x column is char(1) and we tried to insert a string with three characters into this column as shown below:

ERROR:  value too long for type character varying(1)


So, now let’s fix it.

INSERT INTO varchar_test (x, y)
VALUES
    (
        'G',
        'This is a test for char'
        
    );
Now, we will get the same error for the y column as the number of characters entered is greater than 10 as shown below:

ERROR:  value too long for type character varying(10)

Let’s fix it too.

INSERT INTO varchar_test (x, y)
VALUES
    (
        'G',
        'hello Geek'
        
    );
Now that we have managed to successfully assign the values to the character data type, check it by running the below command:

SELECT * FROM varchar_test;
Output:



PostgreSQL – NUMERIC Data Type
Last Updated : 28 Aug, 2020
PostgreSQL supports the NUMERIC type for storing numbers with a very large number of digits. Generally NUMERIC type are used for the monetary or amounts storage where precision is required.

Syntax: NUMERIC(precision, scale)

Where,
     Precision: Total number of digits.
     Scale: Number of digits in terms of a fraction.
The NUMERIC value can have up to 131, 072 digits before the decimal point of 16, 383 digits after the decimal point.
It is allowed to have a zero or positive scale, as the syntax defined below for a NUMERIC column with the scale of zero:

Syntax: NUMERIC(precision)
If you eliminate both precision and scale, there is no limit to the precision or the scale and the syntax will be as below:

Syntax: NUMERIC
The NUMERIC and DECIMAL types are equivalent in PostgreSQL and upto the SQL standard.
It is recommended to not use the NUMERIC type, if precision is not required as the calculation on NUMERIC values is slower than integers, floats, and double precision.

Example 1:
Create a new table named products with the below commands:

CREATE TABLE IF NOT EXISTS products (
    id serial PRIMARY KEY,
    name VARCHAR NOT NULL,
    price NUMERIC (5, 2)
);
Now insert some products with the prices whose scales exceed the scale declared in the price column:

INSERT INTO products (name, price)
VALUES
    ('Phone', 100.2157), 
    ('Tablet', 300.2149);
As the scale of the price column is 2, PostgreSQL rounds the value 100.2157 up to 100.22 and rounds the value 300.2149 down to 300.21
The below query returns all rows of the products table:

SELECT
    *
FROM
    products;
Output:


Example 2:
Create a new table named products with the below commands:

CREATE TABLE IF NOT EXISTS employee_salary(
    id serial PRIMARY KEY,
    name VARCHAR NOT NULL,
    salary NUMERIC (10, 2)
);
Now insert some products with the prices whose scales exceed the scale declared in the price column:

INSERT INTO employee_salary(name, salary)
VALUES
    ('Raju', 57896.2277),
    ('Abhishek', 84561.3657),
    ('Nikhil', 55100.11957), 
    ('Ravi', 49300.21425849);
As the scale of the price column is 2, PostgreSQL rounds the value 57896.2277 up to 57896.22 for Raju, the value 84561.3657 down to 84561.36 for Abhishek, the value 55100.11957 to 55100.12 for Nikhil and the value 49300.21425849 to 49300.21 for Ravi.
The below query returns all rows of the products table:

SELECT
    *
FROM
    employee_salary;
Output:



PostgreSQL – Date Data Type
Last Updated : 28 Aug, 2020
PostgreSQL supports a DATE data type to store date values. It takes 4 bytes of storage and ranges from 4713 BC to 5874897 AD. PostgreSQL uses the yyyy-mm-dd format for storing and inserting date values. If you create a table that has a DATE column and you want to use the current date as the default value for the column, you can use the CURRENT_DATE after the DEFAULT keyword.

Syntax: variable_name DATE
Let’s look into some examples for better understanding.
Example 1:
In this example we will create a new employee table that consists of employee_id, first_name, last_name, birth_date, and hire_date columns, and the data types of the birth_date and hire_date columns are DATE.

CREATE TABLE employees (
    employee_id serial PRIMARY KEY,
    first_name VARCHAR (255),
    last_name VARCHAR (355),
    birth_date DATE NOT NULL,
    hire_date DATE NOT NULL
);
Now insert some data to the tables using the below command:

INSERT INTO employees (first_name, last_name, birth_date, hire_date)
VALUES ('Raju', 'Kumar', '1996-12-02', '2020-01-01'),
       ('Nikhil', 'Aggarwal', '1997-08-24', '2019-01-01'),
       ('Anshul', 'Aggarwal', '1994-05-11', '2017-01-01');
Now that the data has been inserted let’s verify them by using the below command:

SELECT * FROM employees;
Output:


Example 2:
In the same table that we created in example 1, we will now query the age of the employees from the already present data using the command below:

SELECT
    employee_id,
    first_name,
    last_name,
    AGE(birth_date)
FROM
    employees;
Output:


Note: In the above example notice the use of AGE() function. To calculate age at the current date in years, months, and days, you use the AGE() function.


PostgreSQL – TIME Data Type
Last Updated : 22 Feb, 2021
PostgreSQL provides user with TIME data type that is used to handle time values. It requires 8 bytes of storage and can have precision up to 6 digits. It can range from 00:00:00 to 24:00:00.

Syntax: column_name TIME(precision);
The common TIME formats are illustrated below:

HH:MM   
HH:MM:SS
HHMMSS
If precision is required the following format needs to be followed:

MM:SS.pppppp    
HH:MM:SS.pppppp
HHMMSS.pppppp
For instance below are sample TIME value formats:

Without precision:
01:02
01:02:03
010203

With precision:
04:59.999999
04:05:06.777777
040506.777777
Now let’s look into some examples for better understanding.
Example:
In this example we will create a table that holds team schedules details of a company. First, create a new table named team_schedule by using the following commands:

CREATE TABLE team_schedule (
    id serial PRIMARY KEY,
    team_name VARCHAR NOT NULL,
    clock_in_time TIME NOT NULL,
    clock_out_time TIME NOT NULL
);
Now, insert some rows into the team_schedule table:

INSERT INTO team_schedule(team_name, clock_in_time, clock_out_time)
VALUES('Marketing', '09:00:00', '18:00:00'),
      ('Sales', '10:00:00', '19:00:00'),
      ('Mentors', '09:00:00', '18:00:00'),
      ('Software', '11:00:00', '20:00:00'),
      ('Content', '10:00:00', '19:00:00');
Finally, we query from the shifts table using the below command:

SELECT
    *
FROM
    team_schedule;
Output:



PostgreSQL – JSON Data Type
Last Updated : 22 Feb, 2021
JSON stands for JavaScript Object Notation. It is used to store data in the form of key-value pairs and is generally used for communicating between the server and the client. Contrary to other formats, JSON is human-readable text.
PostgreSQL has support for native JSON data type since version 9.2. It offers numerous functions and operators for handling JSON data.

Syntax: variable_name json;
Now let’s look into a few examples for demonstration.

Example 1:
First, create a table (say, orders) using the below command:

CREATE TABLE orders (
    ID serial NOT NULL PRIMARY KEY,
    info json NOT NULL
);
Now insert some data into the orders table as follows:

INSERT INTO orders (info)
VALUES
    (
        '{ "customer": "Raju Kumar", "items": {"product": "coffee", "qty": 6}}'
    );
Now we will query for the orders information using the below command:

SELECT
    info
FROM
    orders;
Output:


Example 2:
In the above example we created an orders table and added single JSON data into it. In this example we will be looking onto inserting multiple JSON data in the same table using the command below:

INSERT INTO orders (info)
VALUES
    (
        '{ "customer": "Nikhil Aggarwal", "items": {"product": "Diaper", "qty": 24}}'
    ),
    (
        '{ "customer": "Anshul Aggarwal", "items": {"product": "Tampons", "qty": 1}}'
    ),
    (
        '{ "customer": "Naveen Arora", "items": {"product": "Toy Train", "qty": 2}}'
    );
Now we will query for the orders information using the below command:

SELECT
    info
FROM
    orders;
Output:




PostgreSQL – CREATE DOMAIN
Last Updated : 06 Sep, 2021
PostgreSQL supports the creation of user-defined data types using the following statements: 
 

CREATE DOMAIN:It creates a user-defined data type that can have optional constraints. 
 
CREATE TYPE:It is often applied to create a composite type (data type that are mixes of two or more data types) using stored procedures. 
 
CREATE DOMAIN: 
In PostgreSQL, a domain is a data type that has optional constraints. It is a must to have a unique name and a well-defined schema range. 

Example: 
First, we create a table (say, marksheet) using the below command: 
 

CREATE TABLE marksheet (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR NOT NULL,
    last_name VARCHAR NOT NULL,
    email VARCHAR NOT NULL,
    marks_obtained INT NOT NULL, 
    CHECK (
        first_name !~ '\s'
        AND last_name !~ '\s'
    )
);
The first_name and last_name fields are not null and must not contain any spaces. For the simplicity of the teachers we can make a student_detail domain using the below command: 
 

CREATE DOMAIN student_detail AS 
    VARCHAR NOT NULL CHECK (value !~ '\s');
Now we can use the student_detail as the data type of the first_name and last_name fields as follows: 
 

CREATE TABLE marksheet (
    student_id serial PRIMARY KEY,
    first_name student_detail,
    last_name student_detail,
    marks_obtained INT NOT NULL,
    email VARCHAR NOT NULL
);
Now insert some data to the table using the below command: 
 

INSERT INTO marksheet (first_name, last_name,marks_obtained, email)
VALUES
    (
        'Raju K',
        'Singh',
     95,
        'rajukumar@gmail.com'
    );
At this stage PostgreSQL will raise the following error: 
 

ERROR:  value for domain marksheet violates check constraint "marksheet_check"
 



So, the behaviour is as we expected. To modify or delete a domain, one can make use of the ALTER DOMAIN or DROP DOMAIN respectively. 
To get all domains in the current database use the below command: 
 

\dD
Output: 
 



 


Querying tables 

PostgreSQL – SELECT
Last Updated : 28 Aug, 2020
In this article we will be looking into the basic use of PostgreSQL SELECT statement to query data from the database table. For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link.

The SELECT statement is as complex and flexible as it can get for a query statement. It can be used with various clauses which increases it’s flexibility and use cases to query data from a table.
The various clauses that can be used with the SELECT statement are listed below:

DISTINCT operator: It is used to select distinct rows from a table.
ORDER BY clause: It is used to sort table rows.
WHERE clause: It is used to filter rows from a table. >LIMIT clause: It is used to select a subset of rows from the table.
FETCH clause: It is also used to select subset of rows from the table.
GROUP BY clause: It is used to group different rows into a single group.
HAVING clause: It is used to filter rows from a table with specified attributes or features.
FROM clause: It is used to specify a column in a table.
joins: It is used to join two or more tables together using joins such as INNER JOIN, LEFT JOIN, FULL OUTER JOIN, CROSS JOIN clauses.
Set operators: These operators such as UNION, INTERSECT, and EXCEPT are used to manipulate the different sets of data.
For the sake of simplicity we will be looking into the use of SELECT statement with FROM clause in our sample DVD rental database.

The syntax for using the SELECT statement is as follows:

Syntax: SELECT select_list FROM table_name;

Now, let’s evaluate the SELECT statement in more detail,

Firstly, we need to specify a particular column or a list of columns from where the data is to be retrieved. Commas are used to separate multiple columns, if a list of column is selected as below:
SELECT select_list1, select_list2, select_list3 FROM table_name;
For selecting all columns from the database, use asterisk(‘*’) as below:

SELECT * FROM table_name;
Secondly, we need to specify the name of the table from which data is to be retrieved, after the FROM keyword.
Now let us look into a few examples of using SELECT statement in our sample database:
Example 1:
Using SELECT statement to query data from one column

SELECT first_name FROM customer;
Output:



Example 2:
Using SELECT statement to query data from multiple columns

SELECT first_name, email FROM customer;
Output:


Example 3:
Using SELECT statement to query data in all columns of a table

SELECT * FROM customer;
Output:


Example 4:
Using SELECT statement with expressions

SELECT first_name || ' ' || last_name AS full_name, email FROM customer;
Output:


PostgreSQL – ORDER BY clause
Last Updated : 19 Sep, 2023
The PostgreSQL ORDER BY clause is used to sort the result query set returned by the SELECT statement. As the query set returned by the SELECT statement has no specific order, one can use the ORDER BY clause in the SELECT statement to sort the results in the desired manner.

Syntax:
SELECT
column_1,
column_2
FROM
table_name
ORDER BY
column_1 [ASC | DESC],
column_2 [ASC | DESC];

Let’s analyze the above syntax:

Firstly we specify the column or the expression that we want to be sorted. If multiple columns or expressions are to be used in the SELECT statement, we separate them with commas.
Secondly, The ASC expression is used to sort the result set in ascending order, and DESC expression is used to sort the result set in descending order. By default the ORDER BY clause uses ASC.
For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples.

Example 1:
Using PostgreSQL ORDER BY clause to sort rows by one column in the “customer” table of the sample database

SELECT
    first_name,
    last_name
FROM
    customer
ORDER BY
    first_name DESC;
Output:


Example 2:
Using PostgreSQL ORDER BY clause to sort rows by multiple columns in the “customer” table. Here we will be sorting the customers by the first name in the ascending order first, and then sort the sorted result set by the last name in descending order.

SELECT
    first_name,
    last_name
FROM
    customer
ORDER BY
    first_name ASC,
    last_name DESC;
Output:


The output of the code gets more clear if the first name of the customer is the same as shown below:


Example 3:
Using PostgreSQL ORDER BY clause to sort rows by expressions. In the below example we will be using the ORDER BY clause with the LENGTH() function to sort the rows by the lengths of the first names of customers. The LENGTH() function accepts a string and returns its length.

SELECT 
    first_name,
    LENGTH(first_name) len
FROM
    customer
ORDER BY 
    LENGTH(first_name) DESC;
Output:


PostgreSQL – WHERE clause
Last Updated : 28 Aug, 2020
The PostgreSQL WHERE clause is used to filter results returned by the SELECT statement.

Syntax: SELECT select_list FROM table_name WHERE condition;

Let’s analyze the above syntax:

The WHERE clause appears right after the FROM clause of the SELECT statement
The condition evaluates to true, false, or unknown. It can either be a Boolean expression or a combination of Boolean expressions where AND and OR operators are used.
The WHERE clause can also be used with the UPDATE and DELETE statement to specify rows to be updated or deleted.
Below table provides us with the list of comparison operators valid in PostgreSQL:

Operator	Description
=	Equal
>	Greater than
<	Less than
>=	Greater than or equal to
<=	Less than or equal to
<> or =!	Not equal
AND	Logical AND operator
OR	Logical OR operator
For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link.
Now, let’s look into some examples.

Example 1:
Using WHERE clause with the equal (=) operator. Here we will be using the equal operator in the “customer” table of our sample database.

SELECT
    last_name,
    first_name
FROM
    customer
WHERE
    first_name = 'Kelly';
Output:


Example 2:
Using the WHERE clause with the AND operator. Here we will be using the AND operator in the “customer” table of our sample database.

SELECT
    last_name,
    first_name
FROM
    customer
WHERE
    first_name = 'Kelly'
AND last_name = 'Knott';
Output:


Example 3:
Using the WHERE clause with the OR operator. Here we will be using the OR operator in the “customer” table of our sample database.

SELECT
    first_name,
    last_name
FROM
    customer
WHERE
    last_name = 'Cooper' OR 
    first_name = 'Jo';
Output:



Example 4:
Using the WHERE clause with the IN operator. The IN operator is used for string matching. Here we will be using the IN operator in the “customer” table of our sample database.

SELECT
    first_name,
    last_name
FROM
    customer
WHERE 
    first_name IN ('Kelly', 'Jo', ' Alexander');
Output:


Example 5:
Using the WHERE clause with the LIKE operator. The LIKE operator is used to find string matching a particular pattern. Here we will be using the LIKE operator in the “customer” table of our sample database.

SELECT
    first_name,
    last_name
FROM
    customer
WHERE 
    first_name LIKE 'Kath%';
Output:


Example 6:
Using the WHERE clause with the BETWEEN operator. The BETWEEN operator return if a value is in the mentioned range. Here we will be using the BETWEEN operator in the “customer” table of our sample database.

SELECT
    first_name,
    LENGTH(first_name) name_length
FROM
    customer
WHERE 
    first_name LIKE 'K%' AND
    LENGTH(first_name) BETWEEN 3 AND 7
ORDER BY
    name_length;
Output:


Example 7:
Using the WHERE clause with the not equal operator (<>). Here we will be using the <> operator in the “customer” table of our sample database.

SELECT 
    first_name, 
    last_name
FROM 
    customer 
WHERE 
    first_name LIKE 'Bra%' AND 
    last_name <> 'Motley';
Output:




PostgreSQL – FETCH clause
Last Updated : 28 Aug, 2020
The PostgreSQL FETCH clause has a functionality similar to the PostgreSQL LIMIT clause. It is used to retrieve a portion of rows returned by a query. As the LIMIT clause is not a standard SQL-command, PostgreSQL provides a standard way of fetching a subset of results from a query.

Syntax:
OFFSET start { ROW | ROWS }
FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY

Let’s analyze the above syntax:

ROW and FIRST are synonymous with ROWS and NEXT respectively.
The start is an integer value that is either zero or positive. By default, it is zero.
The row_count is either one or higher. By default, it is one.
As the order of rows stored in the table is unpredictable, one should always use the FETCH clause with the ORDER BY clause to make the result set consistent.
For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link.

Now, let’s look into a few examples.

Example 1:
Here we will query the first 10 rows of the film sorted by “title” from the film table of our sample database.

SELECT
    film_id,
    title
FROM
    film
ORDER BY
    title 
FETCH FIRST 10 ROW ONLY;
Output:


Example 2:
Here we will query the first 10 rows of the film after the first five films, sorted by “title” from the film table of our sample database.

SELECT
    film_id,
    title
FROM
    film
ORDER BY
    title 
OFFSET 5 ROWS 
FETCH FIRST 10 ROW ONLY;
Output:



PostgreSQL – IN operator
Last Updated : 28 Aug, 2020
The PostgreSQL IN operator is used with the WHERE clause to check against a list of values.

The syntax for using IN operator with the WHERE clause to check against a list of values which returns a boolean value depending upon the match is as below:

Syntax: value IN (value1, value2, …)

The syntax for using IN operator to return the matching values in contrast with the SELECT statement is as below:

Syntax: value IN (SELECT value FROM tbl_name);

For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link.

Now, let’s look into a few examples.
Example 1:
Here we will make a query for the rental information of customer id 10 and 12, using the WHERE clause and IN operator.

SELECT
 customer_id,
    rental_id,
    return_date
FROM
    rental
WHERE
    customer_id IN (10, 12)
ORDER BY
    return_date DESC;
Output:


Example 2:
Here we will make a query for a list of customer id of customers that has rental’s return date on 2005-05-27.

SELECT
    first_name,
    last_name
FROM
    customer
WHERE
    customer_id IN (
        SELECT
            customer_id
        FROM
            rental
        WHERE
            CAST (return_date AS DATE) = '2005-05-27'
    );
Output:



PostgreSQL – HAVING clause
Last Updated : 10 Oct, 2022
PostgreSQL has a HAVING clause that is used to eliminate groups of rows that do not meet specific criteria or conditions. Ii generally used in conjunction with the GROUP BY clause to filter group rows that do not satisfy a specified condition.

Syntax:
SELECT
    column_1,
    aggregate_function (column_2)
FROM
    tbl_name
GROUP BY
    column_1
HAVING
    condition;
Now let’s analyze the above syntax:

In the above syntax the aggregate_function represents functions like SUM(), COUNT() etc.
The HAVING clause provides the condition for group rows created by the GROUP BY clause.
The WHERE clause sets the condition for each row before the GROUP BY clause is applied.
For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples. Example 1: Here we will query to selects the only customer who has been spending more than 200 USD using the HAVING clause in the “payment” table of our sample database.

SELECT
    customer_id,
    SUM (amount)
FROM
    payment
GROUP BY
    customer_id
HAVING
    SUM (amount) > 200;
Output:Example 2: Here we will query to select the stores that has more than 200 customers using the HAVING clause in the “customer” table of our sample database.

SELECT
    store_id,
    COUNT (customer_id)
FROM
    customer
GROUP BY
    store_id
HAVING
    COUNT (customer_id) > 200;
Output:


PostgreSQL – GROUP BY clause
Last Updated : 28 Aug, 2020
The PostgreSQL GROUP BY clause is used to divide rows returned by SELECT statement into different groups. The speciality of GROUP BY clause is that one can use Functions like SUM() to calculate the sum of items or COUNT() to get the total number of items in the groups.

Syntax:
SELECT 
   column_1, 
   column_2,
   computing_function(column_3)
FROM 
   table_name
GROUP BY 
   column_1,
   column_2;
It is important to note that The GROUP BY clause must exactly appear after the FROM or WHERE clause.

For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples.

Example 1:
Here we will query for data from the payment table and group the result by customer id from the “payment” table of our sample database.

SELECT
   customer_id
FROM
   payment
GROUP BY
   customer_id;
Output:


Example 2:
Here we will query to get the amount that each customer has paid till date and use an aggregate function (ie SUM()), to do so and group them by customer_id from the “payment” table of the sample database.

SELECT
    customer_id,
    SUM (amount)
FROM
    payment
GROUP BY
    customer_id;
Output:


Example 3:
here we will make a query to count the number of payment transactions that each staff has been processing, you group the rows in the payment table based on staff_id and use the COUNT() function to get the number of transactions.

SELECT
    staff_id,
    COUNT (payment_id)
FROM
    payment
GROUP BY
    staff_id;
Output:


PostgreSQL – LIKE operator
Last Updated : 28 Aug, 2020
The PostgreSQL LIKE operator is used query data using pattern matching techniques. Its result include strings that are case-sensitive and follow the mentioned pattern.
It is important to know that PostgreSQL provides with 2 special wildcard characters for the purpose of patterns matching as below:

Percent ( %) for matching any sequence of characters.
Underscore ( _) for matching any single character.
Syntax: string LIKE pattern;
For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples.

Now, let’s look into a few examples.

Example 1:
Here we will make a query to find the customer in the “customer” table by looking at the “first_name” column to see if there is any value that begins with “K” using the LIKE operator in our sample database.

SELECT
    first_name,
        last_name
FROM
    customer
WHERE
    first_name LIKE 'K%';
Output:


Notice few things in the above example, the WHERE clause contains a special expression: the first_name, the LIKE operator, and a string that contains a percent (%) character, which is referred to as a pattern.

Example 2:
Here we will query for customers whose first name begins with any single character, is followed by the literal string “her”, and ends with any number of characters using the LIKE operator in our sample database.

SELECT
    first_name,
    last_name
FROM
    customer
WHERE
    first_name LIKE '_her%';
Output:


table operations 

PostgreSQL – CREATE TABLE
Last Updated : 28 Aug, 2020
In PostgreSQL, the CREATE TABLE clause as the name suggests is used to create new tables.

Syntax:
CREATE TABLE table_name (
    column_name TYPE column_constraint,
    table_constraint table_constraint
) INHERITS existing_table_name;
Let’s analyze the syntax above:

First, you define the name of the new table after the CREATE TABLE clause. The TEMPORARY keyword is for creating a temporary table.
Next, one has to list the column name, its data type, and column constraint. A table may have multiple columns separated by a comma (, ). The column constraint defines rules for the column e.g., NOT NULL.
Then, after the column list, one has to define a table-level constraint that defines rules for the data in the table.
After that, one sets an existing table from which the new table inherits. It means the new table contains all columns of the existing table and the columns defined in the CREATE TABLE statement. This is a PostgreSQL’s extension to SQL.
Now let’s jump into an example.

Example:
In this example we will create a new table named account that has the following columns with the corresponding constraints:

user_id – primary key
username – unique and not null
password – not null
email – unique and not null
created_on – not null
last_login – null
The following statement creates the account table:

CREATE TABLE account(
    user_id serial PRIMARY KEY,
    username VARCHAR (50) UNIQUE NOT NULL,
    password VARCHAR (50) NOT NULL,
    email VARCHAR (355) UNIQUE NOT NULL,
    created_on TIMESTAMP NOT NULL,
    last_login TIMESTAMP
);
The below statement creates the role table that consists of two columns: role_id and role_name:

CREATE TABLE role(
    role_id serial PRIMARY KEY,
    role_name VARCHAR (255) UNIQUE NOT NULL
);
The following statement creates the account_roles table that has three columns: user_id, role_id and grant_date:

CREATE TABLE account_role
(
  user_id integer NOT NULL,
  role_id integer NOT NULL,
  grant_date timestamp without time zone,
  PRIMARY KEY (user_id, role_id),
  CONSTRAINT account_role_role_id_fkey FOREIGN KEY (role_id)
      REFERENCES role (role_id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT account_role_user_id_fkey FOREIGN KEY (user_id)
      REFERENCES account (user_id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
);
Let’s examine the above statement in more detail.
The primary key of the account_role table consists of two columns: user_id and role_id, therefore we have to use the primary key table-level constraint to define the primary key as follows:

PRIMARY KEY (user_id, role_id)
Because the user_id column references to the user_id column in the account table, we need to define a foreign key constraint for the user_id column:

CONSTRAINT account_role_user_id_fkey FOREIGN KEY (user_id)
      REFERENCES account (user_id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
The role_idcolumn references to the role_id column in the role table, we also need to define a foreign key constraint for the role_id column:

CONSTRAINT account_role_role_id_fkey FOREIGN KEY (role_id)
      REFERENCES role (role_id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION, 
Output:



PostgreSQL – SELECT INTO
Last Updated : 28 Aug, 2020
In PostgreSQL, the SELECT INTO statement allows users to create a new table and inserts data returned by a query. The new table columns have names and data types linked with the output columns of the SELECT clause. Unlike the SELECT statement, the SELECT INTO statement does not return data to the client.

Syntax:
SELECT
    column_list 
INTO [ TEMPORARY | TEMP | UNLOGGED ] [ TABLE ] new_table_name
FROM
    table_name
WHERE
    condition;
In the process of creating a new table with the structure and data derived from a query result set, one has to specify the new table name in the INTO clause. The TEMP or TEMPORARY keyword is optional; it allows users to create a temporary table instead.
The WHERE clause allows users to specify the data from the original tables that should be inserted into the new table. Besides the WHERE clause, one can use other clauses in the SELECT statement for the SELECT INTO statement such as INNER JOIN, LEFT JOIN, GROUP BY, and HAVING.

Now let’s look into some examples.For examples we will be using the sample database (ie, dvdrental).

Example 1:
In this example, we will use the film table from the dvdrental database to create a new table named film_r that contains all films with the rating of R and has a 5-day rental duration using the below statement:

SELECT
    film_id,
    title,
    rental_rate
INTO TABLE film_r
FROM
    film
WHERE
    rating = 'R'
AND rental_duration = 5
ORDER BY
    title;
Now we can verify the created table using the below statement:

SELECT
    *
FROM
    film_r;
Output:


Example 2:
In this example, we create a temporary table named short_film that has all films whose lengths are under 60 minutes using the below statement:

SELECT
    film_id,
    title,
    length 
INTO TEMP TABLE short_film
FROM
    film
WHERE
    length < 60
ORDER BY
    title;
Now we verify the table short_film using the below statement:

SELECT
    *
FROM
    short_film;
Output:


Note: One cannot use the SELECT INTO statement in PL/pgSQL or ECPG because they interpret the INTO clause differently. In this case, you can use the CREATE TABLE AS statement which provides more functionality than the SELECT INTO statement.


PostgreSQL – CREATE SEQUENCE
Last Updated : 28 Aug, 2020
A sequence in PostgreSQL is a user-defined schema-bound object that yields a sequence of integers based on a specified specification. The CREATE SEQUENCE statement is used to create sequences in PostgreSQL.

Syntax:
CREATE SEQUENCE [ IF NOT EXISTS ] sequence_name
    [ AS { SMALLINT | INT | BIGINT } ]
    [ INCREMENT [ BY ] increment ]
    [ MINVALUE minvalue | NO MINVALUE ] 
    [ MAXVALUE maxvalue | NO MAXVALUE ]
    [ START [ WITH ] start ] 
    [ CACHE cache ] 
    [ [ NO ] CYCLE ]
    [ OWNED BY { table_name.column_name | NONE } ]
Now let’s analyze the above syntax:

First, set the name of the sequence after the CREATE SEQUENCE clause. The IF NOT EXISTS conditionally creates a new sequence only if it does not exist.
Second, specify the data type of the sequence. The valid data type are SMALLINT, INT, and BIGINT. The default data type is BIGINT if you skip it. It is used to determines the sequence’s minimum and maximum values.
The increment specifies which value to be added to the current sequence value to create new value. A positive number will make an ascending sequence while a negative number will form a descending sequence. The default increment value is 1.
Then, we define the minimum value and maximum value of the sequence. If you use NO MINVALUE or NO MAXVALUE, the sequence will use the default value. For an ascending sequence, the default maximum value is the maximum value of the data type of the sequence and the default minimum value is 1 whereas in case of a descending sequence, the default maximum value is -1 and the default minimum value is the minimum value of the data type of the sequence.
The START clause specifies the starting value of the sequence.
The CYCLE allows you to restart the value if the limit is reached. The next number will be the minimum value for the ascending sequence and maximum value for the descending sequence. If you use NO CYCLE, when the limit is reached, attempting to get the next value will result in an error. The NO CYCLE is the default if you don’t explicitly specify CYCLE or NO CYCLE.
The OWNED BY clause allows you to associate the table column with the sequence so that when you drop the column or table, PostgreSQL will automatically drop the associated sequence.
Now let’s jump into some examples.

Example 1:
In this example, we will use the CREATE SEQUENCE statement to create a new ascending sequence starting from 10 with an increment of 5:

CREATE SEQUENCE mysequence
INCREMENT 5
START 10;
To get the next value from the sequence to you use the nextval() function:

SELECT nextval('mysequence');
It will result in the below output:



Now if we repeat the nexval() function we get the incremented value.

Output:


Example 2:
The following statement creates a descending sequence from 3 to 1 with the cycle option:

CREATE SEQUENCE three
INCREMENT -1
MINVALUE 1 
MAXVALUE 3
START 3
CYCLE;
When you execute the following statement multiple times, you will see the number starting from 3, 2, 1 and back to 3, 2, 1 and so on:

SELECT nextval('three');
Output:


Example 3:
In this example we will create a sequence associated with a table column using the statement below:

CREATE TABLE order_details(
    order_id SERIAL,
    item_id INT NOT NULL,
    product_id INT,
    product_name TEXT NOT NULL,
    price DEC(10, 2) NOT NULL,
    PRIMARY KEY(order_id, item_id)
);
Second, create a new sequence associated with the item_id column of the order_details table:

CREATE SEQUENCE order_item_id
START 10
INCREMENT 10
MINVALUE 10
OWNED BY order_details.item_id;
Third, insert three order line items into the order_details table:

INSERT INTO 
    order_details(order_id, item_id, product_name, price)
VALUES
    (100, nextval('order_item_id'), 'DVD Player', 100),
    (100, nextval('order_item_id'), 'Android TV', 550),
    (100, nextval('order_item_id'), 'Speaker', 250);
Fourth, query data from the order_details table:

SELECT
    order_id,
    item_id,
    product_name,
    price
FROM
    order_details;
Output:



PostgreSQL – ALTER TABLE
Last Updated : 28 Aug, 2020
In PostgreSQL, the structure of an existing table can be modified using the ALTER TABLE statement.

Syntax: ALTER TABLE table_name action;
PostgreSQL supports the various actions to perform with ALTER TABLE as listed below:

Add a column to an existing table as below:
ALTER TABLE table_name ADD COLUMN new_column_name TYPE;
Drop a column from an existing table as below:
ALTER TABLE table_name DROP COLUMN column_name;
Rename a column from an existing table as below:
ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name;
Change the default value of a column from an existing table as below:
ALTER TABLE table_name ALTER COLUMN column_name [SET DEFAULT value | DROP DEFAULT];
Change NOT NULL constraint as below:
ALTER TABLE table_name ALTER COLUMN column_name [SET NOT NULL| DROP NOT NULL];
Add CHECK constraints to a column as below:
ALTER TABLE table_name ADD CHECK expression;
Add a constraint as below:
ALTER TABLE table_name ADD CONSTRAINT constraint_name constraint_definition;
Rename an existing table as below:
ALTER TABLE table_name RENAME TO new_table_name;
Now let’s look into an example. For the same purpose let’s first create a table (say, links) that we can alter in our example using the below statement:

CREATE TABLE links (
    link_id serial PRIMARY KEY,
    title VARCHAR (512) NOT NULL,
    url VARCHAR (1024) NOT NULL UNIQUE
);
Example:
In this example, we will insert a new column to the links table as below:

ALTER TABLE links
ADD COLUMN active boolean;
The following statement removes the active column from the links table:

ALTER TABLE links 
DROP COLUMN active;
To rename the title column to link_title, you use the following statement:

ALTER TABLE links 
RENAME COLUMN title TO link_title;
The following statement adds a new column named target to the links table:

ALTER TABLE links 
ADD COLUMN target VARCHAR(10);
To set _blank as the default value for the target column in the links table, you use the following statement:

ALTER TABLE links 
ALTER COLUMN target
SET DEFAULT '_blank';
If you insert the new row into the links table without specifying a value for the target column, the target column will take _blank as the default value. For demonstration let’s insert some data as follows:

INSERT INTO links (link_title, url)
VALUES('PostgreSQL Tutorial', 'https://www.geeksforgeeks.org/');
Query data from the links table:

SELECT * FROM links;
Output:


PostgreSQL – ADD COLUMN
Last Updated : 28 Aug, 2020
PostgreSQL has an ADD COLUMN statement to add one or more columns to an existing database table. To add a new column to an existing table, you use the ALTER TABLE ADD COLUMN statement.

Syntax:
ALTER TABLE table_name
ADD COLUMN new_column_name data_type;
Let’s analyze the above syntax:

First, specify the table that you want to add a new column in the ALTER TABLE clause.
Second, indicate the column name with its attribute such as data type, default value, etc., in the ADD COLUMN clause.
While adding a new column to the table, PostgreSQL appends it at the end of the table. PostgreSQL has no option to set the position of the new column in the table.

Example 1:
First, we create a table (say, village), with village_id and village_name columns using the below statement:

CREATE TABLE village(
    village_id SERIAL PRIMARY KEY,
    village_name VARCHAR NOT NULL
);
Now we add a district column to the table as below:

ALTER TABLE village
ADD COLUMN district VARCHAR;
Now we can verify if the column has been added using the below statement:

SELECT * FROM village;
Output:



Example 2:
First, we create a table (say, cars), with car_id and car_name columns using the below statement:

CREATE TABLE cars(
    car_id SERIAL PRIMARY KEY,
    car_name VARCHAR NOT NULL
);
Now we add a modelcolumn to the table as below:

ALTER TABLE cars
ADD COLUMN model VARCHAR;
Now we can verify if the column has been added using the below statement:

SELECT * FROM cars;
Output:

PostgreSQL – DROP COLUMN
Last Updated : 28 Aug, 2020
PostgreSQL also supports the DROP COLUMN clause in the ALTER TABLE statement to remove one or more columns of a table. When you remove a column from a table, PostgreSQL will automatically remove all of its indexes and constraints involving the column.

Syntax:
ALTER TABLE table_name 
DROP COLUMN column_name;
Now let’s look into an example.

Example:
First, we create a few tables (say, books, categories, and publishers ) for demonstration having the below depicted relationships:


We create the above tables using the below statements:

CREATE TABLE publishers (
    publisher_id serial PRIMARY KEY,
    name VARCHAR NOT NULL
);

CREATE TABLE categories (
    category_id serial PRIMARY KEY,
    name VARCHAR NOT NULL
);

CREATE TABLE books (
    book_id serial PRIMARY KEY,
    title VARCHAR NOT NULL,
    isbn VARCHAR NOT NULL,
    published_date DATE NOT NULL,
    description VARCHAR,
    category_id INT NOT NULL,
    publisher_id INT NOT NULL,
    FOREIGN KEY (publisher_id) REFERENCES publishers (publisher_id),
    FOREIGN KEY (category_id) REFERENCES categories (category_id)
);
In addition, we create a view based on the books and publishers tables as follows:

CREATE VIEW book_info AS SELECT
    book_id,
    title,
    isbn,
    published_date,
    name
FROM
    books b
INNER JOIN publishers P ON P .publisher_id = b.publisher_id
ORDER BY
    title;
If we want to remove the category_id column of the books table, we use the following statement:

ALTER TABLE books DROP COLUMN category_id;
Now we check the books table using the below statement:

SELECT * FROM books;
Output:


PostgreSQL – Rename Table
Last Updated : 28 Aug, 2020
PostgreSQL has a RENAME clause that is used with the ALTER TABLE statement to rename the name of an existing table.

Syntax:
ALTER TABLE table_name
RENAME TO new_table_name; 
In the above syntax:

First, specify the name of the table which you want to rename after the ALTER TABLE clause.
Second, give the new table name after the RENAME TO clause.
Attempting to rename a table that doesn’t exist leads to PostgreSQL raising an error. To rename multiple tables, one has to execute multiple ALTER TABLE RENAME TO statements. It’s not possible to do it in a single statement.
For the purpose of example let’s first create a table using the below statements and then we will attempt to rename it:

CREATE TABLE vendors (
    id serial PRIMARY KEY,
    name VARCHAR NOT NULL
);
Now check if the table has been successfully created using the below statement:

SELECT * FROM vendors;
Now that our table is ready, let’s jump into an example.

Example:
In this we will rename the vendors table to suppliers, using the following ALTER TABLE RENAME TO statement:

ALTER TABLE vendors RENAME TO suppliers;
Now we can verify if the name has been changed using the below statement:

SELECT * FROM suppliers;
Output:


PostgreSQL – DROP TABLE
Last Updated : 28 Aug, 2020
PostgreSQL has a DROP TABLE statement that is used to remove an existing table or tables from the database.

Syntax: DROP TABLE [IF EXISTS] table_name [CASCADE | RESTRICT];
Let’s analyze the above syntax:

We specify the table name after the DROP TABLE keyword to remove the table permanently from the database.
In case the table that you want to remove is used in views, constraints, or any other objects, the CASCADE allows users to remove those dependent objects together with the table automatically.
RESTRICTrefuses to drop table if there is any object depends on it. PostgreSQL uses RESTRICT by default.
We can put a list of tables after the DROP TABLE to remove multiple tables at once, each table separated by a comma.
We can put a list of tables after the DROP TABLE to remove multiple tables at once, each table separated by a comma.
It is important to note that only superuser, schema owner, and table owner have sufficient privilege to remove the table.
Example 1:
We will remove the author table from our database using the below statement:

DROP TABLE author;
PostgreSQL issues an error because the author table does not exist.

To avoid this error, you can use the IF EXISTS parameter as follows:

DROP TABLE IF EXISTS author;
This will lead to PostgreSQL issuing a notice instead of an error.

Output:


Example 2:
Here we will remove a table that already exists in our database. To check for all available tables in the database use the below command:

\dt
It will list all existing table as below:

Here we will remove the categories table using the below statement:

DROP TABLE categories;
Now check the list of tables again to verify the removal using the below command:

\dt
Output:


PostgreSQL – TRUNCATE TABLE
Last Updated : 28 Aug, 2020
PostgreSQL supports the TRUNCATE TABLE statement to remove all data from large tables quickly. To remove all data from a table, you use the DELETE statement. However, for a large table, it is more efficient to use the TRUNCATE TABLE statement. The TRUNCATE TABLE statement removes all rows from a table without scanning it. This is the reason why it is faster than the DELETE statement. In addition, the TRUNCATE TABLE statement reclaims the storage right away so the user does not have to perform a subsequent VACUUM operation, which is useful in case of large tables.

Syntax: TRUNCATE TABLE table_name;
Example 1:
In our database, we already have a table with data called animals. Let’s check if it has any data using the below statement:

SELECT * FROM animals;
It shows the following result:

Now we will delete all the data from the table using the below statement:

TRUNCATE TABLE animals;
Now we verify whether the deletion is complete using the below statement:

SELECT * FROM animals;
Output:


Example 2:
In our database, we already have a table with data called galaxy. Let’s check if it has any data using the below statement:

SELECT * FROM galaxy;
It shows the following result:

Now we will delete all the data from the table using the below statement:

TRUNCATE TABLE galaxy;
Now we verify whether the deletion is complete using the below statement:

SELECT * FROM galaxy;
Output:


PostgreSQL – Copy a Table
Last Updated : 24 Jan, 2021
This article will be focusing on copying an existing table to a new table in PostgreSQL. This might come in handy while creating new tables that would either have the same data or data of the same table with certain operations performed on them.

We will discuss the following 3 cases:

Copy Table with the same structure and data.
Copy Table with the same structure and no data.
Copy Table with the same structure and partial data.
Copy Table with the Same Structure and Data
To copy a table with all its structure and data, use the following query:

Syntax:
CREATE TABLE new_table AS TABLE old_table;
Example:

Let’s add a table with columns id, first_name, last_name, and email to the database:

CREATE TABLE students(
   id SERIAL PRIMARY KEY,
   first_name VARCHAR,
   last_name VARCHAR,
   email VARCHAR UNIQUE
);
Let’s insert some data into our students table:

INSERT INTO students(first_name, last_name, email)
VALUES('Virender', 'Sehwag', 'virender.sehwag@gfg.com'),
    ('Hardik', 'Pandiya', 'hardik.Pandiya@gfg.com');
Now check the data in the table:

SELECT * FROM students;
If everything works fine, the output will as below:



Now copy the students table to a new table named copy_students table.

CREATE TABLE copy_students AS TABLE students;
The above query will create a new table named copy_students with the same structure and data as the students table.

Now check the data of the copy_students table:

SELECT * FROM copy_students;
Output:



Copy Table with the Same Structure and No Data
WITH NO DATA clause is used to copy a table structure without the data using the below query:

Syntax:
CREATE TABLE new_table AS TABLE old_table WITH NO DATA;
Example:

Let’s use the students table that we created before:

CREATE TABLE without_data_students AS TABLE students WITH NO DATA;
Execute the above query to get the table without_data_students with the same structure as students with no data.

SELECT * FROM without_data_students;
Output:



Copy Table with the Same Structure and Partial Data
The below query can be used to copy a table according to a specified condition:

Syntax:
CREATE TABLE new_table AS TABLE old_table WHERE condition;
Example: 

Let’s insert some more rows into the students table:

INSERT INTO students(first_name, last_name, email)
VALUES('Shreyas', 'Iyer', 'shreyas.iyer@gfg.com'),
    ('Rishabh', 'Pant', 'rishabh.pant@gfg.com');
Now the students table will have the following data:

SELECT * FROM students;
Now the students table will look like this:



Let’s create a table copy_partial_students with id 1 and 3 only:

CREATE TABLE copy_partial_students AS SELECT * FROM students WHERE  id IN (1, 3);
Instead of  *, you can also define the column names that you want to copy. The result table columns will have the names and data types as same as the output columns of the SELECT clause.

Now check the data of the copy_partial_students table:

SELECT * FROM copy_partial_students;
Output:



PostgreSQL – Comparing Tables
Last Updated : 28 Aug, 2020
In PostgreSQL, there are several ways to compare two tables to find the difference between them. In this article, we will look into the two most commonly used techniques. 

1. Comparison using EXCEPT and UNION operators

First, let’s create table two tables named foo and bar, and insert some sample data for the demonstration.

CREATE TABLE foo (
    ID INT PRIMARY KEY,
    NAME VARCHAR (50)
);
INSERT INTO foo (ID, NAME)
VALUES
    (1, 'a'),
    (2, 'b');


CREATE TABLE bar (
    ID INT PRIMARY KEY,
    NAME VARCHAR (50)
);
INSERT INTO bar (ID, NAME)
VALUES
    (1, 'a'),
    (2, 'b');


The foo table has the same structure and data as the bar table.

Next, we update one row in the bar table.

UPDATE bar
SET name = 'c'
WHERE
    id = 2;


Now our tables look like below:

psql table comparision

Then, to find the rows in the foo table but not in the bar table, we use the following query:

SELECT
    ID,
    NAME,
    'not in bar' AS note
FROM
    foo
EXCEPT
    SELECT
        ID,
        NAME,
        'not in bar' AS note
    FROM
        bar;


Output:



We used EXCEPT operator that returns the rows in the foo table but not in the bar table. We can apply the same technique to find the rows that are in the bar table but not in the foo table.

SELECT
    ID,
    NAME,
    'not in foo' AS note
FROM
    bar
EXCEPT
    SELECT
        ID,
        NAME,
        'not in foo' AS note
    FROM
        foo;

Output:

comparing tables in psql

2. Comparison using OUTER JOIN

OUTER JOIN can be used to compare two tables as follows:

SELECT
    id,
    name
FROM
    foo
FULL OUTER JOIN bar USING (id, name)
WHERE
    foo.id IS NULL
OR bar.id IS NULL;
Output:



To find the number of rows that are in the foo table but not bar table and vice versa, we use the COUNT function as follows:

SELECT
    COUNT (*)
FROM
    foo
FULL OUTER JOIN bar USING (id, name)
WHERE
    foo.id IS NULL
OR bar.id IS NULL;
Output:



PostgreSQL – INSERT
Last Updated : 28 Aug, 2020
In PostgreSQL, the INSERT statement is used to add new rows to a database table. As one creates a new database, it has no data initially. PostgreSQL provides the INSERT statement to insert data into the database.

Syntax:
INSERT INTO table(column1, column2, …)
VALUES
    (value1, value2, …);
The below rules must be followed while using the PostgreSQL INSERT statement:

First thing to do is specify the table name followed by the columns where you want to insert the data or rows.
Secondly, you must list a comma-separated value list after the VALUES clause. The value list must be in the same order as the columns list specified after the table name.
Let’s set up a sample database and table for the demonstration of INSERT statement.

Create a database named “company” with the below command:
CREATE DATABASE company;
Add a table of “employee” to show the company hierarchy into the database using the below command:
CREATE TABLE employee (
    employee_id INT PRIMARY KEY,
    first_name VARCHAR (255) NOT NULL,
    last_name VARCHAR (255) NOT NULL,
    manager_id INT,
    FOREIGN KEY (manager_id) 
    REFERENCES employee (employee_id) 
    ON DELETE CASCADE
);
The value in the manager_id column represents the senior manager who the employee reports to. If it’s Null, he/she doesn’t report to anyone.

Example 1:
Here we will add some employee data to the table using the below command:

INSERT INTO employee (
    employee_id,
    first_name,
    last_name,
    manager_id
)
VALUES
    (1, 'Sandeep', 'Jain', NULL),
    (2, 'Abhishek ', 'Kelenia', 1),
    (3, 'Harsh', 'Aggarwal', 1),
    (4, 'Raju', 'Kumar', 2),
    (5, 'Nikhil', 'Aggarwal', 2),
    (6, 'Anshul', 'Aggarwal', 2),
    (7, 'Virat', 'Kohli', 3),
    (8, 'Rohit', 'Sharma', 3);
Output:
Use the below command to verify the inserted data:

SELECT * FROM employee;

The overall hierarchy looks like the below image:


Example 2:
In the above example we inserted multiple rows to the company database, whereas in this example we will add a single row to the database.

INSERT INTO employee (
    employee_id,
    first_name,
    last_name,
    manager_id
)
VALUES
    (9, 'Mohit', 'Verma', 3);
Output:
Now check for the newly added employee using the below command:

SELECT * FROM employee;

Now the overall hierarchy looks like the below image:


PostgreSQL – Insert Multiple Values in Various Rows
Last Updated : 01 Feb, 2021
PostgreSQL is a type of relational database (RDBMS) similar to MySQL. Relational Database stores data in the form of a table in which each row is a record and each column is one attribute. In this article, we will look into the process of inserting multiple rows in a PostgreSQL database. In general, we use the INSERT statement to insert values in a database. Just an improvised version of the same statement can be used to insert multiple values in various rows of a database as shown in the syntax below:

Syntax :

##When specifying Column Names
Insert into tableName (col1, col2) values (value,value),(value,value),(value,value);

## when not specifying Column Names
Insert into tableName  values (value,value),(value,value),(value,value);
Approach :

Our database name is geeksforgeeks and the table name is gfg at the beginning there is no data inside the table. For selecting the database we will use query  \c databaseName.
For checking the data inside the table we will use query select *from tableName.
Now for inserting values, we will use the table name and the column names and the records to be inserted will be separated by comma(“‘”).
The query will be Insert into tableName (col1, col2) values (value,value),(value,value),(value,value).
If you want to insert without the column names then the query will be a different one than the above query.
Insert into tableName  values (value,value),(value,value),(value,value) . But one thing should be remembered here that in this case, the order of the values being inserted should be the same as that of in the database and all the mandatory columns must be inserted.
Now again we will check for records inside the table using select*from tableName.
Example 1 :

In this example, we first selected the database using the \c geeksforgeeks command, and then we looked into the database table records then we inserted the multiples record inside the table then again look inside the database tables. The steps followed are to select the database and then look into the table records then insert multiple values and then again look into the table records.



Example 2 :

Here in this example, we will insert the rows without using the column names but one thing to note about this approach is if you are not giving the column names the order of values being inserted will be the same as that of in the table and all the mandatory columns must be filled in the table otherwise there will be an exception. After inserting the data we will again look into the database table.



PostgreSQL – UPDATE
Last Updated : 28 Aug, 2020
PostgreSQL has an UPDATE statement that is used to update or modify an existing data in the table.

Syntax:
UPDATE table
SET column1 = value1,
    column2 = value2, ...
WHERE
    condition;
Let’s analyze the above syntax:

First step is to specify the table where the changes are supposed to be made.
Then we list the columns whose value is to be updated using the SET clause.
The final step is to determine which rows you want to update exactly using the WHERE clause.
Let’s set up a sample database and table for the demonstration of UPDATE statement.

Create a database named “company” with the below command:
CREATE DATABASE company;
Add a table of “employee” to show the company hierarchy into the database using the below command:
CREATE TABLE employee (
    employee_id INT PRIMARY KEY,
    first_name VARCHAR (255) NOT NULL,
    last_name VARCHAR (255) NOT NULL,
    manager_id INT,
    FOREIGN KEY (manager_id) 
    REFERENCES employee (employee_id) 
    ON DELETE CASCADE
);
Now add some employee data to the table using the below command:
INSERT INTO employee (
    employee_id,
    first_name,
    last_name,
    manager_id
)
VALUES
    (1, 'Sandeep', 'Jain', NULL),
    (2, 'Abhishek ', 'Kelenia', 1),
    (3, 'Harsh', 'Aggarwal', 1),
    (4, 'Raju', 'Kumar', 2),
    (5, 'Nikhil', 'Aggarwal', 2),
    (6, 'Anshul', 'Aggarwal', 2),
    (7, 'Virat', 'Kohli', 3),
    (8, 'Rohit', 'Sharma', 3);
The value in the manager_id column represents the senior manager who the employee reports to. If it’s Null, he/she doesn’t report to anyone.
The overall hierarchy looks like the below image:


Our current tables looks like below:

Now let’s update data in the above mentioned table.

Example 1:
Here we will update the employee “Raju Kumar” name to “Raju Singh” using the UPDATE statement.

UPDATE employee 
SET last_name = 'Singh'
WHERE first_name = 'Raju';
Output:


Example 2:
In the above we made an update to a single row, but here we will make changes to multiple rows. Here we will change the last name of everyone to ‘Gupta’ whose last name is ‘Aggarwal’.

UPDATE employee
SET last_name = 'Gupta'
WHERE last_name = 'Aggarwal';
Output:


PostgreSQL – DELETE
Last Updated : 28 Aug, 2020
To delete data from a table PostgreSQL has a DELETE statement.

Syntax: 
DELETE FROM table
WHERE condition;
The below rules need to be followed while using the DELETE statement:

First, specify the table from which you want to delete data in the DELETE FROM clause.
Second, specify which rows to delete by using the condition in the WHERE clause. The WHERE clause is optional. However, if you omit it, the DELETE statement will delete all rows in the table.
Let’s set up a sample database and table for the demonstration of DELETE statement.

Create a database named “company” with the below command:
CREATE DATABASE company;
Add a table of “employee” to show the company hierarchy into the database using the below command:
CREATE TABLE employee (
    employee_id INT PRIMARY KEY,
    first_name VARCHAR (255) NOT NULL,
    last_name VARCHAR (255) NOT NULL,
    manager_id INT,
    FOREIGN KEY (manager_id) 
    REFERENCES employee (employee_id) 
    ON DELETE CASCADE
);
Now add some employee data to the table using the below command:
INSERT INTO employee (
    employee_id,
    first_name,
    last_name,
    manager_id
)
VALUES
    (1, 'Sandeep', 'Jain', NULL),
    (2, 'Abhishek ', 'Kelenia', 1),
    (3, 'Harsh', 'Aggarwal', 1),
    (4, 'Raju', 'Kumar', 2),
    (5, 'Nikhil', 'Aggarwal', 2),
    (6, 'Anshul', 'Aggarwal', 2),
    (7, 'Virat', 'Kohli', 3),
    (8, 'Rohit', 'Sharma', 3);
The value in the manager_id column represents the senior manager who the employee reports to. If it’s Null, he/she doesn’t report to anyone.
The overall hierarchy looks like the below image:

The current database tables look like below:


Example 1:
Here we will be deleting the employee data whose first name is “Raju”.

DELETE FROM employee
WHERE first_name = 'Raju';
Output:


Example 2:
Here we will delete multiple rows from the “employee” table. We will be deleting the data of the employee named “Abhishek Kelenia” and employees who work under him.

DELETE FROM employee
WHERE last_name = 'Kelenia';
Output:


conditionals 

PostgreSQL – CASE
Last Updated : 28 Aug, 2020
PostgreSQL has a conditional expression called CASE to form conditional queries. The PostgreSQL CASE expression is the same as IF/ELSE statement in other programming languages. PostgreSQL provides two forms of the CASE expressions.

Syntax:
CASE 
      WHEN condition_1  THEN result_1
      WHEN condition_2  THEN result_2
      [WHEN ...]
      [ELSE result_n]
END
For examples we will be using the sample database (ie, dvdrental).

Example 1:
Here we will work on the film table of the sample database. Suppose you want to assign a price segment to a film with the following logic:

Mass if the rental rate is 0.99
Economic if the rental rate is 1.99
Luxury if the rental rate is 4.99
We will query for number of films in each segment using the below statement:

SELECT
    SUM (
        CASE
        WHEN rental_rate = 0.99 THEN
            1
        ELSE
            0
        END
    ) AS "Mass",
    SUM (
        CASE
        WHEN rental_rate = 2.99 THEN
            1
        ELSE
            0
        END
    ) AS "Economic",
    SUM (
        CASE
        WHEN rental_rate = 4.99 THEN
            1
        ELSE
            0
        END
    ) AS "Luxury"
FROM
    film;
Output:



Example 2:
PostgreSQL provides another form of the CASE expression called simple form as follows:

CASE expression
WHEN value_1 THEN
    result_1
WHEN value_2 THEN
    result_2 
[WHEN ...]
ELSE
    result_n
END;
We can rewrite the general CASE expression using the simple CASE as follows:

SELECT
    SUM (
        CASE rental_rate
        WHEN 0.99 THEN
            1
        ELSE
            0
        END
    ) AS "Mass",
    SUM (
        CASE rental_rate
        WHEN 2.99 THEN
            1
        ELSE
            0
        END
    ) AS "Economic",
    SUM (
        CASE rental_rate
        WHEN 4.99 THEN
            1
        ELSE
            0
        END
    ) AS "Luxury"
FROM
    film;
Output:
The query returns the same result as the first CASE example.


PostgreSQL – COALESCE
Last Updated : 28 Aug, 2020
In PostgreSQL, the COALESCE function returns the first non-null argument. It is generally used with the SELECT statement to handle null values effectively.

Syntax: COALESCE (argument_1, argument_2, …);
The COALESCE function accepts an unlimited number of arguments. It returns the first argument that is not null. If all arguments are null, the COALESCE function will return null. he COALESCE function evaluates arguments from left to right until it finds the first non-null argument. All the remaining arguments from the first non-null argument are not evaluated.

Example:
For the purpose of demonstration let’s first create a table (say, items) using the below statement:

CREATE TABLE items (
    ID serial PRIMARY KEY,
    product VARCHAR (100) NOT NULL,
    price NUMERIC NOT NULL,
    discount NUMERIC
);
There are four fields in the items table:

id: the primary key that identifies the item in the items table.
product: the product name.
price: the price of the product.
discount: the discount of the product.
Now we insert some records into the items table using INSERT statement as follows:

INSERT INTO items (product, price, discount)
VALUES
    ('A', 1000, 10),
    ('B', 1500, 20),
    ('C', 800, 5),
    ('D', 500, NULL);
Finally we query the net prices of the products using the following:

SELECT
    product,
    (price - discount) AS net_price
FROM
    items;
This will lead to the following:

f you look at the fourth row, you will notice that the net price of the product D is null which seems not correct. The issue is the discount of the product D is null, therefore when we take the null value to calculate the net price, PostgreSQL returns null. The get the right price, we need to assume that if the discount is null, it is zero. Then we can use the COALESCE function as follows:

SELECT
    product,
    (price - COALESCE(discount, 0)) AS net_price
FROM
    items;
Output:


PostgreSQL – NULLIF() Function
Last Updated : 28 Aug, 2020
PostgreSQL has a NULLIF function to handle null values. The NULLIF function is one of the most common conditional expressions provided by PostgreSQL.

Syntax:NULLIF(argument_1,argument_2);

The NULLIF function returns a null value if argument_1 equals to argument_2, otherwise it returns argument_1.

Example :

First, we create a table named posts as follows:

CREATE TABLE posts (
  id serial primary key,
    title VARCHAR (255) NOT NULL,
    excerpt VARCHAR (150),
    body TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

Now we insert some sample data to the table as follows:

INSERT INTO posts (title, excerpt, body)
VALUES
      ('test post 1','test post excerpt 1','test post body 1'),
      ('test post 2','','test post body 2'),
      ('test post 3', null ,'test post body 3');

Our aim is to display the posts overview page that shows the title and excerpt of each post. In case the excerpt is not provided, we use the first 40 characters of the post body. We can simply use the following query to get all rows in the posts table.

SELECT
    ID,
    title,
    excerpt
FROM
    posts;

This leads to the following:

nullif

The null value in the excerpt column. To substitute this null value, we can use the COALESCE function as follows:

SELECT
    id,
    title,
    COALESCE (excerpt, LEFT(body, 40))
FROM
    posts;

This will result in the following:



Unfortunately, there is a mix between null value and ” (empty) in the excerpt column. This is why we need to use the NULLIF function:

SELECT
    id,
    title,
    COALESCE (
        NULLIF (excerpt, ''),
        LEFT (body, 40)
    )
FROM
    posts;

Output:


control flow 

PostgreSQL – IF Statement
Last Updated : 22 Feb, 2022
PostgreSQL has an IF statement executes `statements` if a condition is true. If the condition evaluates to false, the control is passed to the next statement after the END IF part.

Syntax:
IF condition THEN
   statements;
END IF;
The above conditional statement is a boolean expression that evaluates to either true or false.

Example 1:

In this example, we declare two variables a and b. In the body of the block, we compare the value of a and b using the comparison operator >, < and = in the boolean expressions of the IF statements.

DO $$
DECLARE
  a integer := 10;
  b integer := 20;
BEGIN 
  IF a > b THEN
    RAISE NOTICE 'a is greater than b';
  END IF;

  IF a < b THEN
    RAISE NOTICE 'a is less than b';
  END IF;

  IF a = b THEN
    RAISE NOTICE 'a is equal to b';
  END IF;
END $$;
Output:



Example 2:

DO $$
DECLARE
   a integer := 10;
   b integer := 10;
BEGIN 
  IF a > b THEN 
     RAISE NOTICE 'a is greater than b';
  ELSIF a < b THEN
     RAISE NOTICE 'a is less than b';
  ELSE
     RAISE NOTICE 'a is equal to b';
  END IF;
END $$;
Output:



PostgreSQL – CASE Statement
Last Updated : 28 Aug, 2020
PostgreSQL provides you with CASE statements that allow you to execute a block of code conditionally. There are two forms of the CASE statement: 

Simple CASE statement
Searched CASE statement
Simple CASE statement
Syntax:
CASE search-expression
   WHEN expression_1 [, expression_2, ...] THEN
      when-statements
  [ ... ]
  [ELSE
      else-statements ]
END CASE;

The search-expression is an expression that will evaluate with the expression in each WHEN branch using equality operand (=). If a match found, the when-statements in the corresponding WHEN branch are executed. The subsequent expressions underneath will not be evaluated.

The else-statements in the ELSE branch are executed if no match found. The ELSE branch is optional. If no match found and there is no ELSE branch, PostgreSQL will raise the CASE_NOT_FOUND exception.

Let’s look into some examples in our sample dvdrental database.

Example:

Here we will create a new function named get_price_segment that accepts p_film_id as the argument. Based on the rental rate of the film, it returns the price segment: mass, mainstream, high end. In case the price is not 0.99, 2.99 or 4.99, the function returns unspecified.

CREATE OR REPLACE FUNCTION get_price_segment(p_film_id integer)
   RETURNS VARCHAR(50) AS $$
DECLARE 
    rate   NUMERIC;
    price_segment VARCHAR(50);
BEGIN
      -- get the rate based on film_id
    SELECT INTO rate rental_rate 
    FROM film 
    WHERE film_id = p_film_id;
        
     CASE rate
    WHEN 0.99 THEN
            price_segment = 'Mass';
    WHEN 2.99 THEN
            price_segment = 'Mainstream';
    WHEN 4.99 THEN
            price_segment = 'High End';
    ELSE
        price_segment = 'Unspecified';
    END CASE;
    
   RETURN price_segment;
END; $$
LANGUAGE plpgsql;

Now test the get_price_segment() function using the statement:

SELECT get_price_segment(123) AS "Price Segment";

Output:



Searched CASE statement
Syntax:
CASE
    WHEN boolean-expression-1 THEN
      statements
  [ WHEN boolean-expression-2 THEN
      statements
    ... ]
  [ ELSE
      statements ]
END CASE;

The searched CASE statement executes statements based on the result of Boolean expressions in each WHEN clause. PostgreSQL evaluates the Boolean expressions sequentially from top to bottom until one expression is true. Then the evaluation stops and the corresponding statement are executed. The control is passed to the next statement after the END CASE.

In case no true result found, the statements in the ELSE clause are executed. The ELSE clause is optional. If you omit the ELSE clause and there is no true result, PostgreSQL will raise the CASE_NOT_FOUND exception.

Example:

The get_customer_service function accepts p_customer_id as the argument. It first gets the total payment paid by the customer from the payment table. Then based on the total payment, the function uses the searched CASE statement to return the service level platinum, gold, and silver.

CREATE OR REPLACE FUNCTION get_customer_service (p_customer_id INTEGER) 
    RETURNS VARCHAR (25) AS $$ 
DECLARE
 total_payment NUMERIC ; 
        service_level VARCHAR (25) ;
BEGIN
 -- get the rate based on film_id
     SELECT
 INTO total_payment SUM (amount)
     FROM
 payment
     WHERE
 customer_id = p_customer_id ; 
  
   CASE
      WHEN total_payment > 200 THEN
         service_level = 'Platinum' ;
      WHEN total_payment > 100 THEN
     service_level = 'Gold' ;
      ELSE
         service_level = 'Silver' ;
   END CASE ;

   RETURN service_level ;
END ; $$ LANGUAGE plpgsql;

Now let’s test the above function using the below statement:

SELECT
  148 AS customer,
    get_customer_service (148)
UNION

   SELECT
  178 AS customer,
    get_customer_service (178)
UNION
   SELECT
  81 AS customer,
    get_customer_service (81);

Output:



PostgreSQL – Loop Statement
Last Updated : 08 Feb, 2021
The loop statement is used to simply define an unconditional loop that executes statements of code repeatedly until it is terminated after encountering a return or exit statement.

Syntax:

<<label>>
loop
  statements/body;
end loop;
In the above syntax, we must ideally do the following :

Condition for termination:  We should try to define a condition in the body of the loop until which our loop runs. As soon as this condition fails, the loop will be terminated. If we do not define a termination condition, the loop executes infinite times and we encounter the case of an infinite loop.
 
Increment/Decrement: We should try to include an increment or decrement statement inside the body to increase or decrease the running variable. If we do not change the value of the variable, the loop gets stuck in the same condition again and again and we encounter the case of an infinite loop.
To terminate the running of the loop, we can simply include an if statement with an exit statement with the following syntax:

<<label>>
loop
  statements;
  if condition then
     exit;
  end if;
end loop;


A condition when we place a loop inside another loop is called a nested loop. It is important to note that whenever we use nested looping, we must define the loop labels in the exit or continue statements to show precisely which loop we are referring to.

<<outer>>
loop  
  statements;
  <<inner>>
  loop
    inside statements;
    exit <<inner>>
  end loop;
end loop;
Example 1:

The following example shows how to use the loop statement to print all numbers from 1 to 5.

do $$
declare
  n integer:= 6;
  cnt integer := 1 ;  
begin
loop  
 exit when cnt = n ;
 raise notice '%', cnt;  
 cnt := cnt + 1 ;  
end loop;  
end; $$;
Output:



In the above example, we define a cnt variable whose value is increased at each iteration. The value of cnt is printed until it reaches our peak value of n after which the loop is terminated. 

Example 2:

The following example shows how to use the loop statement to print all numbers from 10 to 1.

do $$
declare
 n integer:= 0;
 cnt integer := 10 ;  
begin
loop  
exit when cnt = n ;
raise notice '%', cnt;  
cnt := cnt - 1 ;  
end loop;  
end; $$;
Output:



In the above example, we define a cnt variable whose value is decreased at each iteration. The value of cnt is printed until it reaches our minimum value of n after which the loop is terminated.

PostgreSQL – While Loops
Last Updated : 24 Jan, 2021
PostgreSQL provides the loop statement which simply defines an unconditional loop that executes repeatedly a block of code until terminated by an exit or return statement. The while loop statement executes a block of code till the condition remains true and stops executing when the conditions become false.

The syntax of the loop statement:

[ <<label>> ]
while condition loop
  statements;
end loop;
If we analyze the above syntax:

Condition: If the condition is true, it executes the statements. After each iteration, the while loop again checks the condition.
Body / Statements: Inside the body of the while loop, we need to change the values of some variables to make the condition false or null at some points. Otherwise, we will encounter the case of an infinite loop.
As the while loop tests the condition before executing the statements, it is also referred to as a pretest loop.

The following flowchart describes the while loop statement:


Flowchart of While loop

Example 1:

 The following code is used to raise notices while increasing the count of an arbitrary variable from 0 to 9.

do $$
declare
add integer := 0;
begin
while add <10 loop
raise notice 'Out addition count %', add;
add := add+1;
end loop;
end$$;
Output:



Example 2:

 The following code is used to raise notices while decreasing the count of an arbitrary variable from 10 to 1.

do $$
declare
add integer := 10;
begin
while add > 0 loop
raise notice 'Out addition count %',add;
add := add-1;
end loop;
end$$;
Output:



PostgreSQL – Exit
Last Updated : 08 Feb, 2021
In PostgreSQL, The EXIT statement is used to terminate all types of loops like unconditional loops, a while loop, or a for loop or terminate a block of code specified by the begin..end keywords.

Using EXIT for loops 
We can use the exit to terminate looping statements using the following syntax:

Syntax:
exit [label] [when condition]
If we analyze the above syntax:

Label: The label is used to signify the loop which we want to exit. It is often used in the case of nested looping. If a label is not present, the current loop is terminated.
 
Condition: The condition is a simple boolean expression that determines when we want to terminate the loop. When the value of the boolean expression becomes true, the loop is terminated.
Both of the above are optional. We can use exit with a condition like:

exit when cnt < 5;
Without using the condition in exit, we can rewrite the same code using the IF statement as:

if cnt < 5 then
  exit;
end if;
Example:
Suppose we a have loop that is used to print all numbers from 1 to 10. We can use the EXIT statement in the following manner to limit printing the numbers up to 7 only.

do $$
declare
 n integer:= 8;
 cnt integer := 1 ;  
begin
loop  
exit when cnt = n ;
raise notice '%', cnt;  
cnt := cnt + 1 ;  
end loop;  
end; $$;
Output:



In the above example, we terminate our loop as soon as the value of our cnt variable reaches n(here 8) and thus, only values up to 7 are printed.

Using EXIT to exit a block
We can then the exit statement to terminate a block of code specified by the begin..end keywords. In this case, the exit directly passes the flow of the program to after the end keyword, thus ending the current block.

Syntax:
<<block_label>>
BEGIN
   Statements
   EXIT [block_label] [WHEN condition];
   Statements
END block_label;
Using this syntax, we can terminate the block of code prematurely, thus preventing the statements after the exit to be run.

Example:
The following example shows how we can use EXIT to exit a block.

do
$$
begin
 raise notice '%', 'Before block';
 <<normalblock>>  
  begin
 raise notice '%', 'Before exit ; inside block';
   exit normalblock;
    raise notice '%', 'After exit ; inside block';
  end;
  raise notice '%', 'End of block';
end;
$$;
Output:



In the above example, the statement after exit was not printed as the block was terminated using EXIT before the statement. Thus inside the block, only statements before EXIT were executed and after that, the flow simply passes after the block ended.

PostgreSQL – Continue
Last Updated : 20 Sep, 2021
In PostgreSQL ,The continue statement is used to skip the current iteration prematurely and directly move on to the next iteration. The continue statement is used in conjecture with all types of loops including unconditional loops, while loops and for loops.



Syntax:

CONTINUE [ label ] [ WHEN boolean-expression ];
If we analyze the above syntax:

label: If no label is present, the next iteration of the loop starts. That is, all statements remaining in the loop body are skipped, and control returns to the loop control expression.However, if the label is present, it specifies the label of the loop whose execution will be continued.
 
WHEN condition: It is simply a boolean expression that specifies the condition to skip the current iteration of the loop. If the condition is true, then the current loop iteration will be skipped. However, if it is false, the loop follows the normal flow pattern.
Both the label and WHEN condition is optional and may or may not be used with the continue statement;

Example 1 : 

The following example will be used to display the even numbers from 1 to 10.

do
$$
declare
  cnt int = 0;
begin
 loop
 -- increment of cnt
    cnt = cnt + 1;
 -- exit the loop if cnt > 10
 exit when cnt > 10;
 -- skip the iteration if cnt is an odd number
 continue when mod(cnt,2) = 1;
 -- print out the cnt
 raise notice '%', cnt;
 end loop;
end;
$$;
Output:



In the above example, we use the continue statement to skip the odd numbers by using the fact that the remainder when an odd number is divided by 2 is 1.  

Example 2 :
The following example will be used to display all numbers from 1 to 10 without displaying the number 6.

do
$$
declare
  cnt int = 0;
begin 
 loop
 -- increment of cnt
    cnt = cnt + 1;
 -- exit the loop if cnt > 10
 exit when cnt > 10;
 -- skip the iteration if cnt is an odd number
 continue when cnt = 6;
 -- print out the cnt
 raise notice '%', cnt;
 end loop;
end;
$$;
Output:



In the above example, we use the continue statement to skip the iteration when the value of the cnt variable reaches 6.

transactions and constraints

PostgreSQL – Transactions
Last Updated : 01 Feb, 2021
The Transaction is not a new word we are hearing. We heard that word many times like “Cash Transaction”. Banks usually deal with cash i.e sending or receiving cash, hence we coin the term as a cash transaction. So simply transaction is a unit of work. In this article, we are going to learn about transactions in the PostgreSQL database language. 

Transactions are important in any database language, whenever we want to add, delete and update then transactions are used for keeping the integrity of data and several other reasons. Even without the transactions we can add, delete and update the database but there are so high chances to data gets corrected due to loss of data integrity.

Properties of Transaction
Now let’s see the ACID properties of a transaction:

Atomicity – This property ensures that all the transactions are complete. It follows all or none property i.e the transaction should not be partially completed.
Consistency – This property ensures that all the transactions are consistent i.e after committing the transaction those changes are properly updated in the database or not.
Isolation – When two transactions are running then both the transactions will have their own privacy i.e one transaction won’t disturb another transaction.
Durability – This property ensures that even at the time of system failures the committed data in database is secure i.e permanently.
Commands in a Transaction
There are three main commands in a transaction block. They are:

BEGIN
COMMIT
ROLLBACK
General Syntax:
BEGIN;

// set of statements

[COMMIT | ROLLBACK];
Now we will understand the importance of each and every transaction control command, for that, we have to set up a table in the database first.

CREATE TABLE BankStatements (
    customer_id serial PRIMARY KEY,
    full_name VARCHAR NOT NULL,
    balance INT
);
As the database schema is ready now we will insert some values in it.

INSERT INTO BankStatements (
    customer_id ,
    full_name,
    balance
)
VALUES
    (1, 'Sekhar rao', 1000),
    (2, 'Abishek Yadav', 500),
    (3, 'Srinivas Goud', 1000);
1. BEGIN
BEGIN command is used to initiate a transaction. To start a transaction we should give BEGIN command at first if we don’t give it like that then the database cant able recognizes the transaction.

Example 1

BEGIN;

 INSERT INTO BankStatements (
     customer_id,
    full_name,
        balance

)
    VALUES(
       4, 'Priya chetri', 500
        )
;
        
COMMIT;
Output



2. COMMIT
COMMIT command is used to save changes and reflect them in the database whenever we display the required data. For suppose we updated data in the database but we didn’t give COMMIT then the changes are not reflected in the database. To save the changes done in a transaction, we should COMMIT that transaction for sure.

Example 2

BEGIN;

    UPDATE BankStatements
        SET balance = balance - 500
        WHERE 
        customer_id = 1;
      

    SELECT customer_id, full_name, balance
        FROM BankStatements;
      
    UPDATE BankStatements
        SET balance = balance + 500
        WHERE 
        customer_id = 2;
 
      
COMMIT;


SELECT customer_id, full_name, balance
    FROM BankStatements;
    
Output:



3. ROLLBACK
ROLLBACK command is used to undo the changes done in transactions. As we know transactions in database languages are used for purpose of large computations, for example in banks. For suppose, the employee of the bank incremented the balance record of the wrong person mistakenly then he can simply rollback and can go to the previous state.

Example 3

BEGIN;

    DELETE FROM BankStatements
        WHERE 
        customer_id = 1;
      

    SELECT customer_id, full_name, balance
        FROM BankStatements;
      

ROLLBACK;


SELECT customer_id, full_name, balance
    FROM BankStatements;
Output:



PostgreSQL – COMMIT
Last Updated : 04 Jul, 2022
PostgreSQL COMMIT command is used to save changes and reflect it database whenever we display the required data. For suppose we updated data in the database but we didn’t give COMMIT then the changes are not reflected in the database. To save the changes done in a transaction, we should COMMIT that transaction for sure.

Syntax :

COMMIT TRANSACTION;

(or)

COMMIT;

(or)

END TRANSACTION;
Unlike other database languages in PostgreSQL, we commit the transaction in 3 different forms which are mentioned above. Now for getting good command in the use of COMMIT command we will first create a table for examples.

CREATE TABLE BankStatements (
    customer_id serial PRIMARY KEY,
    full_name VARCHAR NOT NULL,
    balance INT
);
Now we will insert data of some customers

INSERT INTO BankStatements (
    customer_id ,
    full_name,
    balance
)
VALUES
    (1, 'Sekhar rao', 1000),
    (2, 'Abishek Yadav', 500),
    (3, 'Srinivas Goud', 1000);
Now as  the table is ready we will understand about commit

Example 1: 

We will add the data to the table in the transaction using the commit

BEGIN;

 INSERT INTO BankStatements (
     customer_id,
    full_name,
        balance

)
    VALUES(
       4, 'Priya chetri', 500
        )
;
        
COMMIT;
Output:



Example 2:

We will update the balance and display the data without committing the transaction thereafter committing it.

BEGIN;


    UPDATE BankStatements
      SET balance = balance - 500
      WHERE 
      customer_id = 1;
      
      // displaying data before
      // committing the transaction
      SELECT customer_id, full_name, balance
      FROM BankStatements;
      
      UPDATE BankStatements
      SET balance = balance + 500
      WHERE 
      customer_id = 2;
 



       
COMMIT;

// displaying data after
// committing the transaction
SELECT customer_id, full_name, balance
FROM BankStatements;
Output:



NOTE: When we try to display data from another session before committing the changes then we will get the same output that we got in the first example. 

PostgreSQL – Primary Key
Last Updated : 01 Jun, 2020
In this article we will look into the PostgreSQL Primary key constraints using SQL statements. A primary key is a column or a group of columns used to identify a row uniquely in a table. Technically speaking a primary key constraint is the blend of a not-null constraint and a UNIQUE constraint. Only one primary key must exist in a table. PostgreSQL produces a unique B-tree index on the column or a group of columns used that defines the primary key whenever a primary key is added to the table.

Syntax: column_name Data-type PRIMARY KEY
Now let’s look into some examples.
Example 1:
In this example we will create a table (say, books) and add a column(say, book_id) as the primary key of the table.

CREATE TABLE books (
    book_id INTEGER PRIMARY KEY,
    title TEXT,
    price INTEGER
);
Now let’s insert some data to our table using the below command:

INSERT INTO books(book_id, title, price)
VALUES
    ('101', 'Jobs', '2000'),
    ('102', 'Geeta', '250'),
    ('103', 'Ramayana', '354'),
    ('104', 'Vedas', '268');
Now we will check if the inserted works as intended using the below command:

 SELECT * FROM books;
Output:


Example 2:
In this example we will be adding PRIMARY key to an existing table. So, lets first create one using the command below:

CREATE TABLE vendors (name VARCHAR(255));
Now add few rows to the vendors table using INSERT statement as below:

INSERT INTO vendors (NAME)
VALUES
    ('Microsoft'),
    ('IBM'),
    ('Apple'),
    ('Samsung');
Now verify the insert operation, we query data from the vendors table using the following SELECT statement:

SELECT
    *
FROM
    vendors;
This will give us the below result:

Now, if we want to add a primary key named id into the vendors table and the id field is auto-incremented by a single unit, we use the below statement:

ALTER TABLE vendors ADD COLUMN ID SERIAL PRIMARY KEY;
Let’s check the vendors table again using the below command:

SELECT
    id, name
FROM
    vendors;
Output:


PostgreSQL – Foreign Key
Last Updated : 28 Aug, 2020
In this article, we will look into the PostgreSQL Foreign key constraints using SQL statements. A foreign key is a column or a group of columns used to identify a row uniquely of a different table. The table that comprises the foreign key is called the referencing table or child table. And the table to that the foreign key references is known as the referenced table or parent table. A table can possess multiple foreign keys according to its relationships with other tables. 

 

Syntax:  FOREIGN KEY (column) REFERENCES parent_table (table_name)
Let’s analyze the above syntax:

First, specify the name for the foreign key constraint after the CONSTRAINT keyword. The CONSTRAINT clause is optional. If you omit it, PostgreSQL will assign an auto-generated name.
Second, specify one or more foreign key columns in parentheses after the FOREIGN KEY keywords.
Third, specify the parent table and parent key columns referenced by the foreign key columns in the REFERENCES clause.
Finally, specify the delete and update actions in the ON DELETE and ON UPDATE clauses.
The delete and update actions determine the behaviors when the primary key in the parent table is deleted and updated. Since the primary key is rarely updated, the ON UPDATE action is not often used in practice. We’ll focus on the ON DELETE action.

PostgreSQL supports the following actions:

SET NULL
SET DEFAULT
RESTRICT
NO ACTION
CASCADE
Example:

The following statements create the customers and contacts tables:

DROP TABLE IF EXISTS customers;
DROP TABLE IF EXISTS contacts;

CREATE TABLE customers(
   customer_id INT GENERATED ALWAYS AS IDENTITY,
   customer_name VARCHAR(255) NOT NULL,
   PRIMARY KEY(customer_id)
);

CREATE TABLE contacts(
   contact_id INT GENERATED ALWAYS AS IDENTITY,
   customer_id INT,
   contact_name VARCHAR(255) NOT NULL,
   phone VARCHAR(15),
   email VARCHAR(100),
   PRIMARY KEY(contact_id),
   CONSTRAINT fk_customer
      FOREIGN KEY(customer_id) 
      REFERENCES customers(customer_id)
);
In this example, the customer table is the parent table and the contacts table is the child table. Each customer has zero or many contacts and each contact belongs to zero or one customer. The customer_id column in the contacts table is the foreign key column that references the primary key column with the same name in the customer’s table. The following foreign key constraint fk_customer in the contacts table defines the customer_id as the foreign key:

CONSTRAINT fk_customer
   FOREIGN KEY(customer_id) 
      REFERENCES customers(customer_id)
Because the foreign key constraint does not have the ON DELETE and ON UPDATE action, they default to NO ACTION.

NO ACTION
The following inserts data into the customers and contacts tables:

INSERT INTO customers(customer_name)
VALUES('GeeksforGeeks org'),
      ('Dolphin LLC');       
       
INSERT INTO contacts(customer_id, contact_name, phone, email)
VALUES(1, 'Raju kumar', '(408)-111-1234', 'raju.kumar@geeksforgeeks.org'),
      (1, 'Raju kumar', '(408)-111-1235', 'raju.kumar@bluebird.dev'),
      (2, 'Nikhil Aggarwal', '(408)-222-1234', 'nikhil.aggarwalt@geeksforgeeks.org');
The following statement deletes the customer id 1 from the customers table:

DELETE FROM customers
WHERE customer_id = 1;
Because of the ON DELETE NO ACTION, PostgreSQL issues a constraint violation because the referencing rows of the customer id 1 still exist in the contacts table:

ERROR:  update or delete on table "customers" violates foreign key constraint
        "fk_customer" on table "contacts"
DETAIL:  Key (customer_id)=(1) is still referenced from table "contacts".
SQL state: 23503
The RESTRICT action is similar to the NO ACTION. The difference only arises when you define the foreign key constraint as DEFERRABLE with an INITIALLY DEFERRED or INITIALLY IMMEDIATE mode. 

SET NULL
The ON DELETE CASCADE automatically sets NULL to the foreign key columns in the referencing rows of the child table when the referenced rows in the parent table are deleted. The following statements drop the sample tables and re-create them with the foreign key that uses the SET NULL action in the ON DELETE clause:

DROP TABLE IF EXISTS contacts;
DROP TABLE IF EXISTS customers;

CREATE TABLE customers(
   customer_id INT GENERATED ALWAYS AS IDENTITY,
   customer_name VARCHAR(255) NOT NULL,
   PRIMARY KEY(customer_id)
);

CREATE TABLE contacts(
   contact_id INT GENERATED ALWAYS AS IDENTITY,
   customer_id INT,
   contact_name VARCHAR(255) NOT NULL,
   phone VARCHAR(15),
   email VARCHAR(100),
   PRIMARY KEY(contact_id),
   CONSTRAINT fk_customer
      FOREIGN KEY(customer_id) 
      REFERENCES customers(customer_id)
      ON DELETE SET NULL
);

INSERT INTO customers(customer_name)
VALUES('GeeksforGeeks org'),
      ('Dolphin LLC');       
       
INSERT INTO contacts(customer_id, contact_name, phone, email)
VALUES(1, 'Raju kumar', '(408)-111-1234', 'raju.kumar@geeksforgeeks.org'),
      (1, 'Raju kumar', '(408)-111-1235', 'raju.kumar@bluebird.dev'),
      (2, 'Nikhil Aggarwal', '(408)-222-1234', 'nikhil.aggarwalt@geeksforgeeks.org');
The following statements insert data into the customers and contacts tables:

INSERT INTO customers(customer_name)
VALUES('GeeksforGeeks org'),
      ('Dolphin LLC');       
       
INSERT INTO contacts(customer_id, contact_name, phone, email)
VALUES(1, 'Raju kumar', '(408)-111-1234', 'raju.kumar@geeksforgeeks.org'),
      (1, 'Raju kumar', '(408)-111-1235', 'raju.kumar@bluebird.dev'),
      (2, 'Nikhil Aggarwal', '(408)-222-1234', 'nikhil.aggarwalt@geeksforgeeks.org');
To see how the SET NULL works, let’s delete the customer with id 1 from the customers table:

DELETE FROM customers
WHERE customer_id = 1;
Because of the ON DELETE SET NULL action, the referencing rows in the contacts table set to NULL. The following statement displays the data in the contacts table:

SELECT * FROM contacts;
It will result in the following:



As can be seen clearly from the output, the rows that have the customer_id 1 now have the customer_id sets to NULL

CASCADE
The ON DELETE CASCADE automatically deletes all the referencing rows in the child table when the referenced rows in the parent table are deleted. In practice, the ON DELETE CASCADE is the most commonly used option.  The following statements recreate the sample tables. However, the delete action of the fk_customer changes to CASCADE:

DROP TABLE IF EXISTS contacts;
DROP TABLE IF EXISTS customers;

CREATE TABLE customers(
   customer_id INT GENERATED ALWAYS AS IDENTITY,
   customer_name VARCHAR(255) NOT NULL,
   PRIMARY KEY(customer_id)
);

CREATE TABLE contacts(
   contact_id INT GENERATED ALWAYS AS IDENTITY,
   customer_id INT,
   contact_name VARCHAR(255) NOT NULL,
   phone VARCHAR(15),
   email VARCHAR(100),
   PRIMARY KEY(contact_id),
   CONSTRAINT fk_customer
      FOREIGN KEY(customer_id) 
      REFERENCES customers(customer_id)
      ON DELETE CASCADE
);

INSERT INTO customers(customer_name)
VALUES('GeeksforGeeks org'),
      ('Dolphin LLC');       
       
INSERT INTO contacts(customer_id, contact_name, phone, email)
VALUES(1, 'Raju kumar', '(408)-111-1234', 'raju.kumar@geeksforgeeks.org'),
      (1, 'Raju kumar', '(408)-111-1235', 'raju.kumar@bluebird.dev'),
      (2, 'Nikhil Aggarwal', '(408)-222-1234', 'nikhil.aggarwalt@geeksforgeeks.org');
The following statement deletes the customer id 1:

DELETE FROM customers
WHERE customer_id = 1;
Because of the ON DELETE CASCADE action, all the referencing rows in the contacts table are automatically deleted:

SELECT * FROM contacts;
This will result in the following:



SET DEFAULT
The ON DELETE SET DEFAULT sets the default value to the foreign key column of the referencing rows in the child table when the referenced rows from the parent table are deleted. To add a foreign key constraint to the existing table, you use the following form of the ALTER TABLE statement:

ALTER TABLE child_table 
ADD CONSTRAINT constraint_name 
FOREIGN KEY (fk_columns) 
REFERENCES parent_table (parent_key_columns);
When you add a foreign key constraint with ON DELETE CASCADE option to an existing table, you need to follow these steps:

First, drop existing foreign key constraints:

ALTER TABLE child_table
DROP CONSTRAINT constraint_fkey;
Then, add a new foreign key constraint with ON DELETE CASCADE action:

ALTER TABLE child_table
ADD CONSTRAINT constraint_fk
FOREIGN KEY (fk_columns)
REFERENCES parent_table(parent_key_columns)
ON DELETE CASCADE;



PostgreSQL – CHECK Constraint
Last Updated : 01 Jun, 2020
In PostgreSQL, the CHECK constraint is primarily used to specify if a value in a column necessarily meets a specific requirement. The CHECK constraint utilizes a Boolean expression to assess the values before performing an insert or update operation to the column. If the values pass the check, PostgreSQL allows the insertion or update of those values into the column. It is primarily used while creating a table.

Syntax: variable_name Data-type CHECK(condition);
Now let’s jump into an example for better understanding.

Example:
We will first create an employee table with specific checks as follows:

CREATE TABLE employees (
    id serial PRIMARY KEY,
    first_name VARCHAR (50),
    last_name VARCHAR (50),
    birth_date DATE CHECK (birth_date > '1900-01-01'),
    joined_date DATE CHECK (joined_date > birth_date),
    salary numeric CHECK(salary > 0)
);
Now we will first insert data that satisfies the above constraints using the below command:

INSERT INTO employees (
    first_name,
    last_name,
    birth_date,
    joined_date,
    salary
)
VALUES
    (
        'Raju',
        'Kumar',
        '1994-01-01',
        '2015-07-01',
         100000
    );
Now if we check if the data insertion was successful using the below command:

SELECT * FROM employee;
We can see the data inserted as below:


Now we will try to insert data that fails the check as below:

INSERT INTO employees (
    first_name,
    last_name,
    birth_date,
    joined_date,
    salary
)
VALUES
    (
        'Nikhil',
        'Aggarwal',
        '1972-01-01',
        '2015-07-01',
        - 100000
    );
Output:

ERROR:  new row for relation "employees" violates check constraint "employees_salary_check"
DETAIL:  Failing row contains (2, Nikhil, Aggarwal, 1972-01-01, 2015-07-01, -100000)


As we can see the behaviour is exactly what we expected.

PostgreSQL – UNIQUE Constraint
Last Updated : 01 Jun, 2020
PostgreSQL provides the user with a UNIQUE constrain that is used to make sure that values stored in a column or a group of columns are unique across rows in a table. Every time the user inserts a new row, PostgreSQL checks if the value already exists in the table if UNIQUE constraints are used. If it discovers that the new value is already present, it denies the change and issues an error. A similar process is carried out for updating existing data.

Syntax: UNIQUE(column); or variable_name Data Type UNIQUE;
Now let’s look into some examples.

Example 1:
In this example we will create a new table named person with a UNIQUE constraint for the email column using the below command:

CREATE TABLE person (
    id serial PRIMARY KEY,
    first_name VARCHAR (50),
    last_name VARCHAR (50),
    email VARCHAR (50) UNIQUE
);
Now we will insert some data to the table using the below command:

INSERT INTO person(first_name, last_name, email)
VALUES
    (
        'Raju',
        'Kumar',
        'rajukumar@gmail.com'
    );
Now if we try to insert the same email, PostgreSQL should raise an error. So let’s do so.

INSERT INTO person(first_name, last_name, email)
VALUES
    (
        'Nikhil',
        'Aggarwal',
        'rajukumar@gmail.com'
    );
Output:

ERROR:  duplicate key value violates unique constraint "person_email_key"
DETAIL:  Key (email)=(rajukumar@gmail.com) already exists.


Example 2:
PostgreSQL also allows users to create a UNIQUE constraint to the first_name using the below commands:

CREATE TABLE person (
    id SERIAL  PRIMARY KEY,
    first_name VARCHAR (50),
    last_name  VARCHAR (50),
    email      VARCHAR (50),
        UNIQUE( first_name)
);
Now we will insert some data to the table using the below command:

INSERT INTO person(first_name, last_name, email)
VALUES
    (
        'Raju',
        'Kumar',
        'rajukumar@gmail.com'
    );
Now if we try to insert the same email, PostgreSQL should raise an error. So let’s do so.

INSERT INTO person(first_name, last_name, email)
VALUES
    (
        'Nikhil',
        'Aggarwal',
        'nikhilagg@gmail.com'
    ),
    (
        'Raju',
        'Verma',
        'rajuverma@gmail.com'
    );
This should raise an error for the first_name of Raju Verma as Raju Kumar already exists.
Output:

ERROR:  duplicate key value violates unique constraint "person_first_name_key"
DETAIL:  Key (first_name)=(Raju) already exists.



joins and schemas 

PostgreSQL – Joins
Last Updated : 28 Aug, 2020
A PostgreSQL Join statement is used to combine data or rows from one(self-join) or more tables based on a common field between them. These common fields are generally the Primary key of the first table and Foreign key of other tables.
There are 4 basic types of joins supported by PostgreSQL, namely:

Inner Join
Left Join
Right Join
Full Outer Join
Some special PostgreSQL joins are below:

Natural Join
Cross Join
Self Join
Let’s look into the 4 of the basic Joins in PostgreSQL.For the sake of this article, we will be setting up a sample database with the below commands in our psql shell:

Create a database zoo.
CREATE DATABASE zoo;
Create a table zoo_1.
CREATE TABLE zoo_1 (
    id INT PRIMARY KEY,
    animal VARCHAR (100) NOT NULL
);
Create a table zoo_2.
CREATE TABLE zoo_2 (
    id INT PRIMARY KEY,
    animal VARCHAR (100) NOT NULL
);
Insert data into zoo_1 table.
INSERT INTO zoo_1(id, animal)
VALUES
    (1, 'Lion'),
    (2, 'Tiger'),
    (3, 'Wolf'),
    (4, 'Fox');
Insert data into zoo_2 table.
INSERT INTO zoo_2(id, animal)
VALUES
    (1, 'Tiger'),
    (2, 'Lion'),
    (3, 'Rhino'),
    (4, 'Panther');
Now, we have two tables zoo_1 and zoo_2 with two common animals and four different animals. Let’s also assume zoo_1 is the left table.

Inner Join
The below statement joins the left table with the right table using the values in the “animal” column:

SELECT
    zoo_1.id id_a,
    zoo_1.animal animal_a,
    zoo_2.id id_b,
    zoo_2.animal animal_b
FROM
    zoo_1 
INNER JOIN zoo_2 ON zoo_1.animal = zoo_2.animal;
Output:


As seen in the above output, the inner join returns a result set that contains row in the left table that matches the row in the right table.

The Venn diagram for INNER JOIN is as below:


Left Join
The below statement joins the left table with the right table using left join (or left outer join):

SELECT
    zoo_1.id,
    zoo_1.animal,
    zoo_2.id,
    zoo_2.animal
FROM
    zoo_1
LEFT JOIN zoo_2 ON zoo_1.animal = zoo_2.animal;
Output:


As seen in the output above the left join returns a complete set of rows from the left table with the matching rows if available from the right table. If there is no match, the right side will have null values.

The Venn diagram for a LEFT JOIN is as below:


Right Join
The RIGHT JOIN or RIGHT OUTER JOIN works exactly opposite to the LEFT JOIN. It returns a complete set of rows from the right table with the matching rows if available from the left table. If there is no match, the left side will have null values.

The below statement joins the right table with the left table using the right join (or right outer join):

SELECT
    zoo_1.id,
    zoo_1.animal,
    zoo_2.id,
    zoo_2.animal
FROM
    zoo_1
RIGHT JOIN zoo_2 ON zoo_1.animal = zoo_2.animal;
Output:


The Venn diagram for a RIGHT OUTER JOIN is below:


Full Outer Join
The full outer join or full join returns a result set that contains all rows from both the left and right tables, with the matching rows from both sides where available. If there is no match, the missing side contains null values.

The below statement illustrates the full outer join:

SELECT
    zoo_1.id,
    zoo_1.animal,
    zoo_2.id,
    zoo_2.animal
FROM
    zoo_1
FULL JOIN zoo_2 ON zoo_1.animal = zoo_2.animal;
Output:


The Venn diagram for a FULL OUTER JOIN is below:


PostgreSQL – LEFT JOIN
Last Updated : 28 Aug, 2020
The PostgreSQL LEFT JOIN returns all the rows of the table on the left side of the join and matching rows for the table on the right side of the join. The rows for which there is no matching row on the right side, the result-set will contain null. LEFT JOIN is also known as LEFT OUTER JOIN.

Syntax:
SELECT table1.column1, table1.column2, table2.column1, ....
FROM table1 
LEFT JOIN table2
ON table1.matching_column = table2.matching_column;


table1: First table.
table2: Second table
matching_column: Column common to both the tables.
Let’s analyze the above syntax:

Firstly, using the SELECT statement we specify the tables from where we want the data to be selected.
Second, we specify the main table.
Third, we specify the table that the main table joins to.
The below Venn Diagram illustrates the working of PostgreSQL LEFT JOIN clause:


For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples.

Now, let’s look into a few examples.

Example 1:
Here we will use the LEFT JOIN clause to join the “film” table to the “inventory” table.

SELECT
    film.film_id,
    film.title,
    inventory_id
FROM
    film
LEFT JOIN inventory ON inventory.film_id = film.film_id;
Output:


Example 2:
Here we will use the LEFT JOIN clause to join the “film” table to the “inventory” table and use the WHERE clause to filter out films that are not in the inventory supply.

SELECT
    film.film_id,
    film.title,
    inventory_id
FROM
    film
LEFT JOIN inventory ON inventory.film_id = film.film_id
WHERE
    inventory.film_id IS NULL;
Output:


PostgreSQL – INNER JOIN
Last Updated : 19 Sep, 2023
In PostgreSQL the INNER JOIN keyword selects all rows from both the tables as long as the condition satisfies. This keyword will create the result-set by combining all rows from both the tables where the condition satisfies i.e value of the common field will be the same.

Syntax:
SELECT table1.column1, table1.column2, table2.column1, ....
FROM table1 
INNER JOIN table2
ON table1.matching_column = table2.matching_column;


table1: First table.
table2: Second table
matching_column: Column common to both the tables.
Let’s analyze the above syntax:

Firstly, using the SELECT statement we specify the tables from where we want the data to be selected.
Second, we specify the main table.
Third, we specify the table that the main table joins to.
The below Venn Diagram illustrates the working of PostgreSQL INNER JOIN clause:

For the sake of this article we will be using the sample DVD rental database, which is explained here .

Now, let’s look into a few examples.

Example 1:
Here we will be joining the “customer” table to “payment” table using the INNER JOIN clause.

SELECT
    customer.customer_id,
    first_name,
    last_name,
    email,
    amount,
    payment_date
FROM
    customer
INNER JOIN payment ON payment.customer_id = customer.customer_id;
Output:


Example 2:

Here we will be joining the “customer” table to “payment” table using the INNER JOIN clause and sort them with the ORDER BY clause:

SELECT
    customer.customer_id,
    first_name,
    last_name,
    email,
    amount,
    payment_date
FROM
    customer
INNER JOIN payment ON payment.customer_id = customer.customer_id
ORDER BY
    customer.customer_id;
Output:


Example 3:
Here we will be joining the “customer” table to “payment” table using the INNER JOIN clause and filter them with the WHERE clause:

SELECT
    customer.customer_id,
    first_name,
    last_name,
    email,
    amount,
    payment_date
FROM
    customer
INNER JOIN payment ON payment.customer_id = customer.customer_id
WHERE
    customer.customer_id = 15;

Output:


Example 4:
Here we will establish the relationship between three tables: staff, payment, and customer using the INNER JOIN clause.

SELECT
    customer.customer_id,
    customer.first_name customer_first_name,
    customer.last_name customer_last_name,
    customer.email,
    staff.first_name staff_first_name,
    staff.last_name staff_last_name,
    amount,
    payment_date
FROM
    customer
INNER JOIN payment ON payment.customer_id = customer.customer_id
INNER JOIN staff ON payment.staff_id = staff.staff_id;
Output:


PostgreSQL – FULL OUTER JOIN
Last Updated : 28 Aug, 2020
The PostgreSQL FULL OUTER JOIN or FULL JOIN creates the result-set by combining the result of both LEFT JOIN and RIGHT JOIN. The result-set will contain all the rows from both the tables. The rows for which there is no matching, the result-set will contain NULL values.

Syntax:
SELECT table1.column1, table1.column2, table2.column1, ....
FROM table1 
FULL JOIN table2
ON table1.matching_column = table2.matching_column;

or,

SELECT table1.column1, table1.column2, table2.column1, ....
FROM table1 
FULL OUTER JOIN table2
ON table1.matching_column = table2.matching_column;
table1: First table.
table2: Second table
matching_column: Column common to both the tables.
The Venn diagram for FULL OUTER JOIN is given below:


For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples.

Example 1:
Here we will make a query for all the films and the actors of the movie using the “film” table and “actor” table from our sample database.

SELECT
    title,
    first_name,
        last_name
FROM
    film f
FULL OUTER JOIN actor a 
        ON a.actor_id = f.film_id;
Output:


Example 2:
Here we will make a query for all the films and the language of the movie using the “film” table and “language” table from our sample database.

SELECT
    title,
    name
FROM
    film f
FULL OUTER JOIN language l 
        ON l.language_id = f.film_id;
Output:


PostgreSQL – Schema
Last Updated : 28 Aug, 2020
In PostgreSQL, a schema is a namespace that contains named database objects such as tables, views, indexes, data types, functions, and operators.
To access an object of a schema, users need to qualify its name with the schema name as a prefix as shown below:

Syntax: schema_name.object_name
A database can contain one or multiple schemas while each schema belongs to only one database. Two schemas can have different objects that share the same name. For instance, you may have a sales schema that has a staff table and the public schema which also has the staff table. When you refer to the staff table you must qualify it as follows:

public.staff

or,

sales.staff
There are various scenario where schemas need to be used:

Schemas allow users to organize database objects e.g., tables into logical groups to make them more manageable.
Schemas enable multiple users to use one database without interfering with each other.
Public schema
PostgreSQL generates a schema named public for all databases. Whatever object users create without specifying the schema name, PostgreSQL will automatically put it into this public schema. Therefore, the following statements are equal:

CREATE TABLE table_name(...);

and

CREATE TABLE public.table_name(...);
Schemas and Privileges
Users can only access objects in the schemas that they own. It means they cannot access any object in the schemas, which does not belong to them. To enable users to access the objects in the schema that they do not own, you must grant the USAGE privilege to the users on the schema as shown in the following statement:

GRANT USAGE ON SCHEMA schema_name TO user_name;
To allow users to create objects in the schema that they do not own, you need to grant them the CREATE privilege on the schema.

GRANT CREATE ON SCHEMA schema_name TO user_name;
Note: By default, every user has the CREATE and USAGE on the public schema.

Schema Operations
The below operations is allowed by PostgreSQL:

To create a new schema, you use the CREATE SCHEMA statement.
To rename a schema or change its owner, you use the ALTER SCHEMA statement.
To drop a schema, you use the DROP SCHEMA statement.


PostgreSQL – CREATE SCHEMA
Last Updated : 28 Aug, 2020
PostgreSQL has a CREATE SCHEMA statement that is used to create a new schema in a database.

Syntax:
CREATE SCHEMA [IF NOT EXISTS] schema_name;
Let’s analyze the above syntax:

First, specify the name of the schema after the CREATE SCHEMA keywords. The schema name must be unique within the current database.
Second, optionally use IF NOT EXISTS to conditionally create the new schema only if it does not exist. Attempting to create a new schema that already exists without using the IF NOT EXISTS option will result in an error.
Note: To execute the CREATE SCHEMA statement, you must have the CREATE privilege in the current database.
To create a schema for a user use the following:

Syntax:
CREATE SCHEMA [IF NOT EXISTS] AUTHORIZATION user_name;
Now that we have known the basics of creating a schema in PostgreSQL, let’s jump into some examples.

Example 1:
The following statement uses the CREATE SCHEMA statement to create a new schema named marketing:

CREATE SCHEMA IF NOT EXISTS marketing;
The following statement returns all schemas from the current database:

SELECT 
  * 
FROM 
    pg_catalog.pg_namespace
ORDER BY 
    nspname;
Output:


Example 2:
In this example, we will create a schema for a user (say, Raju). to do show let’s first create a user using the below statement:

CREATE USER Raju WITH ENCRYPTED PASSWORD 'Postgres123';
Now create a schema for the user Raju as follows:

CREATE SCHEMA AUTHORIZATION Raju;
Third, create a new schema that will be owned by Raju:

CREATE SCHEMA IF NOT EXISTS geeksforgeeks AUTHORIZATION Raju;
The following statement returns all schemas from the current database:

SELECT 
  * 
FROM 
    pg_catalog.pg_namespace
ORDER BY 
    nspname;
Output:



PostgreSQL – DROP SCHEMA
Last Updated : 28 Aug, 2020
PostgreSQL also supports the deletion of a schema and its objects using the DROP SCHEMA statement.

Syntax: DROP SCHEMA [IF EXISTS] schema_name [ CASCADE | RESTRICT ];
Let’s analyze the above syntax:

First, specify the name of the schema from which you want to remove after the DROP SCHEMA keywords.
Second, use the IF EXISTS option to conditionally to delete schema only if it exists.
Third, use CASCADE to delete schema and all of its objects, and in turn, all objects that depend on those objects. If you want to delete schema only when it is empty, you can use the RESTRICT option. By default, PostgreSQL uses RESTRICT.
To execute the DROP SCHEMA statement, you must be the owner of the schema that you want to drop or a superuser. PostgreSQL also allows you to drop multiple schemas at the same time by using a single DROP SCHEMA statement.
Now let’s look into some examples.

Example 1:
This example uses the DROP SCHEMA statement to remove the marketing schema present in our database:

DROP SCHEMA IF EXISTS marketing;
To verify so use the below statement:

SELECT * FROM  pg_catalog.pg_namespace ORDER BY nspname;
Output:


Example 2:
The following example uses the DROP SCHEMA statement to drop multiple schemas gfg and Raju using a single statement:

DROP SCHEMA IF EXISTS gfg, raju;
To verify so use the below statement:

SELECT * FROM  pg_catalog.pg_namespace ORDER BY nspname;
Output:


roles and permissions 


PostgreSQL – CREATE ROLE
Last Updated : 28 Aug, 2020
PostgreSQL uses roles to represent user accounts. It doesn’t use the user concept like other database systems. Typically, roles can log in are called login roles. They are equivalent to users in other database systems. When roles contain other roles, they are called group roles. When you create a role, it is valid in all databases in the database server (or cluster).

To create a new role, you use the CREATE ROLE statement as follows:

Syntax: CREATE ROLE role_name;
To get all roles in the current PostgreSQL database server, you can query them from the pg_roles system catalog as follows:

Syntax: SELECT rolname FROM pg_roles;
This will result in the following:



If one uses the psql tool, one can use the \du command to list all existing roles in the current PostgreSQL database server:

Syntax: \du
It will behave as shown below:



Role attributes
The attributes of a role define privileges for that role including login, superuser, database creation, role creation, password, etc:

Syntax: CREATE ROLE name WITH option;
In this syntax, the WITH keyword is optional. And the option can be one or more attributes including SUPER, CREATEDB, CREATEROLE, etc.

1. Create login roles
The following statement creates a role called ‘Raju’ that has the login privilege and an initial password:

CREATE ROLE raju
LOGIN 
PASSWORD 'mypassword1';
Note: It is required to place the password in single quotes (‘).

Now verify the role using the below command:

\du
The role creation is successful as shown below:



2. Create superuser roles
The following statement creates a role called ‘Nikhil’ that has the superuser attribute:

CREATE ROLE Nikhil
SUPERUSER 
LOGIN 
PASSWORD 'mypassword1';
This will lead to the following:



The superuser can override all access restrictions within the database therefore you should create this role only when needed.

Note: One must be a superuser in order to create another superuser role.

3. Create roles that can create databases
If you want to create roles that have the database creation privilege, you use the CREATEDB attribute:

CREATE ROLE dba 
CREATEDB 
LOGIN 
PASSWORD 'Abcd1234';
This will lead to the following:



4. Create roles with validity period
To set a date and time after which the role’s password is no longer valid, you use the valid until attribute:

VALID UNTIL 'timestamp'
Example:

CREATE ROLE dev_api WITH
LOGIN
PASSWORD 'securePass1'
VALID UNTIL '2030-01-01';
Output:



5. Create roles with connection limit
To specify the number of concurrent connections a role can make, you use the CONNECTION LIMIT attribute:

CONNECTION LIMIT connection_count
The following creates a new role called API that can make 1000 concurrent connections:

CREATE ROLE api
LOGIN
PASSWORD 'securePass1'
CONNECTION LIMIT 1000;
This will create a new role as follows:



The following psql command shows all the roles that we have created so far:

\du
This will show you the results as depicted below:



PostgreSQL – ALTER ROLE
Last Updated : 10 Feb, 2021
In PostgreSQL, the ALTER ROLE statement is used to manage and modify roles. It can be used to modify the name of a role, the attributes of a role, and alter a role’s session default for a configuration variable.

Syntax: ALTER ROLE role_name [WITH] option;
The following functions are available with ALTER ROLE statement:

SUPERUSER | NOSUPERUSER – It is used to determine if the role is a superuser.
VALID UNTIL ‘timestamp’ – It is used to specify the expiry date and time of a role’s password.
CREATEDB | NOCREATEDB– It is used to provide permissions to a role for creating new databases.
REPLICATION | NOREPLICATION – It is used to check if a role is a replication role.
CREATEROLE | NOCREATEROLE –It is used to provide permissions to a role for creating or modifying roles.
PASSWORD ‘password’ | PASSWORD NULL – It is used to change a role’s password.
INHERIT | NOINHERIT – It is used to determine if the inherited role has all the inherited privileges of the parent role.
BYPASSRLS | NOBYPASSRLS – It is used to check if a role can bypass a row-level security (RLS) policy.
LOGIN | NOLOGIN – As the name suggests itself, it is used to allow the role to log in.
CONNECTION LIMIT limit – It is used to set the number of concurrent connections that a role can make. Here -1 means the role can create an unlimited number of rows.
The following are the set of rules that must be followed while using the ALTER ROLE statement:

Superusers can modify the attributes for any role.
Only non-superusers and no-replication roles can be modified is a role has CREATE ROLE attribute to it.
Ordinal roles can only change their passwords.
Example:

First, log in to the PostgreSQL using the Postgres role.

Now, create a new role called ‘Ravi’ using the CREATE ROLE statement:

create role ravi login password 'geeks12345';
Now modify the role of ravi to be a superuser using the below statement:

alter role ravi superuser;
To view the role use the following command:

\du ravi
Output:



PostgreSQL – DROP ROLE
Last Updated : 16 Oct, 2021
In PostgreSQL the DROP ROLE statement to remove a role.

Syntax: DROP ROLE [IF EXISTS] target_role;
Let’s analyze the above syntax:

After the DROP ROLE keywords add the role name that is to be deleted.
Use the IF EXISTS option can be used to issue a notice instead of an error when a request to remove a role that does not exist is made.
it is important to note that to remove a superuser role, one needs to be a superuser. To remove a non-superuser roles, you will need the privilege to create a role using the CREATE ROLE statement. If we accidentally try to remove a role that has been referenced in any database, PostgreSQL raises an error. In this case, one has to take two steps:

You either need to remove the database objects owned by that particular role using the DROP OWNED statement or reassign the ownership of the database objects to another role using the REASSIGN OWNED statement.
You will also be needing to revoke all other permissions granted to the role.
In other words, follow the below statements exactly as shown to drop a role:

REASSIGN OWNED BY target_role TO another_role;
DROP OWNED BY target_role;


DROP ROLE target_role;
Example:

In this example:

Here, we will create a new role called geeksforgeeks and use this role to create a table named employees.
Then, we will show the step by step guide on how to remove the role geeksforgeeks from the PostgreSQL database server.
First, log in to PostgreSQL using the Postgres role:

psql -U postgres
Second, create a new role called geeksforgeeks using the below statement:

create role geeksforgeeks with login password 'geeks12345';
Third, grant createdb privilege to geeksforgeeks using the below statements:

alter role geeksforgeeks createdb;
Fourth, create a new database called sales:

create database sales;
Now, login to the PostgreSQL database server using the geeksforgeeks role as shown below:

psql -U geeksforgeeks -W sales
Add a new table to the Sales database:

create table employee(
    customer_id int generated always as identity,
    customer_name varchar(150) not null,
    primary key(employee_id)
);
Now show the list of tables in the sales database using the below command:

\du
This will show you the following result:



Now log in as Postgres and attempt to drop the geeksforgeeks role:

drop role geeksforgeeks;
Output:



PostgreSQL – GRANT
Last Updated : 09 Jan, 2023
In PostgreSQL, the GRANT statement is used to grant privileges to a role to alter on database objects like tables, views, functions, etc.

The following shows the syntax of the GRANT statement:

Syntax:
GRANT privilege_list | ALL 
ON  table_name
TO  role_name;
Let’s analyze the above syntax:

Some elements of the privilege_list are SELECT, INSERT, UPDATE, DELETE, TRUNCATE, etc. The ALL option to grant all available privileges to a role.
It is required to mention the name of the table after the ON keyword.
The next step is to mention the name of the role to be granted the privileges.
Example:

Create a role called ‘Anshul’ that can login to the PostgreSQL database server as shown below:

create role anshul
login 
password 'geeks12345';
Now create a table called candidate as below:

create table Players (
    player_id int generated always as identity,
    first_name varchar(100) not null,
    last_name varchar(100) not null,
    email varchar(255) not null unique,
    phone varchar(25) not null,
    primary key(player_id)
);
Now, use the role ‘Anshul’ to log in to the PostgreSQL database server separately and try to select data from the players table from the Anshul’s session:

SELECT * FROM players;
Here PostgreSQL will raise an error as shown below:

ERROR:  permission denied for table players
To grant the SELECT privilege on the players table to the role anshul, the GRANT statement can be executed in the postgres‘ session as shown below:

GRANT SELECT 
ON players
TO anshul;
Now, execute the SELECT statement from the anshul’s session:

SELECT * FROM players;
Seventh, execute the following INSERT statement;

INSERT INTO players(first_name, last_name, email, phone)
VALUES('raju', 'kumar', 'raju.kumar@geeksforgeeks.org', '408-111-2222');
PostgreSQL issued the following error because anshul does not have the INSERT privilege on the players table:

ERROR:  permission denied for table players
Now, grant INSERT, UPDATE, and DELETE privileges on the candidates table to the role anshul:

GRANT INSERT, UPDATE, DELETE
ON players
TO anshul;
Ninth, execute the INSERT statement again from the anshul’s session:

INSERT INTO players(first_name, last_name, email, phone)
VALUES('raju', 'kumar', 'raju.kumar@gmail.com', '408-111-2222');
Now, anshul can insert data into the players table. In addition to that the Anshul role can update or delete data from the table.

Output:



PostgreSQL – REVOKE
Last Updated : 17 Aug, 2021
In PostgreSQL, the REVOKE statement is used to revoke previously granted privileges on database objects through a role.

The following shows the syntax of the REVOKE statement:

Syntax: 
REVOKE privilege | ALL
ON TABLE tbl_name |  ALL TABLES IN SCHEMA schema_name
FROM role_name;
Let’s analyze the above syntax:

First, specify the privileges that is to be revoked. Use the ALL option to revoke all previously granted privileges.
Then, set the name of the table after the ON keyword.
Finally, specify the name of the role whose privileges is to be revoked.
Example:

First,log into the dvdrental sample database as Postgres:

psql -U postgres -d dvdrental
Now initialize a role called ‘abhishek’ with the LOGIN and PASSWORD attributes as shown below:

CREATE ROLE abhishek
LOGIN 
PASSWORD 'geeks12345';
Now grat all privileges on the film table to the role ‘abhishek’ as shown below:

GRANT ALL 
ON film
TO abhishek;
Now provide the SELECT privilege on the actor table to the role ‘abhishek’ as shown below:

GRANT SELECT
ON actor
TO abhishek;
Here we will revoke the SELECT privilege on the actor table from the role ‘abhishek’, as shown below:

REVOKE SELECT
ON actor
FROM abhishek;
If you wish to revoke all privileges on the film table from the role ‘abhishek’, make use of theREVOKE statement with the ALL option as shown below:

REVOKE ALL
ON film
FROM abhishek;
Output:



operators 

PostgreSQL – UNION operator
Last Updated : 28 Aug, 2020
The PostgreSQL UNION operator is used to combine result sets of multiple queries into a single set of result. It is used to combine result sets of two or more SELECT statements into a single result set.

Syntax:
SELECT
    column_1,
    column_2
FROM
    table_name_1
UNION
SELECT
    column_1,
    column_2
FROM
    table_name_2;
The below rules need to be followed while using a UNION operator:

Both queries must return the same number of columns.
The corresponding columns in the queries must have compatible data types.
Note: The UNION operator removes all duplicate rows from the query set.

Let’s look into some examples of the UNION operator by setting up two sample tables in a sample database(say, sales2020). Let’s say table “sales2020q1” represents the sales of a particular product in the first quarter of 2020 and “sales2020q2” represents the sales in the second quarter of the same year. Now let’s set up the database following the below procedures:

Create the sales2020 database using the below command:
CREATE DATABASE sales2020;
Now add two tables namely sales2020q1 and sales2020q2 to the sales2020 database using the below commands:
CREATE TABLE sales2020q1(
    id SERIAL,
    name VARCHAR(50) NOT NULL,
    amount VARCHAR(50),
    PRIMARY KEY (id)
);
CREATE TABLE sales2020q2(
    id SERIAL,
    name VARCHAR(50) NOT NULL,
    amount VARCHAR(50),
    PRIMARY KEY (id)
);
Insert data into tables using the below commands:
INSERT INTO sales2020q1(name, amount)
VALUES
    ('Raju Kumar', '121232'),
    ('Nikhil Aggarwal', '254789'),
    ('Abhishek Kelenia', '365487');

INSERT INTO sales2020q2(name, amount)
VALUES
    ('Raju Kumar', '457264'),
    ('Nikhil Aggarwal', '365241'),
    ('Abhishek Kelenia', '759864');
Now that our sample database is ready. Let’s implement the UNION operator in a few examples.

Example 1:
Here we will use the UNION operator to combine data from both sales2020q1 and salese2020q2 tables.

SELECT *
FROM
    sales2020q1
UNION
SELECT *
FROM
    sales2020q2;
Output:


Example 2:
Here we will sort the combined result returned by the UNION operator in defending order of “id” by using the ORDER BY clause after combining the data from both sales2020q1 and salese2020q2 tables.

SELECT *
FROM
    sales2020q1
UNION ALL
SELECT *
FROM
    sales2020q2
ORDER BY 
 name ASC,
 amount DESC;
Output:



PostgreSQL – INTERSECT Operator
Last Updated : 04 Sep, 2021
PostgreSQL has an INTERSECT operator that is used to combine two or more result sets returned by the SELECT statement and provide with the common data among the tables into a single result set. 

Syntax:
SELECT
    column_list
FROM
    A
INTERSECT
SELECT
    column_list
FROM
    B;
The below rules must be followed while using the INTERSECT operator with the SELECT statement:  

The number of columns and their order in the SELECT clauses must be the same. 
The data types of the columns must be compatible. 
The Venn diagram of an INTERSECT operator in PostgreSQL is as below: 



Now let’s set up a sample database to observe the implementation of the INTERSECT operator. We will create a sample database for RAW employees(say, raw_agents) and set up three tables namely agent, op_chi (operational in CHINA), and op_pak (operational in Pakistan). To do so follow the below procedures: 

Create the database using the below command: 
CREATE DATABASE raw_agents;
Create table employees, op_CHI and op_PAK using the below commands: 
CREATE TABLE agent(
    agent_id serial PRIMARY KEY,
    agent_name VARCHAR (255) NOT NULL
);
CREATE TABLE op_chi(
    agent_id INT PRIMARY KEY,
    active_date DATE NOT NULL,
    FOREIGN KEY (agent_id) REFERENCES agent (agent_id)
);
CREATE TABLE op_pak(
    agent_id INT PRIMARY KEY,
    active_date DATE NOT NULL,
    FOREIGN KEY (agent_id) REFERENCES agent (agent_id)
);
Insert active date to the tables with the name of agents with the below commands: 
INSERT INTO agent(agent_name)
VALUES
    ('Tiger'),
    ('James Bond'),
    ('Jason Bourne'),
    ('Ethan Hunt'),
    ('Ajit Doval'),
    ('Rowdy Rathore'),
    ('Milkha Singh'),
    ('Tom Hanks'),
    ('Sabana'),
    ('Razia Sultan');

INSERT INTO op_chi
VALUES
    (1, '2000-02-01'),
    (2, '2001-06-01'),
    (5, '2002-01-01'),
    (7, '2005-06-01');

INSERT INTO op_pak
VALUES
    (9, '2000-01-01'),
    (2, '2002-06-01'),
    (5, '2006-06-01'),
    (10, '2005-06-01');
Now that our database is all set, let’s look into some examples. 

Example 1: 

Here we will query for “agent_id” of agents who have been active both in Pakistan and China using the INTERSECT operator. 

SELECT
    agent_id
FROM
    op_CHI
INTERSECT
SELECT
        agent_id
FROM
    op_PAk;
Output: 



Example 2: 

Here we will query for “agent_id” of agents who have been active both in Pakistan and China using the INTERSECT operator and use the ORDER BY clause to sort them by ascending “agent_id”. 

SELECT
    agent_id
FROM
    op_CHI
INTERSECT
SELECT
        agent_id
FROM
    op_PAk
ORDER BY
        agent_id;
Output: 



PostgreSQL – EXCEPT Operator
Last Updated : 28 Aug, 2020
In PostgreSQL, the EXCEPT operator is used to return distinct rows from the first (left) query that are not in the output of the second (right) query while comparing result sets of two or more queries.

Syntax:
SELECT column_list
FROM A
WHERE condition_a
EXCEPT 
SELECT column_list
FROM B
WHERE condition_b;
The below rules must be obeyed while using the EXCEPT operator:

The number of columns and their orders must be the same in the two queries.
The data types of the respective columns must be compatible.
The below Venn diagram illustrates the result of EXCEPT operator:


For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples.

Example 1:
Here we will query for films that are not in the inventory using EXCEPT operator from data of the “film” and “inventory” tables of our sample database and sort them using ORDER BY clause based on the film title.

SELECT
    film_id,
    title
FROM
    film
EXCEPT
    SELECT
        DISTINCT inventory.film_id,
        title
    FROM
        inventory
    INNER JOIN film ON film.film_id = inventory.film_id
ORDER BY title;
Output:


Example 2:
Here we will query for films that are only in the English Language (ie, language_id = 1) using EXCEPT operator from data of the “film” and “language” tables of our sample database and sort them using the ORDER BY clause based on the film title.

SELECT
    language_id,
    title
FROM
    film
WHERE
        language_id = 1
EXCEPT
    SELECT
        DISTINCT language.language_id,
        name
    FROM
        language
    INNER JOIN film ON film.language_id = language.language_id
ORDER BY title;;
Output:


PostgreSQL – ANY Operator
Last Updated : 28 Aug, 2020
PostgreSQL has an ANY operator that is used to compare a scalar value with a set of values returned by a subquery.

Syntax: expression operator ANY(subquery)
The below rules must be followed while using PostgreSQL ANY operator:

The subquery must return exactly one column.
The ANY operator must be preceded by one of the following comparison operator =, <=, >, <, > and <>
The ANY operator returns true if any value of the subquery meets the condition, otherwise, it returns false.
For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples.

Example 1:
Here we will query for the maximum length of film grouped by film category from the “film” table of our sample database.

SELECT title
FROM film
WHERE length >= ANY(
    SELECT MAX( length )
    FROM film
    INNER JOIN film_category USING(film_id)
    GROUP BY  category_id );
Output:



Example 2:
Here we will query for the films whose category is either Action(category_id = 1) or Drama(category_id = 7) from the “category” table of our sample database.

SELECT
    title,
    category_id
FROM
    film
INNER JOIN film_category
        USING(film_id)
WHERE
    category_id = ANY(
        SELECT
            category_id
        FROM
            category
        WHERE
            NAME = 'Action'
            OR NAME = 'Drama'
    );
Output:


PostgreSQL – ALL Operator
Last Updated : 28 Aug, 2020
The PostgreSQL ALL operator is used for comparing a value with a list of values returned by a subquery.

Syntax: comparison_operator ALL (subquery)
The below rules need to be followed while using the ALL operator:

The ALL operator always needs to be preceded by a comparison operator(=, !=, <, >, >=, <=).
It must always be followed by a subquery surrounded by parentheses.
For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples.

Example 1:
Here we will query for all films whose lengths are greater than the list of the average lengths by using the ALL and greater than operator(>).

SELECT
    film_id,
    title,
    length
FROM
    film
WHERE
    length > ALL (
            SELECT
                ROUND(AVG (length), 2)
            FROM
                film
            GROUP BY
                rating
    )
ORDER BY
    length;
Output:


Example 2:

Here we will query for all films whose rental_rate is less than the list of the average rental_rate by using the ALL and less than operator(<).

SELECT
    film_id,
    title,
    rental_rate
FROM
    film
WHERE
    rental_rate < ALL (
            SELECT
                ROUND(AVG (rental_rate), 2)
            FROM
                film
            GROUP BY
                rating
    )
ORDER BY
    rental_rate;

Output:




PostgreSQL – EXISTS Operator
Last Updated : 18 Apr, 2023
In PostgreSQL, the EXISTS operator is used to test for the existence of rows in a subquery.It is generally used with correlated subqueries. If the subquery returns at least one row, the result of EXISTS is true. In case the subquery returns no row, the result is of EXISTS is false.

Syntax: EXISTS (subquery)
For the sake of this article we will be using the sample DVD rental database, which is explained here and can be downloaded by clicking on this link in our examples. 

Example 1: Here we will query for customers who have at least one payment whose amount is greater than 9 USD using the “customer” and “payment” tables of our sample database.

SELECT first_name,
       last_name
FROM customer c
WHERE EXISTS
    (SELECT 1
     FROM payment p
     WHERE p.customer_id = c.customer_id
       AND amount > 9 )
ORDER BY first_name,
         last_name;
Output:

  

Example 2: Here we will query for films that are not available in the inventory using the “film” and “inventory” tables of our sample database.

SELECT title
FROM film f
WHERE NOT EXISTS
    (SELECT 1
     FROM inventory i
     WHERE f.film_id = i.film_id )
ORDER BY title;
Output:

 

postgre functions 

PostgreSQL – CREATE FUNCTION Statement
Last Updated : 28 Aug, 2020
In PostgreSQL CREATE FUNCTION statement to develop user-defined functions.

Syntax:
create [or replace] function function_name(param_list)
   returns return_type 
   language plpgsql
  as
$$
declare 
-- variable declaration
begin
 -- logic
end;
$$
Let’s analyze the above syntax:

First, specify the name of the function after the create function keywords. If you want to replace the existing function, you can use the replace keywords.
Then, specify the function parameter list surrounded by parentheses after the function name. A function can have zero or many parameters.
Next, specify the datatype of the returned value after the returns keyword.
After that, use the language plpgsql to specify the procedural language of the function. Note that PostgreSQL supports many procedural languages, not just plpgsql.
Finally, place a block in the dollar-quoted string constant.
For the purpose of example, we will use the sample database ie, dvdrental.

Example:

The following statement creates a function that counts the films whose length between the len_from and len_to parameters:

create function get_film_count(len_from int, len_to int)
returns int
language plpgsql
as
$$
declare
   film_count integer;
begin
   select count(*) 
   into film_count
   from film
   where length between len_from and len_to;
   
   return film_count;
end;
$$;
The function get_film_count has two main sections: header and body. 

In the Header section:

First, the name of the function is get_film_count that follows the create function keywords.
Second, the get_film_count() function accepts two parameters len_from and len_to with the integer datatype.
Third, the get_film_count function returns an integer specified by the returns int clause
Finally, the language of the function is plpgsql indicated by the language plpgsql.
In the Body section:

Use the dollar-quoted string constant syntax that starts with $$ and ends with $$. Between these $$, you can place a block that contains the declaration and logic of the function.
In the declaration section, declare a variable called film_count that stores the number of films selected from the film table.
In the body of the block, use the select into statement to select the number of films whose length is between len_from and len_to and assign the result to the film_count variable. At the end of the block, use the return statement to return the film_count.
Now that we got familiar with the structure of the CREATE FUNCTION statement, let’s create a function using the same.

First, launch the psql interactive tool and connect to the dvdrental database and enter the above code in the psql to create the function like this:

create function get_film_count(len_from int, len_to int)
 returns int
 language plpgsql
 as
 $$
 declare
    film_count integer;
 begin
   select count(*)
    into film_count
   from film
   where length between len_from and len_to;

   return film_count;
 end;
$$;
You will see the following message if the function is created successfully as shown below:



Finally, use the below command to list all user-defined in the current database:

\df
This will show you all the user-defined functions in the database as shown below:



PostgreSQL – Function Overloading
Last Updated : 28 Aug, 2020
PostgreSQL allows more than one function to have the same name, so long as the arguments are different. If more than one function has the same name, we say those functions are overloaded. When a function is called, PostgreSQL determines the exact function is being called based on the input arguments.

Let’s take a look at the following get_rental_duration() function applied to the sample dvdrental database.

CREATE OR REPLACE FUNCTION get_rental_duration(p_customer_id INTEGER)
    RETURNS INTEGER AS $$
    
DECLARE 
    rental_duration INTEGER; 
BEGIN
    -- get the rate based on film_id
    SELECT INTO rental_duration SUM( EXTRACT( DAY FROM return_date - rental_date)) 
    FROM rental 
    WHERE customer_id=p_customer_id;

    RETURN rental_duration;
END; $$
LANGUAGE plpgsql;
The get_rental_function accepts p_customer_id as the argument. It returns the sum of duration (in days) that a specific customer rented DVDs. For example, we can get the rental duration of the customer with customer id 278, we call the get_rental_duration function as follows:

SELECT get_rental_duration(278);
It returns the following:



Suppose, we want to know the rental duration of a customer from a specific date up to now. We can add one more parameter p_from_date to the get_rental_duration() function, or we can develop a new function with the same name but have two parameters as follows:

CREATE OR REPLACE FUNCTION get_rental_duration(p_customer_id INTEGER, p_from_date DATE)
    RETURNS INTEGER AS $$
DECLARE 
    rental_duration integer;
BEGIN
    -- get the rental duration based on customer_id and rental date
    SELECT INTO rental_duration
                SUM( EXTRACT( DAY FROM return_date + '12:00:00' - rental_date)) 
    FROM rental 
    WHERE customer_id= p_customer_id AND 
          rental_date >= p_from_date;
     
    RETURN rental_duration;
END; $$
LANGUAGE plpgsql;
This function has the same name as the first one except that it has two parameters. We say the function is overloaded by the get_rental_duration(integer, date) function. The following statement gets the rental duration of the customer with customer id 278 since July 1st, 2005:

SELECT get_rental_duration(278, '2005-07-01');
It will result in the following:




PostgreSQL – Drop Function
Last Updated : 28 Aug, 2020
In PostgreSQL, the Drop function statement is used to remove a function.

Syntax:
drop function [if exists] function_name(argument_list)
[cascade | restrict]
Let’s analyze the above syntax:

First, specify the name of the function that you want to remove after the drop function keywords.
Second, use the if exists option if you want to instruct PostgreSQL to issue a notice instead of an error in case the function does not exist.
Third, specify the argument list of the function. Since functions can be overloaded PostgreSQL needs to know which function you want to remove by checking the argument list. If a function is unique within the schema, you do not need to specify the argument list.
When a function has any dependent objects such as operators or triggers, you cannot drop that function. To drop the function and its dependent objects, you need to specify the cascade option. The drop function with the cascade option will recursively remove the function, its dependent objects, and the objects that depend on those objects, and so on.

By default, the drop function statement uses the restrict option that rejects the removal of a function when it has any dependent objects. To drop multiple functions using a single drop function statement, you specify a comma-separated list of function name after the drop function keyword like this:

drop function [if exists] function1, function2, ...;
For the sake of example, we will use the sample database ie, dvdrental.

Example :

The following statement uses the create function statement to define a function that returns a set of films including film_id, title, and actor:

create or replace function get_film_actors()
    returns setof record
as $$
declare
   rec record;
begin
   for rec in select 
            film_id, 
            title, 
            (first_name || ' ' || last_name)::varchar
        from film
        inner join film_actor using(film_id)
        inner join actor using (actor_id)
        order by title
    loop
        return next rec;
    end loop;
    
    return;
end;
$$ 
language plpgsql;
The following statement defines a function with the same name get_film_actors. However, it accepts a film id as the argument:

create or replace function get_film_actors(p_fiml_id int)
    returns setof record
 as $$
declare
 rec record;
begin
for rec in select 
film_id, 
title, 
            (first_name || ' ' || last_name)::varchar
        from film
 inner join film_actor using(film_id)
        inner join actor using (actor_id)
        where film_id = p_fiml_id
 order by title
    loop
 return next rec;
    end loop;

    return;
end;
$$ 
language plpgsql;
The following statement attempts to drop the get_film_actors function:

drop function get_film_actors;
Output:



Since the get_film_actors stored procedure is not unique, you need to specify which function you want to drop.

The following statement drops the get_film_actors function that has zero parameters:

drop function get_film_actors();
Now, there is only one get_film_actors function left. Since it is unique in the database, you can drop it without specifying its argument list like this:

drop function get_film_actors;
Or if you want to specify the exact function, you can use the following statement:

drop function get_film_actors(int);
Conclusion:
Use the drop function statement to remove a function.
Specify the argument list in the function if the function is overloaded.
Use the drop function statement with the cascade option to drop a function and its dependent objects and objects that depends on those objects, and so on.


PostgreSQL – MAX() Function
Last Updated : 01 Jun, 2020
PostgreSQL MAX() function is an aggregate function that returns the maximum value in a set of values.

Syntax: MAX(expression);
The MAX() function can be used with SELECT, WHERE and HAVING clause.

Now let’s look into some examples.For examples we will be using the sample database (ie, dvdrental).
Example 1:
The below query gets us the maximum amount paid by customers in the payment table:

SELECT MAX(amount)
FROM payment;
Output:


Example 2:
The following query gets the largest payment paid by each customer:

SELECT
    customer_id,
    MAX (amount)
FROM
    payment
GROUP BY
    customer_id;
Output:



PostgreSQL – MIN() Function
Last Updated : 01 Jun, 2020
PostgreSQL MIN() function is an aggregate function that returns the minimum value in a set of values.

Syntax: MIN(expression);
The MIN() function can be used with SELECT, WHERE and HAVING clause.

Now let’s look into some examples.For examples we will be using the sample database (ie, dvdrental).
Example 1:
The below query gets us the minimum amount paid by customers in the payment table:

SELECT MIN(amount)
FROM payment;
Output:


Example 2:
The following query gets the smallest payment paid by each customer:

SELECT
    customer_id,
    MIN(amount)
FROM
    payment
GROUP BY
    customer_id;
Output:




PostgreSQL – SUM() Function
Last Updated : 01 Jun, 2020
PostgreSQL provides with a SUM() function that is used to get the addition of values of a numeric column.

Syntax: SUM(column)
The following points needs to be kept in mind while using the above function:

It ignores all NULL values.
If used with DISTINCT operator as SUM(DISTINCT column), it skips duplicate values.
Using SUM() function with SELECT clause returns NULL instead of Zero.
For examples we will be using the sample database (ie, dvdrental).

Example 1:
In this example we will calculate the total amount paid by each customer using the SUM() function and GROUP BY clause as follows:

SELECT
    customer_id,
    SUM (amount) AS total
FROM
    payment
GROUP BY
    customer_id;
Output:


Example 2:
In this example we will query for the top 10 customers who paid the most as follows:

SELECT
    customer_id,
    SUM (amount) AS total
FROM
    payment
GROUP BY
    customer_id
ORDER BY total DESC
LIMIT 10;
Output:



PostgreSQL – COUNT() Function
Last Updated : 01 Jun, 2020
The COUNT() function is an aggregate function that enables users to get the number of rows that match a particular requirement of a query.
Depending upon the user requirements the COUNT() function can have the following syntaxes:

Syntax: COUNT(*)
Returns: All rows including NULL and Duplicates

Syntax: COUNT(column)
Returns:  All rows except NULL.

Syntax: COUNT(DISTINCT column)
Returns: All rows without NULL and Duplicates
The COUNT() function is used with the SELECT statement.

For examples we will be using the sample database (ie, dvdrental).
Example 1:
In this example we will use the COUNT(*) function to get the number of transactions in the payment table using the command below:

SELECT
   COUNT(*)
FROM
   payment;
Output:


Example 2:
In this example we will query for the distinct amounts which customers paid, using the COUNT(DISTINCT column) function as shown below:

SELECT
    COUNT (DISTINCT amount)
FROM
    payment;
Output:


Example 3:
Here we will be using the COUNT() function to get the details of customers who have made more than 40 payments:

SELECT
    customer_id,
    COUNT (customer_id)
FROM
    payment
GROUP BY
    customer_id
HAVING
    COUNT (customer_id) > 40;
Output:


PostgreSQL – EXTRACT Function
Last Updated : 07 Oct, 2021
The PostgreSQL EXTRACT() function is used to query for field associated with date and time such as a year, month, and day from a date/time value.

Syntax: EXTRACT(field FROM source)
Let’s analyze the above syntax:

In the above syntax the field argument is used to specify fields that is to be extracted from the date/time value.
The source is generally either a TIMESTAMP type or an INTERVAL type. Depending upon the values passed the type is set. For instance, if we pass a DATE value, the function adapt to a TIMESTAMP type value.
Example 1:

The below statement extracts year from a timestamp:

SELECT EXTRACT(YEAR FROM TIMESTAMP '2020-12-31 13:30:15');
Output:



Example 2:

The below statement extracts the quarter from a timestamp:

SELECT EXTRACT(QUARTER FROM TIMESTAMP '2020-12-31 13:30:15');
Output:



Example 3:

The below statement extracts month from a timestamp:

SELECT EXTRACT(MONTH FROM TIMESTAMP '2020-12-31 13:30:15');
Output:




PostgreSQL – Errors and Messages
Last Updated : 28 Aug, 2020
In this article, we will look into the Errors in that are inbuilt in PostgreSQL and the process of raising an error in PostgreSQL through RAISE statement and to use the ASSERT statement to insert debugging checks into PL/pgSQL blocks.

To raise an error message user can implement the RAISE statement as follows:

Syntax: RAISE level format;
Let’s explore into the raise statement a bit more. Following the RAISE statement is the level option that specifies the error severity. PostgreSQL provides the following levels:

DEBUG
LOG
NOTICE
INFO
WARNING
EXCEPTION
If users don’t specify the level, by default, the RAISE statement will use the EXCEPTION level that raises an error and stops the current transaction. We will discuss the RAISE EXCEPTION later in the next section.

The format is a string that specifies the message. The format uses percentage ( %) placeholders that will be substituted by the next arguments. The number of placeholders must match the number of arguments, otherwise, PostgreSQL will report the following error message:

[Err] ERROR:  too many parameters specified for RAISE
Example:

The following example illustrates the RAISE statement that reports different messages at the current time.

DO $$ 
BEGIN 
  RAISE INFO 'information message %', now() ;
  RAISE LOG 'log message %', now();
  RAISE DEBUG 'debug message %', now();
  RAISE WARNING 'warning message %', now();
  RAISE NOTICE 'notice message %', now();
END $$;
Output:



Note: Not all messages are reported back to the client, only INFO, WARNING, and NOTICE level messages are reported to the client. This is controlled by the client_min_messages and log_min_messages configuration parameters.

Raising Errors:
To raise errors, you use the EXCEPTION level after the RAISE statement. Note that the RAISE statement uses the EXCEPTION level by default. Besides raising an error, you can add more detailed information by using the following clause with the RAISE statement:

USING option = expression
The options can be any one of the below:

MESSAGE: set error message text
HINT: provide the hint message so that the root cause of the error is easier to be discovered.
DETAIL:  give detailed information about the error.
ERRCODE: identify the error code, which can be either by condition name or directly five-character SQLSTATE code.
Example 1:

DO $$ 
DECLARE
  email varchar(255) := 'raju@geeksforgeeks.org';
BEGIN 
  -- check email for duplicate
  -- ...
  -- report duplicate email
  RAISE EXCEPTION 'Duplicate email: %', email 
        USING HINT = 'Check the email again';
END $$;
Output:



Example 2:

The following examples illustrate how to raise an SQLSTATE and its corresponding condition:

DO $$ 
BEGIN 
    --...
    RAISE SQLSTATE '2210B';
END $$;
DO $$ 
BEGIN 
    --...
    RAISE invalid_regular_expression;
END $$;
Output:



